/*
Navicat MySQL Data Transfer

Source Server         : MySQL51
Source Server Version : 50173
Source Host           : localhost:3307
Source Database       : mapleblog

Target Server Type    : MYSQL
Target Server Version : 50173
File Encoding         : 65001

Date: 2018-08-21 21:20:40
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `article`
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `article_id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `article_user_id` int(10) unsigned DEFAULT '1',
  `article_title` varchar(255) DEFAULT NULL,
  `article_content` mediumtext,
  `article_content_md` mediumtext,
  `article_parent_category_id` int(10) DEFAULT NULL,
  `article_child_category_id` int(10) DEFAULT NULL,
  `article_tag_ids` varchar(50) DEFAULT NULL,
  `article_view_count` int(10) DEFAULT '0',
  `article_comment_count` int(5) DEFAULT '0',
  `article_like_count` int(5) DEFAULT '0',
  `article_post_time` datetime DEFAULT NULL,
  `article_update_time` datetime DEFAULT NULL,
  `article_is_comment` int(2) unsigned DEFAULT NULL,
  `article_status` int(2) unsigned DEFAULT '1',
  `article_order` int(2) unsigned DEFAULT NULL,
  PRIMARY KEY (`article_id`)
) ENGINE=MyISAM AUTO_INCREMENT=52 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('1', '1', '[转载]SpringMVC中使用Interceptor拦截器', '<p>SpringMVC 中的Interceptor 拦截器也是相当重要和相当有用的，它的主要作用是拦截用户的请求并进行相应的处理。比如通过它来进行权限验证，或者是来判断用户是否登陆，或者是像12306 那样子判断当前时间是否是购票时间。</p><p><br></p><p>一、定义Interceptor实现类</p><p>SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的。在SpringMVC 中定义一个Interceptor 非常简单，主要有两种方式，第一种方式是要定义的Interceptor类要实现了Spring 的HandlerInterceptor 接口，或者是这个类继承实现了HandlerInterceptor 接口的类，比如Spring 已经提供的实现了HandlerInterceptor 接口的抽象类HandlerInterceptorAdapter ；第二种方式是实现Spring的WebRequestInterceptor接口，或者是继承实现了WebRequestInterceptor的类。</p><p><br></p><p>（一）实现HandlerInterceptor接口</p><p>HandlerInterceptor 接口中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。</p><p><br></p><p>（1 ）preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法，顾名思义，该方法将在请求处理之前进行调用。SpringMVC 中的Interceptor 是链式的调用的，在一个应用中或者说是在一个请求中可以同时存在多个Interceptor 。每个Interceptor 的调用会依据它的声明顺序依次执行，而且最先执行的都是Interceptor 中的preHandle 方法，所以可以在这个方法中进行一些前置初始化操作或者是对当前请求的一个预处理，也可以在这个方法中进行一些判断来决定请求是否要继续进行下去。该方法的返回值是布尔值Boolean 类型的，当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方法，如果已经是最后一个Interceptor 的时候就会是调用当前请求的Controller 方法。</p><p><br></p><p>（2 ）postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView) 方法，由preHandle 方法的解释我们知道这个方法包括后面要说到的afterCompletion 方法都只能是在当前所属的Interceptor 的preHandle 方法的返回值为true 时才能被调用。postHandle 方法，顾名思义就是在当前请求进行处理之后，也就是Controller 方法调用之后执行，但是它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作。postHandle 方法被调用的方向跟preHandle 是相反的，也就是说先声明的Interceptor 的postHandle 方法反而会后执行，这和Struts2里面的Interceptor 的执行过程有点类型。Struts2 里面的Interceptor 的执行过程也是链式的，只是在Struts2 里面需要手动调用ActionInvocation 的invoke 方法来触发对下一个Interceptor 或者是Action 的调用，然后每一个Interceptor 中在invoke 方法调用之前的内容都是按照声明顺序执行的，而invoke 方法之后的内容就是反向的。</p><p><br></p><p>（3 ）afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex) 方法，该方法也是需要当前对应的Interceptor 的preHandle 方法的返回值为true 时才会执行。顾名思义，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。</p><p><br></p><p>下面是一个简单的代码说明：</p><p><br></p><p>import javax.servlet.http.HttpServletRequest;</p><p>import javax.servlet.http.HttpServletResponse;</p><p>import org.springframework.web.servlet.HandlerInterceptor;</p><p>import org.springframework.web.servlet.ModelAndView;</p><p>public class SpringMVCInterceptor implements HandlerInterceptor {</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，SpringMVC中的Interceptor拦截器是链式的，可以同时存在&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 多个Interceptor，然后SpringMVC会根据声明的前后顺序一个接一个的执行，而且所有的Interceptor中的preHandle方法都会在&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* Controller方法调用之前调用。SpringMVC的这种Interceptor链式结构也是可以进行中断的，这种中断方式是令preHandle的返&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 回值为false，当preHandle的返回值为false的时候整个请求就结束了。&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public boolean preHandle(HttpServletRequest request,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HttpServletResponse response, Object handler) throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; return false;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 后，也就是在Controller的方法调用之后执行，但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 作。这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，这跟Struts2里面的拦截器的执行过程有点像，&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 或者是调用action，然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public void postHandle(HttpServletRequest request,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HttpServletResponse response, Object handler,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ModelAndView modelAndView) throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行，&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 这个方法的主要作用是用于清理资源的，当然这个方法也只能在当前这个Interceptor的preHandle方法的返回值为true时才会执行。&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public void afterCompletion(HttpServletRequest request,</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HttpServletResponse response, Object handler, Exception ex)</p><p>&nbsp; &nbsp; throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; }</p><p>}</p><p>（二）实现WebRequestInterceptor 接口</p><p>WebRequestInterceptor 中也定义了三个方法，我们也是通过这三个方法来实现拦截的。这三个方法都传递了同一个参数WebRequest ，那么这个WebRequest 是什么呢？这个WebRequest 是Spring 定义的一个接口，它里面的方法定义都基本跟HttpServletRequest 一样，在WebRequestInterceptor 中对WebRequest 进行的所有操作都将同步到HttpServletRequest 中，然后在当前请求中一直传递。</p><p><br></p><p>（1 ）preHandle(WebRequest request) 方法。该方法将在请求处理之前进行调用，也就是说会在Controller 方法调用之前被调用。这个方法跟HandlerInterceptor 中的preHandle 是不同的，主要区别在于该方法的返回值是void ，也就是没有返回值，所以我们一般主要用它来进行资源的准备工作，比如我们在使用Hibernate 的时候可以在这个方法中准备一个Hibernate 的Session 对象，然后利用WebRequest 的setAttribute(name, value, scope) 把它放到WebRequest 的属性中。这里可以说说这个setAttribute 方法的第三个参数scope ，该参数是一个Integer 类型的。在WebRequest 的父层接口RequestAttributes 中对它定义了三个常量：</p><p><br></p><p>SCOPE_REQUEST ：它的值是0 ，代表只有在request 中可以访问。</p><p><br></p><p>SCOPE_SESSION ：它的值是1 ，如果环境允许的话它代表的是一个局部的隔离的session，否则就代表普通的session，并且在该session范围内可以访问。</p><p><br></p><p>SCOPE_GLOBAL_SESSION ：它的值是2 ，如果环境允许的话，它代表的是一个全局共享的session，否则就代表普通的session，并且在该session 范围内可以访问。</p><p><br></p><p>（2 ）postHandle(WebRequest request, ModelMap model) 方法。该方法将在请求处理之后，也就是在Controller 方法调用之后被调用，但是会在视图返回被渲染之前被调用，所以可以在这个方法里面通过改变数据模型ModelMap 来改变数据的展示。该方法有两个参数，WebRequest 对象是用于传递整个请求数据的，比如在preHandle 中准备的数据都可以通过WebRequest 来传递和访问；ModelMap 就是Controller 处理之后返回的Model 对象，我们可以通过改变它的属性来改变返回的Model 模型。</p><p><br></p><p>（3 ）afterCompletion(WebRequest request, Exception ex) 方法。该方法会在整个请求处理完成，也就是在视图返回并被渲染之后执行。所以在该方法中可以进行资源的释放操作。而WebRequest 参数就可以把我们在preHandle 中准备的资源传递到这里进行释放。Exception 参数表示的是当前请求的异常对象，如果在Controller中抛出的异常已经被Spring 的异常处理器给处理了的话，那么这个异常对象就是是null 。</p><p><br></p><p>&nbsp;</p><p><br></p><p>下面是一个简单的代码说明：</p><p><br></p><p>import org.springframework.ui.ModelMap;</p><p>import org.springframework.web.context.request.WebRequest;</p><p>import org.springframework.web.context.request.WebRequestInterceptor;</p><p>public class AllInterceptor implements WebRequestInterceptor {</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 在请求处理之前执行，该方法主要是用于准备资源数据的，然后可以把它们当做请求属性放到WebRequest中&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public void preHandle(WebRequest request) throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"AllInterceptor...............................\");</p><p>&nbsp; &nbsp; &nbsp; &nbsp; request.setAttribute(\"request\", \"request\", WebRequest.SCOPE_REQUEST);//这个是放到request范围内的，所以只能在当前请求中的request中获取到&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; request.setAttribute(\"session\", \"session\", WebRequest.SCOPE_SESSION);//这个是放到session范围内的，如果环境允许的话它只能在局部的隔离的会话中访问，否则就是在普通的当前会话中可以访问&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; request.setAttribute(\"globalSession\", \"globalSession\", WebRequest.SCOPE_GLOBAL_SESSION);//如果环境允许的话，它能在全局共享的会话中访问，否则就是在普通的当前会话中访问&nbsp;&nbsp;</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 该方法将在Controller执行之后，返回视图之前执行，ModelMap表示请求Controller处理之后返回的Model对象，所以可以在&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 这个方法中修改ModelMap的属性，从而达到改变返回的模型的效果。&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public void postHandle(WebRequest request, ModelMap map) throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; for (String key:map.keySet())</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(key + \"-------------------------\");;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; map.put(\"name3\", \"value3\");</p><p>&nbsp; &nbsp; &nbsp; &nbsp; map.put(\"name1\", \"name1\");</p><p>&nbsp; &nbsp; }</p><p>&nbsp; &nbsp; /**&nbsp;</p><p>&nbsp; &nbsp; &nbsp;* 该方法将在整个请求完成之后，也就是说在视图渲染之后进行调用，主要用于进行一些资源的释放&nbsp;</p><p>&nbsp; &nbsp; &nbsp;*/</p><p>&nbsp; &nbsp; @Override</p><p>&nbsp; &nbsp; public void afterCompletion(WebRequest request, Exception exception)</p><p>&nbsp; &nbsp; throws Exception {</p><p>&nbsp; &nbsp; &nbsp; &nbsp; // TODO Auto-generated method stub&nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(exception + \"-=-=--=--=-=-=-=-=-=-=-=-==-=--=-=-=-=\");</p><p>&nbsp; &nbsp; }</p><p>}</p><p><br></p><p>&nbsp;二、把定义的拦截器类加到SpringMVC的拦截体系中</p><p>1.在SpringMVC的配置文件中加上支持MVC的schema</p><p><br></p><p>xmlns:mvc=\"http://www.springframework.org/schema/mvc\"</p><p>xsi:schemaLocation=\" http://www.springframework.org/schema/mvc</p><p>&nbsp; &nbsp; http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd\"</p><p>下面是我的声明示例：</p><p><br></p><p><br></p><p><br></p><p>这样在SpringMVC的配置文件中就可以使用mvc标签了，mvc标签中有一个mvc:interceptors是用于声明SpringMVC的拦截器的。</p><p><br></p><p>&nbsp;</p><p><br></p><p>（二）使用mvc:interceptors标签来声明需要加入到SpringMVC拦截器链中的拦截器</p><p><br></p><p><br></p><p>&nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p><p>&nbsp; &nbsp;&nbsp;</p><p><br></p><p><br></p><p>由上面的示例可以看出可以利用mvc:interceptors标签声明一系列的拦截器，然后它们就可以形成一个拦截器链，拦截器的执行顺序是按声明的先后顺序执行的，先声明的拦截器中的preHandle方法会先执行，然而它的postHandle方法和afterCompletion方法却会后执行。</p><p><br></p><p>在mvc:interceptors标签下声明interceptor主要有两种方式：</p><p><br></p><p>（1）直接定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。</p><p><br></p><p>（2）使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。</p><p><br></p><p>经过上述两步之后，定义的拦截器就会发生作用对特定的请求进行拦截了。</p><p><br></p><p><br></p><p><br></p>', null, '1', '9', '12', '15', '0', '0', '2017-10-06 23:54:18', '2017-10-07 15:31:36', '1', '1', '1');
INSERT INTO `article` VALUES ('2', '1', 'springmvc 表单中文乱码解决方案', '<p>基本上通过在 web.xml 了配置拦截器就可以解决。</p><p>这里需要注意的是，最好把这段代码放在web.xml中开头的位置，因为拦截有顺序，如果放在后面的话容易拦截不到。</p><p>拦截器代码如下</p><p><div><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol start=\"1\" class=\"dp-xml\"><li class=\"alt\"><span><span class=\"comments\">&lt;!--post乱码过滤器--&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"comments\">&lt;!--&nbsp;配置springMVC编码过滤器&nbsp;--&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span><span class=\"tag\">&lt;</span><span class=\"tag-name\">filter</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">filter-name</span><span class=\"tag\">&gt;</span><span>CharacterEncodingFilter</span><span class=\"tag\">&lt;/</span><span class=\"tag-name\">filter-name</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">filter-class</span><span class=\"tag\">&gt;</span><span>org.springframework.web.filter.CharacterEncodingFilter</span><span class=\"tag\">&lt;/</span><span class=\"tag-name\">filter-class</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\">&lt;!--&nbsp;设置过滤器中的属性值&nbsp;--&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">init-param</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">param-name</span><span class=\"tag\">&gt;</span><span>encoding</span><span class=\"tag\">&lt;/</span><span class=\"tag-name\">param-name</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">param-value</span><span class=\"tag\">&gt;</span><span>UTF-8</span><span class=\"tag\">&lt;/</span><span class=\"tag-name\">param-value</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;/</span><span class=\"tag-name\">init-param</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\">&lt;!--&nbsp;启动过滤器&nbsp;--&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">init-param</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">param-name</span><span class=\"tag\">&gt;</span><span>forceEncoding</span><span class=\"tag\">&lt;/</span><span class=\"tag-name\">param-name</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">param-value</span><span class=\"tag\">&gt;</span><span>true</span><span class=\"tag\">&lt;/</span><span class=\"tag-name\">param-value</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;/</span><span class=\"tag-name\">init-param</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"tag\">&lt;/</span><span class=\"tag-name\">filter</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span><span class=\"comments\">&lt;!--&nbsp;过滤所有请求&nbsp;--&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"tag\">&lt;</span><span class=\"tag-name\">filter-mapping</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">filter-name</span><span class=\"tag\">&gt;</span><span>CharacterEncodingFilter</span><span class=\"tag\">&lt;/</span><span class=\"tag-name\">filter-name</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">url-pattern</span><span class=\"tag\">&gt;</span><span>/*</span><span class=\"tag\">&lt;/</span><span class=\"tag-name\">url-pattern</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span><span class=\"tag\">&lt;/</span><span class=\"tag-name\">filter-mapping</span><span class=\"tag\">&gt;</span><span>&nbsp;&nbsp;</span></span></li></ol></div></div><p><br></p><p>顺便再补充其他的几个可能原因。</p></p><p>1、数据库和数据表不是 utf-8 编码</p><p>就在前几天，我遇到的问题正是这个。当时是刚从 windows 搬到 mac。也是在提交 post 表单的时候，中文一直是乱码，后台百度发现，原来是 navicat 的原因。就是在新建 数据库连接(注意是连接)，不能选择 utf-8，应该选择默认的自动。这个地方很坑人。</p><p>数据库和数据表当然是 utf-8，一般这种情况很少出错。</p><p>&nbsp;</p><p>2、修改 Tomcat 的 server.xml 文件，添加 utf-8 编码</p><p><div><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol start=\"1\" class=\"dp-j\"><li class=\"alt\"><span><span>&lt;Connector&nbsp;port=</span><span class=\"string\">\"8080\"</span><span>&nbsp;protocol=</span><span class=\"string\">\"HTTP/1.1\"</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connectionTimeout=<span class=\"string\">\"20000\"</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redirectPort=<span class=\"string\">\"8443\"</span><span>&nbsp;URIEncoding=</span><span class=\"string\">\"UTF-8\"</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useBodyEncodingForURI=<span class=\"string\">\"true\"</span><span>&nbsp;/&gt;&nbsp;&nbsp;</span></span></li></ol></div></div><br></p><p>3、注意你的 IDE (如Eclipse,IntelliJ IDEA)的 jsp 文件编码，一般在右下角可以看出来，通常我们也要把默认的编码设置为 utf-8。</p><p>&nbsp;</p><p>4、还有一种方法就是 直接对接收到的数据编码转换，我感觉有点麻烦，所以不是很喜欢</p><p><div><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol start=\"1\" class=\"dp-j\"><li class=\"alt\"><span><span>String&nbsp;name=</span><span class=\"keyword\">new</span><span>&nbsp;String((user.getUname()).getBytes(</span><span class=\"string\">\"ISO-8859-1\"</span><span>),</span><span class=\"string\">\"utf8\"</span><span>);&nbsp;&nbsp;</span></span></li></ol></div></div><p><span>总结：一般来说，第一种拦截器方法是可用的，要注意的是要把拦截器代码放到 web.xml 头部，防止拦截不到，还有表单一定要 post 方式提交。</span></p></p>', null, '1', '9', '12', '11', '0', '0', '2017-10-07 12:12:42', '2017-10-07 15:34:10', '1', '1', '1');
INSERT INTO `article` VALUES ('4', '1', '[转载]HTTP的幂等性', '<div id=\"header\"><h2>理解HTTP幂等性</h2></div><div id=\"post_detail\"><div class=\"post\"><div class=\"postText\"><div id=\"cnblogs_post_body\"><p>基于HTTP协议的Web API是时下最为流行的一种分布式服务提供方式。无论是在大型互联网应用还是企业级架构中，我们都见到了越来越多的SOA或RESTful的Web API。为什么Web API如此流行呢？我认为很大程度上应归功于简单有效的HTTP协议。HTTP协议是一种分布式的面向资源的网络应用层协议，无论是服务器端提供Web服务，还是客户端消费Web服务都非常简单。再加上浏览器、<a href=\"https://liuyanzhao.com/tag/java/\" title=\"查看与 Java 相关的文章\" target=\"_blank\">Java</a>script、AJAX、JSON以及HTML5等技术和工具的发展，互联网应用架构设计表现出了从传统的PHP、JSP、ASP.NET等服务器端动态网页向Web API + RIA（富互联网应用）过渡的趋势。Web API专注于提供业务服务，RIA专注于用户界面和交互设计，从此两个领域的分工更加明晰。在这种趋势下，Web API设计将成为服务器端程序员的必修课。然而，正如简单的<a href=\"https://liuyanzhao.com/tag/java/\" title=\"查看与 Java 相关的文章\" target=\"_blank\">Java</a>语言并不意味着高质量的<a href=\"https://liuyanzhao.com/tag/java/\" title=\"查看与 Java 相关的文章\" target=\"_blank\">Java</a>程序，简单的HTTP协议也不意味着高质量的Web API。要想设计出高质量的Web API，还需要深入理解分布式系统及HTTP协议的特性。</p><h2>幂等性定义</h2><p>本文所要探讨的正是HTTP协议涉及到的一种重要性质：幂等性(Idempotence)。在HTTP/1.1规范中幂等性的定义是：</p><blockquote><p>Methods can also have the property of \"idempotence\" in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.</p></blockquote><p>从定义上看，HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性属于语义范畴，正如编译器只能帮助检查语法错误一样，HTTP规范也没有办法通过消息格式等语法手段来定义它，这可能是它不太受到重视的原因之一。但实际上，幂等性是分布式系统设计中十分重要的概念，而HTTP的分布式本质也决定了它在HTTP中具有重要地位。</p><h2>分布式事务 vs 幂等设计</h2><p>为什么需要幂等性呢？我们先从一个例子说起，假设有一个从账户取钱的远程API（可以是HTTP的，也可以不是），我们暂时用类函数的方式记为：</p><pre><code>bool withdraw(account_id, amount)\r\n</code></pre><p>withdraw的语义是从account_id对应的账户中扣除amount数额的钱；如果扣除成功则返回true，账户余额减少amount；如果扣除失败则返回false，账户余额不变。值得注意的是：和本地环境相比，我们不能轻易假设分布式环境的可靠性。一种典型的情况是withdraw请求已经被服务器端正确处理，但服务器端的返回结果由于网络等原因被掉丢了，导致客户端无法得知处理结果。如果是在网页上，一些不恰当的设计可能会使用户认为上一次操作失败了，然后刷新页面，这就导致了withdraw被调用两次，账户也被多扣了一次钱。如图1所示：</p><p><img src=\"/uploads/2017/10/20171007153621950.png\" alt=\"20171007153621950.png\"><br></p><p>图1</p><p>这个问题的解决方案一是采用分布式事务，通过引入支持分布式事务的中间件来保证withdraw功能的事务性。分布式事务的优点是对于调用者很简单，复杂性都交给了中间件来管理。缺点则是一方面架构太重量级，容易被绑在特定的中间件上，不利于异构系统的集成；另一方面分布式事务虽然能保证事务的ACID性质，而但却无法提供性能和可用性的保证。</p><p>另一种更轻量级的解决方案是幂等设计。我们可以通过一些技巧把withdraw变成幂等的，比如：</p><pre><code>int create_ticket() \r\nbool idempotent_withdraw(ticket_id, account_id, amount)\r\n</code></pre><p>create_ticket的语义是获取一个服务器端生成的唯一的处理号ticket_id，它将用于标识后续的操作。idempotent_withdraw和withdraw的区别在于关联了一个ticket_id，一个ticket_id表示的操作至多只会被处理一次，每次调用都将返回第一次调用时的处理结果。这样，idempotent_withdraw就符合幂等性了，客户端就可以放心地多次调用。</p><p>基于幂等性的解决方案中一个完整的取钱流程被分解成了两个步骤：1.调用create_ticket()获取ticket_id；2.调用idempotent_withdraw(ticket_id, account_id, amount)。虽然create_ticket不是幂等的，但在这种设计下，它对系统状态的影响可以忽略，加上idempotent_withdraw是幂等的，所以任何一步由于网络等原因失败或超时，客户端都可以重试，直到获得结果。如图2所示：</p><p><img src=\"/uploads/2017/10/20171007153648208.png\" alt=\"20171007153648208.png\"><br></p><div id=\"cnblogs_post_body\"><p>图2</p><p>和分布式事务相比，幂等设计的优势在于它的轻量级，容易适应异构环境，以及性能和可用性方面。在某些性能要求比较高的应用，幂等设计往往是唯一的选择。</p><h2>HTTP的幂等性</h2><p>HTTP协议本身是一种面向资源的应用层协议，但对HTTP协议的使用实际上存在着两种不同的方式：一种是RESTful的，它把HTTP当成应用层协议，比较忠实地遵守了HTTP协议的各种规定；另一种是SOA的，它并没有完全把HTTP当成应用层协议，而是把HTTP协议作为了传输层协议，然后在HTTP之上建立了自己的应用层协议。本文所讨论的HTTP幂等性主要针对RESTful风格的，不过正如上一节所看到的那样，幂等性并不属于特定的协议，它是分布式系统的一种特性；所以，不论是SOA还是RESTful的Web API设计都应该考虑幂等性。下面将介绍HTTP GET、DELETE、PUT、POST四种主要方法的语义和幂等性。</p><p>HTTP GET方法用于获取资源，不应有副作用，所以是幂等的。比如：GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</p><p>HTTP DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p><p>比较容易混淆的是HTTP POST和PUT。POST和PUT的区别容易被简单地误认为“POST表示创建资源，PUT表示更新资源”；而实际上，二者均可用于创建资源，更为本质的差别是在幂等性方面。在HTTP规范中对POST和PUT是这样定义的：</p><blockquote><p>The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line ...... If a resource has been created on the origin server, the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.</p><p>The PUT method requests that the enclosed entity be stored under the supplied Request-URI. If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI.</p></blockquote><p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p><p>在介绍了几种操作的语义和幂等性之后，我们来看看如何通过Web API的形式实现前面所提到的取款功能。很简单，用POST /tickets来实现create_ticket；用PUT /accounts/account_id/ticket_id&amp;amount=xxx来实现idempotent_withdraw。值得注意的是严格来讲amount参数不应该作为URI的一部分，真正的URI应该是/accounts/account_id/ticket_id，而amount应该放在请求的body中。这种模式可以应用于很多场合，比如：论坛网站中防止意外的重复发帖。</p><h2>总结</h2><p>上面简单介绍了幂等性的概念，用幂等设计取代分布式事务的方法，以及HTTP主要方法的语义和幂等性特征。其实，如果要追根溯源，幂等性是数学中的一个概念，表达的是N次变换与1次变换的结果相同，有兴趣的读者可以从Wikipedia上进一步了解。</p><h2>参考</h2><p><a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html\">RFC 2616, Hypertext Transfer Protocol -- HTTP/1.1, Method Definitions</a></p><p><a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://devhawk.net/2007/11/09/the-importance-of-idempotence/\">The Importance of Idempotence</a></p><p><a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://stackoverflow.com/questions/630453/put-vs-post-in-rest\">Stackoverflow - PUT vs POST in REST</a></p></div><p>&nbsp;</p><p>&nbsp;</p><p>原文地址：<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html</a></p></div></div></div></div>', null, '10', '14', '6', '7', '0', '0', '2017-10-07 15:37:20', '2017-10-07 15:37:20', '1', '1', '1');
INSERT INTO `article` VALUES ('3', '1', '使用rapid-framework继承jsp页面', '<p>对于多张网页页面，许多部分都是相同的，应该继承同一个页面，该页面是所有页面的父页面。<br></p><p>后来搜了一下找到一个<code>rapid-framework</code>的东西，由于我使用的是<code>maven</code>，所以引入很简单。</p><p></p><div><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol start=\"1\" class=\"dp-xml\"><li class=\"alt\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">dependency</span><span class=\"tag\">&gt;</span>&nbsp;&nbsp;</li><li class=\"\">&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">groupId</span><span class=\"tag\">&gt;</span>com.googlecode.rapid-framework<span class=\"tag\"><!--</span--><span class=\"tag-name\">groupId</span><span class=\"tag\">&gt;</span>&nbsp;&nbsp;</span></li><li class=\"alt\">&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">artifactId</span><span class=\"tag\">&gt;</span>rapid-core<span class=\"tag\"><!--</span--><span class=\"tag-name\">artifactId</span><span class=\"tag\">&gt;</span>&nbsp;&nbsp;</span></li><li class=\"\">&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">version</span><span class=\"tag\">&gt;</span>4.0.5<span class=\"tag\"><!--</span--><span class=\"tag-name\">version</span><span class=\"tag\">&gt;</span>&nbsp;&nbsp;</span></li><li class=\"alt\"><span class=\"tag\"><!--</span--><span class=\"tag-name\">dependency</span><span class=\"tag\">&gt;</span>&nbsp;&nbsp;</span></li></ol></div></div><p>父页面</p><p></p><div><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol start=\"1\" class=\"dp-xml\"><li class=\"alt\">...&nbsp;&nbsp;</li><li class=\"\"><span class=\"tag\">&lt;</span>%@&nbsp;taglib&nbsp;<span class=\"attribute\">prefix</span>=<span class=\"attribute-value\">\"rapid\"</span>&nbsp;<span class=\"attribute\">uri</span>=<span class=\"attribute-value\">\"http://www.rapid-framework.org.cn/rapid\"</span>&nbsp;%<span class=\"tag\">&gt;</span>&nbsp;&nbsp;</li><li class=\"alt\">...&nbsp;&nbsp;</li><li class=\"\">&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">body</span><span class=\"tag\">&gt;</span>&nbsp;&nbsp;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!-- 正文 --></span>&nbsp;&nbsp;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">rapid:block</span>&nbsp;<span class=\"attribute\">name</span>=<span class=\"attribute-value\">\"content\"</span><span class=\"tag\">&gt;</span>&nbsp;&nbsp;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;123&nbsp;&nbsp;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">rapid:block</span><span class=\"tag\">&gt;</span>&nbsp;&nbsp;</span></li><li class=\"alt\"><span class=\"tag\"><!--</span--><span class=\"tag-name\">body</span><span class=\"tag\">&gt;</span>&nbsp;&nbsp;</span></li></ol></div></div><p></p><p></p><ul></ul><p>&nbsp;<code><rapid:block name=\"content\"></rapid:block></code>定义叫做<code>content</code>的一块，该部分可以让子页面重写。</p><p></p><p>子页面</p><p></p><div><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol start=\"1\" class=\"dp-xml\"><li class=\"alt\"><span class=\"tag\">&lt;</span>%@&nbsp;page&nbsp;<span class=\"attribute\">contentType</span>=<span class=\"attribute-value\">\"text/html;charset=UTF-8\"</span>&nbsp;<span class=\"attribute\">language</span>=<span class=\"attribute-value\">\"java\"</span>&nbsp;%<span class=\"tag\">&gt;</span>&nbsp;&nbsp;</li><li class=\"\"><span class=\"tag\">&lt;</span>%@&nbsp;taglib&nbsp;<span class=\"attribute\">prefix</span>=<span class=\"attribute-value\">\"rapid\"</span>&nbsp;<span class=\"attribute\">uri</span>=<span class=\"attribute-value\">\"http://www.rapid-framework.org.cn/rapid\"</span>&nbsp;%<span class=\"tag\">&gt;</span>&nbsp;&nbsp;</li><li class=\"alt\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">rapid:override</span>&nbsp;<span class=\"attribute\">name</span>=<span class=\"attribute-value\">\"content\"</span><span class=\"tag\">&gt;</span>&nbsp;&nbsp;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;这是内容&nbsp;&nbsp;</li><li class=\"alt\"><span class=\"tag\"><!--</span--><span class=\"tag-name\">rapid:override</span><span class=\"tag\">&gt;</span>&nbsp;&nbsp;</span></li><li class=\"\"><span class=\"tag\">&lt;</span>%@&nbsp;include&nbsp;<span class=\"attribute\">file</span>=<span class=\"attribute-value\">\"base.jsp\"</span>%<span class=\"tag\">&gt;</span>&nbsp;&nbsp;</li></ol></div></div><p></p><p></p><li>&nbsp;&lt;%@ include file=\"base.jsp\"%&gt;引入父页面</li><p></p><li>重写父页面中叫做content的部分。</li><p></p><li>访问子页面，父页面内部的元素不会显示，代替的是子页面重写的内容。</li>', null, '1', '8', '18', '10', '0', '0', '2017-10-07 15:30:17', '2017-10-07 15:34:45', '1', '1', '1');
INSERT INTO `article` VALUES ('5', '1', 'JDBC常用API和使用', '<h2>一、JDBC 常用 API</h2><p><strong>1、Connection 接口</strong></p><table class=\"layui-table\" width=\"695\"><tbody><tr><td>方法名称</td><td>功能描述</td></tr><tr><td>getMetaData()</td><td>该方法用于返回数据库的元数据的 DatabaseMetaData 对象</td></tr><tr><td>createStatement</td><td>用于创建一个 Statement 对象来将 SQL 语句发送到数据库</td></tr><tr><td>preparedStatement(String sql)</td><td>用于创建一个 PreparedStatement 对象来将参数化的SQL语句发送到数据库</td></tr><tr><td>prepareCall(String sql)</td><td>用于创建一个 CallableStatement 对象来调用数据库存储过程</td></tr></tbody></table><p><strong>2、Statement 接口</strong></p><table class=\"layui-table\" width=\"696\"><tbody><tr><td>方法名称</td><td>功能描述</td></tr><tr><td>boolean execute(String sql)</td><td>用于执行各种 SQL 语句,该方法返回一个 boolean 类型的值。如果为 true,表示所执行的 SQL 语句具备查询结果，可通过 Statement 的getResultSet() 方法查询结果</td></tr><tr><td>int executeUpdate(String sql)</td><td>用于执行 SQL 中的 insert、update 和 delete 语句，该方法返回一个 int 类型的值，表示影响数据库中的行数</td></tr><tr><td>ResultSet executeQuery(String sql)</td><td>用于执行 SQL 中的 select 语句（查询，遍历），该方法返回一个表示查询结果的 ResultSet 对象</td></tr></tbody></table><p><strong>&nbsp;<span>execute是executeQuery和executeUpdate的综合.</span></strong></p><p><strong><span>通常我们没有必要使用execute方法来执行SQL语句，而是使用 executeQuery 或 executeUpdate 更适合。</span></strong></p><p>具体可参考：<a href=\"https://liuyanzhao.com/5278.html\" target=\"_blank\" rel=\"noopener noreferrer\">execute、executeUpdate、executeQuery三者的区别</a></p><p><strong>3、PreparedStatement 接口</strong></p><table class=\"layui-table\" width=\"695\"><tbody><tr><td>方法名称</td><td>功能描述</td></tr><tr><td>executeUpdate()</td><td>在此 PreparedStatement 对象中执行 SQL 语句，该语句必须是一个 DML 语句，或者无返回内容的 SQL 语句，比如 DDL 语句</td></tr><tr><td>executeQuery()</td><td>在此 PreparedStatement 对象中执行 SQL 语句，该方法返回的是 ResultSet 对象</td></tr><tr><td>setInt(int parameterIndex, int x)</td><td>将指定的参数设置为 int 值</td></tr><tr><td>setFloat(int parameterIndex, float x)</td><td>将指定的参数设置为 Float 值</td></tr><tr><td>setString(int parameterIndex, String x)</td><td>将指定参数设置的给定的 Date 值</td></tr><tr><td>setDate(int parameterIndex, Date x)</td><td>将指定参数设置给定的 Date 值</td></tr><tr><td>addBatch()</td><td>将一组参数添加到此 PreparedStatement 对象的批处理命令中</td></tr><tr><td>setCharacterStream(parameterIndex, reader, length)</td><td>将指定的输入流写入数据库的文本字段</td></tr><tr><td>setBinaryStream(parameterIndex, x, length)</td><td>将二进制的输入流数据写入到二进制的字段中</td></tr></tbody></table><p>DML 语句：SELECT、UPDATE、INSERT、DELETE</p><p>DLL 语句：CREATE DROP ALERT</p><p>具体参考:&nbsp;<a href=\"https://liuyanzhao.com/5283.html\" target=\"_blank\" rel=\"noopener noreferrer\">sql语句分为三类(DML,DDL,DCL)-介绍</a></p><p>4、ResultSet 接口</p><table class=\"layui-table\"><tbody><tr><td>getString(int columnIndex)</td><td>用于获取 指定字段的 String 类型的值，参数 columnIndex 代表字段的索引</td></tr><tr><td>getString(String columnName)</td><td>&nbsp;用于获取指定字段的 String 类型的值，参数 columnIndex 代表字段名称</td></tr><tr><td>getInt(int columnIndex)</td><td>&nbsp;用于获取指定字段的 int 类型的值，参数 columnIndex 代表字段的索引</td></tr><tr><td>getInt(String columnName)</td><td>&nbsp;用于获取指定字段的 int 类型的值，参数 columnIndex 代表字段名称</td></tr><tr><td>getDate(int columnIndex)</td><td>&nbsp;用于获取指定字段的 Date类型的值，参数 columnIndex 代表字段索引</td></tr><tr><td>getDate(String columnName)</td><td>&nbsp;用于获取指定字段的 Date类型的值，参数 columnIndex 代表字段名称</td></tr><tr><td>next()</td><td>&nbsp;将游标从当前位置移到下一位置</td></tr><tr><td>absolute(int row)</td><td>将游标移到此 ResultSet 对象的指定行</td></tr><tr><td>afterLast()</td><td>将游标移动到此 ResultSet 对象的末尾，即最后一行之后</td></tr><tr><td>beforeFirst()</td><td>将游标移动到此 ResultSet 对象开头，即第一行之前</td></tr><tr><td>previous()</td><td>将游标移动到此 ResultSet 对象的上一行</td></tr><tr><td>last()</td><td>将游标移动到此 &nbsp;Result 对象的最后一行</td></tr></tbody></table><h2>二、案例</h2><p><strong>1、往数据库里添加数据</strong></p><p>① 数据表结构如下</p><p><img src=\"/uploads/2017/10/2017100715402014.png\" alt=\"2017100715402014.png\"><br></p><p><span>② 代码如下</span></p><p><span></span></p><div><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol start=\"1\" class=\"dp-j\"><li class=\"alt\"><span><span class=\"keyword\">package</span><span>&nbsp;com.test;&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"keyword\">import</span><span>&nbsp;java.sql.Connection;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span><span class=\"keyword\">import</span><span>&nbsp;java.sql.Date;&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"keyword\">import</span><span>&nbsp;java.sql.DriverManager;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span><span class=\"keyword\">import</span><span>&nbsp;java.sql.PreparedStatement;&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"keyword\">import</span><span>&nbsp;java.sql.SQLException;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span><span class=\"keyword\">import</span><span>&nbsp;java.text.ParseException;&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"keyword\">import</span><span>&nbsp;java.text.SimpleDateFormat;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span><span class=\"comment\">/*</span>&nbsp;</span></li><li class=\"\"><span><span class=\"comment\">&nbsp;*&nbsp;@author wjw</span></span></li><li class=\"alt\"><span><span class=\"comment\">&nbsp;*/</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"keyword\">public</span><span>&nbsp;</span><span class=\"keyword\">class</span><span>&nbsp;Demo1&nbsp;{&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span><span>&nbsp;</span><span class=\"keyword\">static</span><span>&nbsp;</span><span class=\"keyword\">final</span><span>&nbsp;String&nbsp;URL&nbsp;=&nbsp;</span><span class=\"string\">\"jdbc:mysql://127.0.0.1:3306/jdbc_study?useUnicode=true&amp;characterEncoding=utf8\"</span><span>;&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span><span>&nbsp;</span><span class=\"keyword\">static</span><span>&nbsp;</span><span class=\"keyword\">final</span><span>&nbsp;String&nbsp;USER&nbsp;=&nbsp;</span><span class=\"string\">\"root\"</span><span>;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span><span>&nbsp;</span><span class=\"keyword\">static</span><span>&nbsp;</span><span class=\"keyword\">final</span><span>&nbsp;String&nbsp;PASSWORD&nbsp;=&nbsp;</span><span class=\"string\">\"\"</span><span>;&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span><span>&nbsp;</span><span class=\"keyword\">static</span><span>&nbsp;Connection&nbsp;conn&nbsp;=&nbsp;</span><span class=\"keyword\">null</span><span>;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span><span>&nbsp;</span><span class=\"keyword\">static</span><span>&nbsp;</span><span class=\"keyword\">void</span><span>&nbsp;main(String[]&nbsp;args)&nbsp;</span><span class=\"keyword\">throws</span><span>&nbsp;ClassNotFoundException,&nbsp;SQLException,&nbsp;ParseException&nbsp;{&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//1、加载驱动，需要提前把&nbsp;jar&nbsp;包添加到&nbsp;classpath&nbsp;中</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class.forName(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//2、创建应用程序与数据库连接的&nbsp;Connection&nbsp;对象</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn&nbsp;=&nbsp;DriverManager.getConnection(URL,&nbsp;USER,&nbsp;PASSWORD);&nbsp;&nbsp;</span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//3、要执行的&nbsp;sql&nbsp;语句：name,password,email,status通过占位符填数,create_date&nbsp;自动为当前时间</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;sql&nbsp;=&nbsp;<span class=\"string\">\"&nbsp;INSERT&nbsp;INTO&nbsp;users\"</span><span>+&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"string\">\"(name,password,birthday,email,create_date,status)&nbsp;\"</span><span>+&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"string\">\"VALUES(\"</span><span>+&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"string\">\"?,?,?,?,current_date(),?)\"</span><span>;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//4、创建执行&nbsp;SQL&nbsp;语句的&nbsp;PreparedStatement&nbsp;对象</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreparedStatement&nbsp;ptmt&nbsp;=&nbsp;conn.prepareStatement(sql);&nbsp;&nbsp;</span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ptmt.setString(<span class=\"number\">1</span><span>,&nbsp;</span><span class=\"string\">\"小美\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ptmt.setString(<span class=\"number\">2</span><span>,&nbsp;</span><span class=\"string\">\"123456\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ptmt.setDate(<span class=\"number\">3</span><span>,</span><span class=\"keyword\">new</span><span>&nbsp;Date((</span><span class=\"keyword\">new</span><span>&nbsp;SimpleDateFormat(</span><span class=\"string\">\"yyyy-MM-dd\"</span><span>).parse(</span><span class=\"string\">\"2011-10-1\"</span><span>)).getTime())&nbsp;);&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ptmt.setString(<span class=\"number\">4</span><span>,&nbsp;</span><span class=\"string\">\"xiaomei@126.com\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ptmt.setInt(<span class=\"number\">5</span><span>,&nbsp;</span><span class=\"number\">1</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//5、真正执行&nbsp;sql&nbsp;语句，并返回影响的行数</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">int</span><span>&nbsp;x&nbsp;=&nbsp;ptmt.executeUpdate();&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"影响行数：\"</span><span>&nbsp;+&nbsp;x);&nbsp;</span><span class=\"comment\">//返回1</span><span>&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=\"\"><span>}&nbsp;&nbsp;</span></li></ol></div></div><br><p></p><p>③运行结果</p><p>上面的操作，将在 jdbc_study 数据库的 users 表中添加一条记录，终端显示 1</p><p><strong>2、查询（打印）数据库信息</strong></p><p>①数据表如下</p><p><img src=\"/uploads/2017/10/20171007154127663.png\" alt=\"20171007154127663.png\"><br></p><p><span>②代码如下</span></p><p><span></span></p><div><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol start=\"1\" class=\"dp-j\"><li class=\"alt\"><span><span class=\"keyword\">package</span><span>&nbsp;com.test;&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"keyword\">import</span><span>&nbsp;java.sql.Connection;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span><span class=\"keyword\">import</span><span>&nbsp;java.sql.Date;&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"keyword\">import</span><span>&nbsp;java.sql.DriverManager;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span><span class=\"keyword\">import</span><span>&nbsp;java.sql.PreparedStatement;&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"keyword\">import</span><span>&nbsp;java.sql.ResultSet;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span><span class=\"keyword\">import</span><span>&nbsp;java.sql.SQLException;&nbsp;&nbsp;</span></span></li><li class=\"\"><span><span class=\"keyword\">import</span><span>&nbsp;java.text.ParseException;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><p><span><span class=\"keyword\">import</span><span>&nbsp;java.text.SimpleDateFormat;&nbsp;&nbsp; </span></span></p></li><li class=\"alt\"><br></li><li class=\"alt\"><span><span class=\"keyword\">public</span><span>&nbsp;</span><span class=\"keyword\">class</span><span>&nbsp;Demo2&nbsp;{&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span><span>&nbsp;</span><span class=\"keyword\">static</span><span>&nbsp;</span><span class=\"keyword\">final</span><span>&nbsp;String&nbsp;URL&nbsp;=&nbsp;</span><span class=\"string\">\"jdbc:mysql://127.0.0.1:3306/jdbc_study?useUnicode=true&amp;characterEncoding=utf8\"</span><span>;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span><span>&nbsp;</span><span class=\"keyword\">static</span><span>&nbsp;</span><span class=\"keyword\">final</span><span>&nbsp;String&nbsp;USER&nbsp;=&nbsp;</span><span class=\"string\">\"root\"</span><span>;&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span><span>&nbsp;</span><span class=\"keyword\">static</span><span>&nbsp;</span><span class=\"keyword\">final</span><span>&nbsp;String&nbsp;PASSWORD&nbsp;=&nbsp;</span><span class=\"string\">\"\"</span><span>;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span><span>&nbsp;</span><span class=\"keyword\">static</span><span>&nbsp;Connection&nbsp;conn&nbsp;=&nbsp;</span><span class=\"keyword\">null</span><span>;&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span><span>&nbsp;</span><span class=\"keyword\">static</span><span>&nbsp;</span><span class=\"keyword\">void</span><span>&nbsp;main(String[]&nbsp;args)&nbsp;</span><span class=\"keyword\">throws</span><span>&nbsp;ClassNotFoundException,&nbsp;SQLException,&nbsp;ParseException&nbsp;{&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//1、加载驱动，需要提前把&nbsp;jar&nbsp;包添加到&nbsp;classpath&nbsp;中</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class.forName(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//2、创建应用程序与数据库连接的&nbsp;Connection&nbsp;对象</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn&nbsp;=&nbsp;DriverManager.getConnection(URL,&nbsp;USER,&nbsp;PASSWORD);&nbsp;&nbsp;</span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//3、要执行的&nbsp;sql&nbsp;语句：name,password,email,satic&nbsp;通过占位符填数,create_date&nbsp;自动为当前时间</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;sql&nbsp;=&nbsp;<span class=\"string\">\"&nbsp;SELECT&nbsp;*&nbsp;FROM&nbsp;users\"</span><span>;&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//4、创建执行&nbsp;SQL&nbsp;语句的&nbsp;PreparedStatement&nbsp;对象</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreparedStatement&nbsp;ptmt&nbsp;=&nbsp;conn.prepareStatement(sql);&nbsp;&nbsp;</span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//5、真正执行&nbsp;sql&nbsp;语句，并返回影响的&nbsp;ResultSet</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResultSet&nbsp;rs&nbsp;=&nbsp;ptmt.executeQuery();&nbsp;&nbsp;</span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//6、打印&nbsp;ResultSet&nbsp;数据集</span><span>&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">while</span><span>(rs.next())&nbsp;{&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(rs.getInt(<span class=\"string\">\"id\"</span><span>)+</span><span class=\"string\">\"&nbsp;\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(rs.getString(<span class=\"string\">\"name\"</span><span>)+</span><span class=\"string\">\"&nbsp;\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(rs.getString(<span class=\"string\">\"password\"</span><span>)+</span><span class=\"string\">\"&nbsp;\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(rs.getDate(<span class=\"string\">\"birthday\"</span><span>)+</span><span class=\"string\">\"&nbsp;\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(rs.getString(<span class=\"string\">\"email\"</span><span>)+</span><span class=\"string\">\"&nbsp;\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(rs.getDate(<span class=\"string\">\"create_date\"</span><span>)+</span><span class=\"string\">\"&nbsp;\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print(rs.getInt(<span class=\"string\">\"status\"</span><span>)+</span><span class=\"string\">\"&nbsp;\"</span><span>);&nbsp;&nbsp;</span></span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println();&nbsp;&nbsp;</span></li><li class=\"alt\"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=\"\"><span>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</span></li><li class=\"alt\"><span>}&nbsp;&nbsp;</span></li></ol></div></div><p>③ 运行结果</p><p></p><p>控制台上可以看到如下界面</p><p><img src=\"/uploads/2017/10/20171007154222212.jpg\" alt=\"20171007154222212.jpg\"><br></p>', null, '1', '8', '20', '8', '0', '0', '2017-10-07 15:42:43', '2018-01-24 23:31:16', '1', '1', '1');
INSERT INTO `article` VALUES ('6', '1', 'Hibernate 简单的CURD操作', '<h2>一、单表操作 CURD 实例</h2><ul><li>save</li><li>update</li><li>delete</li><li>get/load (查询单个记录)</li></ul><p>&nbsp;</p><h2>二、代码实现</h2><p><strong>StudentTest.java</strong></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"annotation\">@Test</span></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;testSaveStudnets()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//生成学生对象</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;Student&nbsp;s&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Student();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;s.setName(<span class=\"string\">\"陶渊明\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;s.setSex(<span class=\"number\">1</span>);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;s.setBirthday(<span class=\"keyword\">new</span>&nbsp;Date());</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;Address&nbsp;address&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Address(<span class=\"string\">\"332000\"</span>,<span class=\"string\">\"13512345678\"</span>,<span class=\"string\">\"江西九江\"</span>);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;s.setAddress(address);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;session.save(s);<span class=\"comment\">//保存对象进入数据库</span></li><li class=\"alt\">}</li><li class=\"\"></li><li class=\"alt\"><span class=\"annotation\">@Test</span></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;testGetStudents()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;Student&nbsp;s&nbsp;=&nbsp;(Student)&nbsp;session.get(Student.<span class=\"keyword\">class</span>,&nbsp;<span class=\"number\">1</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s);</li><li class=\"alt\">}</li><li class=\"\"></li><li class=\"alt\"><span class=\"annotation\">@Test</span></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;testLoadStudents()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;Student&nbsp;s&nbsp;=&nbsp;(Student)&nbsp;session.load(Student.<span class=\"keyword\">class</span>,&nbsp;<span class=\"number\">1</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s);</li><li class=\"alt\">}</li><li class=\"\"></li><li class=\"alt\"><span class=\"annotation\">@Test</span></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;testUpdateStudents()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;Student&nbsp;s&nbsp;=&nbsp;(Student)&nbsp;session.get(Student.<span class=\"keyword\">class</span>,&nbsp;<span class=\"number\">1</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;s.setName(<span class=\"string\">\"五柳先生\"</span>);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;session.update(s);</li><li class=\"\">}</li><li class=\"alt\"></li><li class=\"\"><span class=\"annotation\">@Test</span></li><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;testDeleteStudents()&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;Student&nbsp;s&nbsp;=&nbsp;(Student)&nbsp;session.get(Student.<span class=\"keyword\">class</span>,&nbsp;<span class=\"number\">1</span>);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;session.delete(s);</li><li class=\"\">}</li></ol></div><p>&nbsp;</p><h2>三、get 和 load 的区别</h2><p><strong>区别一、</strong></p><ul><li>不考虑缓存的情况下，get 方法会在调用之后，立即向数据库发送 sql 语句，返回持久化对象。</li><li>load 方法会在调用后返回一个持久化对象。该代理对象只保留了实体对象的 id，直到使用实体对象的非主键属性时才发出 sql 语句。</li></ul><p><strong>区别二、</strong></p><ul><li>查询数据库中不存在的数据时，get 方法返回 null 。</li><li>load 方法返回异常 org.hibernate.ObjectNotFoundException</li></ul><p>p</p><div><br></div>', null, '1', '9', '21', '12', '0', '0', '2017-10-07 15:49:54', '2017-10-07 15:49:54', '1', '1', '1');
INSERT INTO `article` VALUES ('7', '1', 'Hibernate 基本类型', '<p>这里介绍几个特殊的&nbsp;<a href=\"https://liuyanzhao.com/tag/hibernate/\" title=\"查看与 Hibernate 相关的文章\" target=\"_blank\">Hibernate</a>&nbsp;类型和属性</p><h2>一、日期类型</h2><p>我们的 Student 类有一个成员变量 birthday</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">private</span>&nbsp;Date&nbsp;birthday;<span class=\"comment\">//出生日期</span></li></ol></div><p>在我们的 Studnet.hbm.xml 对应的是自动生成的 属性</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-xml\" start=\"1\"><li class=\"alt\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">property</span>&nbsp;<span class=\"attribute\">name</span>=<span class=\"attribute-value\">\"birthday\"</span>&nbsp;<span class=\"attribute\">type</span>=<span class=\"attribute-value\">\"java.util.Date\"</span><span class=\"tag\">&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">column</span>&nbsp;<span class=\"attribute\">name</span>=<span class=\"attribute-value\">\"BIRTHDAY\"</span>&nbsp;<span class=\"tag\">/&gt;</span></li><li class=\"alt\"><span class=\"tag\">&lt;/</span><span class=\"tag-name\">property</span><span class=\"tag\">&gt;</span></li></ol></div><p>type 表示该字段的类型，不同的类型，会让数据表的字段类型也不同</p><table class=\"layui-table\"><tbody><tr><td>type（映射类型）</td><td>描述</td></tr><tr><td>java.util.Date</td><td>年月日时分秒（2017-07-25 18:20:12）</td></tr><tr><td>date</td><td>年月日（2017-07-25）</td></tr><tr><td>time</td><td>时分秒（18:20:12）</td></tr><tr><td>timestamp</td><td>年月日时分秒（2017-07-25 18:20:12）</td></tr></tbody></table><h2>二、对象类型</h2><p>我们这里使用使用 Blob 类型存照片</p><p>1、Student 类中 成员变量如下</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;sid;<span class=\"comment\">//学号</span></li><li class=\"\"><span class=\"keyword\">private</span>&nbsp;String&nbsp;name;<span class=\"comment\">//姓名</span></li><li class=\"alt\"><span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;sex;<span class=\"comment\">//性别</span></li><li class=\"\"><span class=\"keyword\">private</span>&nbsp;Date&nbsp;birthday;<span class=\"comment\">//出生日期</span></li><li class=\"alt\"><span class=\"keyword\">private</span>&nbsp;String&nbsp;address;<span class=\"comment\">//地址</span></li><li class=\"\"><span class=\"keyword\">private</span>&nbsp;Blob&nbsp;picture;<span class=\"comment\">//照片&nbsp;&nbsp;&nbsp;</span></li></ol></div><p>2、然后删除原来的 Student.hbm.xml &nbsp;文件，重新生成</p><p>3、在测试类添加&nbsp;testWriteBlob方法</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"annotation\">@Test</span></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;testWriteBlob()&nbsp;<span class=\"keyword\">throws</span>&nbsp;Exception&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;Student&nbsp;s&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Student(<span class=\"number\">1</span>,<span class=\"string\">\"杜甫\"</span>,<span class=\"number\">1</span>,<span class=\"keyword\">new</span>&nbsp;Date(),<span class=\"string\">\"四川\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//先获得照片文件</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;f&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;File(<span class=\"string\">\"d:\"</span>+File.separator+<span class=\"string\">\"boy.jpg\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//获得照片文件的输入流</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;InputStream&nbsp;input&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;FileInputStream(f);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//创建Blob对象</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;Blob&nbsp;image&nbsp;=&nbsp;<a href=\"https://liuyanzhao.com/tag/hibernate/\" title=\"查看与 Hibernate 相关的文章\" target=\"_blank\">Hibernate</a>.getLobCreator(session).createBlob(input,input.available());</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//设置照片属性</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;s.setPicture(image);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;session.save(s);</li><li class=\"alt\">}</li></ol></div><p>注意：这里 Blob 是&nbsp;java.sql.Blob 包下</p><p>4、然后使用 Junit Test 运行&nbsp;testWriteBlob 方法</p><p><img src=\"/uploads/2017/10/2017100715505630.png\" alt=\"2017100715505630.png\"><br></p><p>5、为了证明是否真的是写入数据库中，我们重新把照片读出来</p><p>在测试类中添加 testReadBlob 方法</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"annotation\">@Test</span></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;testReadBlob()&nbsp;<span class=\"keyword\">throws</span>&nbsp;Exception&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;Student&nbsp;s&nbsp;=&nbsp;(Student)session.get(Student.<span class=\"keyword\">class</span>,&nbsp;<span class=\"number\">1</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//获得Blob对象</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;Blob&nbsp;image&nbsp;=&nbsp;s.getPicture();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//获得照片的输入流</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;InputStream&nbsp;input&nbsp;=&nbsp;image.getBinaryStream();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//创建输出流</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;f&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;File(<span class=\"string\">\"d:\"</span>+File.separator+<span class=\"string\">\"dest.jpg\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//获得输出流</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;OutputStream&nbsp;output&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;FileOutputStream(f);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//创建缓冲区</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">byte</span>[]&nbsp;buff&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;<span class=\"keyword\">byte</span>[input.available()];</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;input.read(buff);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;output.write(buff);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;input.close();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;output.close();</li><li class=\"\">}</li></ol></div><p>6、使用 Junit Test 运行 testReadBlob 方法</p><p>我们可以看到 D 盘，已经生成了一张新照片，dest.jpg</p><p>&nbsp;</p><p><img src=\"/uploads/2017/10/20171007155038568.png\" alt=\"20171007155038568.png\"><br></p><h2>三、组件属性</h2><p>实体类中某个属性属于用户自定义的类的对象，下面我们通过一个例子来解释</p><p>1、实体类 Student.java 成员变量如下</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;sid;<span class=\"comment\">//学号</span></li><li class=\"\"><span class=\"keyword\">private</span>&nbsp;String&nbsp;name;<span class=\"comment\">//姓名</span></li><li class=\"alt\"><span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;sex;<span class=\"comment\">//性别</span></li><li class=\"\"><span class=\"keyword\">private</span>&nbsp;Date&nbsp;birthday;<span class=\"comment\">//出生日期</span></li><li class=\"alt\"><span class=\"comment\">//private&nbsp;String&nbsp;address;//地址</span></li><li class=\"\"><span class=\"keyword\">private</span>&nbsp;Blob&nbsp;picture;<span class=\"comment\">//照片&nbsp;&nbsp;&nbsp;</span></li><li class=\"alt\"><span class=\"keyword\">private</span>&nbsp;Address&nbsp;address;&nbsp;<span class=\"comment\">//地址</span></li></ol></div><p>我们这里把之前的 String 类型的 address 改成 Address 类型</p><p>2、Address 类 部分代码如下</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">private</span>&nbsp;String&nbsp;postcode;<span class=\"comment\">//邮编</span></li><li class=\"\"><span class=\"keyword\">private</span>&nbsp;String&nbsp;phone;<span class=\"comment\">//手机</span></li><li class=\"alt\"><span class=\"keyword\">private</span>&nbsp;String&nbsp;address;<span class=\"comment\">//地址</span></li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;Address(String&nbsp;postcode,&nbsp;String&nbsp;phone,&nbsp;String&nbsp;address)&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.postcode&nbsp;=&nbsp;postcode;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.phone&nbsp;=&nbsp;phone;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.address&nbsp;=&nbsp;address;</li><li class=\"alt\">}</li></ol></div><p>3、修改 Student.hbm.xml</p><p>将之前的</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-xml\" start=\"1\"><li class=\"alt\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">property</span>&nbsp;<span class=\"attribute\">name</span>=<span class=\"attribute-value\">\"address\"</span>&nbsp;<span class=\"attribute\">type</span>=<span class=\"attribute-value\">\"java.lang.String\"</span><span class=\"tag\">&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">column</span>&nbsp;<span class=\"attribute\">name</span>=<span class=\"attribute-value\">\"ADDRESS\"</span>&nbsp;<span class=\"tag\">/&gt;</span></li><li class=\"alt\"><span class=\"tag\">&lt;/</span><span class=\"tag-name\">property</span><span class=\"tag\">&gt;</span></li></ol></div><p>改成</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-xml\" start=\"1\"><li class=\"alt\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">component</span>&nbsp;<span class=\"attribute\">name</span>=<span class=\"attribute-value\">\"address\"</span>&nbsp;<span class=\"attribute\">class</span>=<span class=\"attribute-value\">\"Address\"</span><span class=\"tag\">&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">property</span>&nbsp;<span class=\"attribute\">name</span>=<span class=\"attribute-value\">\"postcode\"</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"POSTCODE\"</span><span class=\"tag\">/&gt;</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">property</span>&nbsp;<span class=\"attribute\">name</span>=<span class=\"attribute-value\">\"phone\"</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"PHONE\"</span><span class=\"tag\">/&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">property</span>&nbsp;<span class=\"attribute\">name</span>=<span class=\"attribute-value\">\"address\"</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"ADDRESS\"</span><span class=\"tag\">/&gt;</span></li><li class=\"alt\"><span class=\"tag\">&lt;/</span><span class=\"tag-name\">component</span><span class=\"tag\">&gt;</span></li></ol></div><p>注意：单词不要打错</p><p>4、修改 测试类 testSaveStudent 代码</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"annotation\">@Test</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;testSaveStudnets()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//生成学生对象</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;Student&nbsp;s&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Student();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;s.setName(<span class=\"string\">\"陶渊明\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;s.setSex(<span class=\"number\">1</span>);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;s.setBirthday(<span class=\"keyword\">new</span>&nbsp;Date());</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//s.setAddress(\"江西九江\");</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;Address&nbsp;address&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Address(<span class=\"string\">\"332000\"</span>,<span class=\"string\">\"13512345678\"</span>,<span class=\"string\">\"江西九江\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;s.setAddress(address);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;session.save(s);<span class=\"comment\">//保存对象进入数据库</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;}</li></ol></div><p>5、修改 hibernate.cfg.xml 里的创建表的策略</p><p>因为要修改表结构，暂且把 update 改成 create</p><p>6、用 Junit Test 运行 testSaveStudent 方法</p><p>运行成功，查看数据表</p><p><img src=\"/uploads/2017/10/2017100715512437.jpg\" alt=\"2017100715512437.jpg\"><br></p><p>查看 表结构</p><p><img src=\"/uploads/2017/10/20171007155135604.jpg\" alt=\"20171007155135604.jpg\"><br></p><p>&nbsp;</p>', null, '1', '9', '21', '18', '0', '0', '2017-10-07 15:51:57', '2017-10-07 15:51:57', '1', '1', '1');
INSERT INTO `article` VALUES ('8', '1', 'Mybatis高级映射多对多查询', '<p>紧接着上一篇文章：<a href=\"https://liuyanzhao.com/5847.html\" target=\"_blank\" rel=\"noopener noreferrer\">Mybatis高级映射一对多查询</a>&nbsp;写</p><h2>一、开发准备</h2><p><strong>1、新建数据表（四张表）和添加测试数据</strong></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-sql\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">DROP</span>&nbsp;<span class=\"keyword\">TABLE</span>&nbsp;IF&nbsp;EXISTS&nbsp;`items`;</li><li class=\"\"><span class=\"keyword\">DROP</span>&nbsp;<span class=\"keyword\">TABLE</span>&nbsp;IF&nbsp;EXISTS&nbsp;`orders`;</li><li class=\"alt\"><span class=\"keyword\">DROP</span>&nbsp;<span class=\"keyword\">TABLE</span>&nbsp;IF&nbsp;EXISTS&nbsp;`<span class=\"func\">user</span>`;</li><li class=\"\"><span class=\"keyword\">DROP</span>&nbsp;<span class=\"keyword\">TABLE</span>&nbsp;IF&nbsp;EXISTS&nbsp;`orderdetail`;</li><li class=\"alt\"></li><li class=\"\">/*items是商品表*/</li><li class=\"alt\"><span class=\"keyword\">CREATE</span>&nbsp;<span class=\"keyword\">TABLE</span>&nbsp;`items`&nbsp;(</li><li class=\"\">&nbsp;&nbsp;`id`&nbsp;<span class=\"keyword\">INT</span>(11)&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;AUTO_INCREMENT,</li><li class=\"alt\">&nbsp;&nbsp;`<span class=\"keyword\">name</span>`&nbsp;<span class=\"keyword\">VARCHAR</span>(32)&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'商品名称\',</li><li class=\"\">&nbsp;&nbsp;`price`&nbsp;<span class=\"keyword\">FLOAT</span>(10,1)&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'商品定价\',</li><li class=\"alt\">&nbsp;&nbsp;`detail`&nbsp;TEXT&nbsp;COMMENT&nbsp;\'商品描述\',</li><li class=\"\">&nbsp;&nbsp;`pic`&nbsp;<span class=\"keyword\">VARCHAR</span>(64)&nbsp;<span class=\"keyword\">DEFAULT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'商品图片\',</li><li class=\"alt\">&nbsp;&nbsp;`createtime`&nbsp;DATETIME&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'生产日期\',</li><li class=\"\">&nbsp;&nbsp;<span class=\"keyword\">PRIMARY</span>&nbsp;<span class=\"keyword\">KEY</span>&nbsp;(`id`)</li><li class=\"alt\">)&nbsp;ENGINE=INNODB&nbsp;AUTO_INCREMENT=4&nbsp;<span class=\"keyword\">DEFAULT</span>&nbsp;CHARSET=utf8;</li><li class=\"\"></li><li class=\"alt\">/*<span class=\"func\">user</span>是用户表*/</li><li class=\"\"><span class=\"keyword\">CREATE</span>&nbsp;<span class=\"keyword\">TABLE</span>&nbsp;`<span class=\"func\">user</span>`&nbsp;(</li><li class=\"alt\">&nbsp;&nbsp;`id`&nbsp;<span class=\"keyword\">INT</span>(11)&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;AUTO_INCREMENT,</li><li class=\"\">&nbsp;&nbsp;`username`&nbsp;<span class=\"keyword\">VARCHAR</span>(32)&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'用户名称\',</li><li class=\"alt\">&nbsp;&nbsp;`birthday`&nbsp;<span class=\"keyword\">DATE</span>&nbsp;<span class=\"keyword\">DEFAULT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'生日\',</li><li class=\"\">&nbsp;&nbsp;`gender`&nbsp;<span class=\"keyword\">CHAR</span>(1)&nbsp;<span class=\"keyword\">DEFAULT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'性别\',</li><li class=\"alt\">&nbsp;&nbsp;`address`&nbsp;<span class=\"keyword\">VARCHAR</span>(256)&nbsp;<span class=\"keyword\">DEFAULT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'地址\',</li><li class=\"\">&nbsp;&nbsp;<span class=\"keyword\">PRIMARY</span>&nbsp;<span class=\"keyword\">KEY</span>&nbsp;(`id`)</li><li class=\"alt\">)&nbsp;ENGINE=INNODB&nbsp;AUTO_INCREMENT=27&nbsp;<span class=\"keyword\">DEFAULT</span>&nbsp;CHARSET=utf8;</li><li class=\"\"></li><li class=\"alt\">/*orders是订单表*/</li><li class=\"\"><span class=\"keyword\">CREATE</span>&nbsp;<span class=\"keyword\">TABLE</span>&nbsp;`orders`&nbsp;(</li><li class=\"alt\">&nbsp;&nbsp;`id`&nbsp;<span class=\"keyword\">INT</span>(11)&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;AUTO_INCREMENT,</li><li class=\"\">&nbsp;&nbsp;`user_id`&nbsp;<span class=\"keyword\">INT</span>(11)&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'下单用户id\',</li><li class=\"alt\">&nbsp;&nbsp;`number`&nbsp;<span class=\"keyword\">VARCHAR</span>(32)&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'订单号\',</li><li class=\"\">&nbsp;&nbsp;`createtime`&nbsp;DATETIME&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'创建订单时间\',</li><li class=\"alt\">&nbsp;&nbsp;`note`&nbsp;<span class=\"keyword\">VARCHAR</span>(100)&nbsp;<span class=\"keyword\">DEFAULT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'备注\',</li><li class=\"\">&nbsp;&nbsp;<span class=\"keyword\">PRIMARY</span>&nbsp;<span class=\"keyword\">KEY</span>&nbsp;(`id`),</li><li class=\"alt\">&nbsp;&nbsp;<span class=\"keyword\">KEY</span>&nbsp;`FK_orders_1`&nbsp;(`user_id`),</li><li class=\"\">&nbsp;&nbsp;<span class=\"keyword\">CONSTRAINT</span>&nbsp;`FK_orders_id`&nbsp;<span class=\"keyword\">FOREIGN</span>&nbsp;<span class=\"keyword\">KEY</span>&nbsp;(`user_id`)&nbsp;<span class=\"keyword\">REFERENCES</span>&nbsp;`<span class=\"func\">user</span>`&nbsp;(`id`)&nbsp;<span class=\"keyword\">ON</span>&nbsp;<span class=\"keyword\">DELETE</span>&nbsp;<span class=\"keyword\">NO</span>&nbsp;<span class=\"keyword\">ACTION</span>&nbsp;<span class=\"keyword\">ON</span>&nbsp;<span class=\"keyword\">UPDATE</span>&nbsp;<span class=\"keyword\">NO</span>&nbsp;<span class=\"keyword\">ACTION</span></li><li class=\"alt\">)&nbsp;ENGINE=INNODB&nbsp;AUTO_INCREMENT=6&nbsp;<span class=\"keyword\">DEFAULT</span>&nbsp;CHARSET=utf8;</li><li class=\"\"></li><li class=\"alt\">/*orderdetail是订单明细表*/</li><li class=\"\"><span class=\"keyword\">DROP</span>&nbsp;<span class=\"keyword\">TABLE</span>&nbsp;IF&nbsp;EXISTS&nbsp;orderdetail;</li><li class=\"alt\"><span class=\"keyword\">CREATE</span>&nbsp;<span class=\"keyword\">TABLE</span>&nbsp;`orderdetail`&nbsp;(</li><li class=\"\">&nbsp;&nbsp;`id`&nbsp;<span class=\"keyword\">INT</span>(11)&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;AUTO_INCREMENT,</li><li class=\"alt\">&nbsp;&nbsp;`orders_id`&nbsp;<span class=\"keyword\">INT</span>(11)&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'订单id\',</li><li class=\"\">&nbsp;&nbsp;`items_id`&nbsp;<span class=\"keyword\">INT</span>(11)&nbsp;<span class=\"op\">NOT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'商品id\',</li><li class=\"alt\">&nbsp;&nbsp;`items_num`&nbsp;<span class=\"keyword\">INT</span>(11)&nbsp;<span class=\"keyword\">DEFAULT</span>&nbsp;<span class=\"op\">NULL</span>&nbsp;COMMENT&nbsp;\'商品购买数量\',</li><li class=\"\">&nbsp;&nbsp;<span class=\"keyword\">PRIMARY</span>&nbsp;<span class=\"keyword\">KEY</span>&nbsp;(`id`),</li><li class=\"alt\">&nbsp;&nbsp;<span class=\"keyword\">KEY</span>&nbsp;`FK_orderdetail_1`&nbsp;(`orders_id`),</li><li class=\"\">&nbsp;&nbsp;<span class=\"keyword\">KEY</span>&nbsp;`FK_orderdetail_2`&nbsp;(`items_id`),</li><li class=\"alt\">&nbsp;&nbsp;<span class=\"keyword\">CONSTRAINT</span>&nbsp;`FK_orderdetail_1`&nbsp;<span class=\"keyword\">FOREIGN</span>&nbsp;<span class=\"keyword\">KEY</span>&nbsp;(`orders_id`)&nbsp;<span class=\"keyword\">REFERENCES</span>&nbsp;`orders`&nbsp;(`id`)&nbsp;<span class=\"keyword\">ON</span>&nbsp;<span class=\"keyword\">DELETE</span>&nbsp;<span class=\"keyword\">NO</span>&nbsp;<span class=\"keyword\">ACTION</span>&nbsp;<span class=\"keyword\">ON</span>&nbsp;<span class=\"keyword\">UPDATE</span>&nbsp;<span class=\"keyword\">NO</span>&nbsp;<span class=\"keyword\">ACTION</span>,</li><li class=\"\">&nbsp;&nbsp;<span class=\"keyword\">CONSTRAINT</span>&nbsp;`FK_orderdetail_2`&nbsp;<span class=\"keyword\">FOREIGN</span>&nbsp;<span class=\"keyword\">KEY</span>&nbsp;(`items_id`)&nbsp;<span class=\"keyword\">REFERENCES</span>&nbsp;`items`&nbsp;(`id`)&nbsp;<span class=\"keyword\">ON</span>&nbsp;<span class=\"keyword\">DELETE</span>&nbsp;<span class=\"keyword\">NO</span>&nbsp;<span class=\"keyword\">ACTION</span>&nbsp;<span class=\"keyword\">ON</span>&nbsp;<span class=\"keyword\">UPDATE</span>&nbsp;<span class=\"keyword\">NO</span>&nbsp;<span class=\"keyword\">ACTION</span></li><li class=\"alt\">)&nbsp;ENGINE=INNODB&nbsp;AUTO_INCREMENT=5&nbsp;<span class=\"keyword\">DEFAULT</span>&nbsp;CHARSET=utf8;</li></ol></div><p>为了测试，我这里随便填了些数据</p><p><img src=\"/uploads/2017/10/20171007155334244.png\" alt=\"20171007155334244.png\"><br></p><p><img src=\"/uploads/2017/10/20171007155349805.png\" alt=\"20171007155349805.png\"><br></p><p><br></p><p><img src=\"/uploads/2017/10/20171007155410485.png\" alt=\"20171007155410485.png\"><br></p><p><br></p><p><strong><img src=\"/uploads/2017/10/20171007155450773.png\" alt=\"20171007155450773.png\"></strong></p><p><strong>2、思路分析</strong></p><p><img src=\"/uploads/2017/10/20171007155545742.png\" alt=\"20171007155545742.png\"><br></p><p>订单项和订单明细是一对多的关系，所以本文主要来查询订单表，然后关联订单明细表，这样就有一对多的问题出来了。</p><p><span>因为多对多比较复杂，总公共有四张表，我们先来分析一下思路：</span></p><blockquote><p><span>1、将用户信息映射到User中；</span></p><p><span>2、在User类中添加订单列表属性<code>List<orders>ordersList</orders></code>，将用户创建的订单映射到ordersList中；</span></p><p><span>3、在Orders中添加订单明细列表属性<code>List<orderdetail>orderDetails</orderdetail></code>，将订单的明细映射到orderDetails中；</span></p><p><span>4、在OrderDetail中添加Items属性，将订单明细所对应的商品映射到Items中。</span></p></blockquote><p>经过这样分析后，感觉虽然有点复杂，但是好像不是很难的样子，映射的方法也跟前面的一样，只不过这里表有点多，关系有点复杂。下面来写映射文件：</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-sql\" start=\"1\"><li class=\"alt\">&lt;<span class=\"keyword\">select</span>&nbsp;id=<span class=\"string\">\"findUserAndItemsResultMap\"</span>&nbsp;resultMap=<span class=\"string\">\"UserAndItemsResultMap\"</span>&gt;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">SELECT</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orders.*,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"func\">user</span>.`username`,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"func\">user</span>.`sex`,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"func\">user</span>.`address`,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderdetail.`id`&nbsp;orderdetail_id,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderdetail.`items_id`,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderdetail.`items_num`,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderdetail.`orders_id`,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.`<span class=\"keyword\">name</span>`&nbsp;items_name,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.`detail`&nbsp;items_detail,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.`price`&nbsp;items_price</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">FROM</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orders,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"func\">USER</span>,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderdetail,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">WHERE</span>&nbsp;orders.`user_id`=<span class=\"func\">user</span>.`id`&nbsp;<span class=\"op\">AND</span>&nbsp;orders.`id`&nbsp;=&nbsp;orderdetail.`orders_id`&nbsp;<span class=\"op\">AND</span>&nbsp;orderdetail.`items_id`=items.`id`</li><li class=\"\"><!--<span class=\"keyword\"-->select&gt;</li></ol></div><p>我们先看一下查询结果：</p><p><img src=\"/uploads/2017/10/2017100717420134.png\" alt=\"2017100717420134.png\"><br></p><p><br></p><h2>二、代码实现</h2><p><strong>1、四个持久化类</strong></p><p>① User.java</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">package</span>&nbsp;com.test.mybatis.po;</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.util.Date;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;java.util.List;</li><li class=\"alt\"></li><li class=\"\"><span class=\"comment\">/**</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*&nbsp;用户的持久类</span></li><li class=\"\"><span class=\"comment\">&nbsp;*/</span></li><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;User&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;id;&nbsp;<span class=\"comment\">//编号</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;String&nbsp;username;&nbsp;<span class=\"comment\">//用户名</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;String&nbsp;gender;&nbsp;<span class=\"comment\">//性别</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;Date&nbsp;birthday;&nbsp;<span class=\"comment\">//生日</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;String&nbsp;address;&nbsp;<span class=\"comment\">//地址</span></li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;List<orders>&nbsp;getOrdersList()&nbsp;{</orders></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;ordersList;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setOrdersList(List<orders>&nbsp;ordersList)&nbsp;{</orders></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.ordersList&nbsp;=&nbsp;ordersList;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//用户创建的订单列表</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;List<orders>&nbsp;ordersList;</orders></li><li class=\"\"></li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;getId()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;id;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setId(<span class=\"keyword\">int</span>&nbsp;id)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.id&nbsp;=&nbsp;id;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;String&nbsp;getUsername()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;username;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setUsername(String&nbsp;username)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.username&nbsp;=&nbsp;username;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;String&nbsp;getGender()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;gender;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setGender(String&nbsp;gender)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.gender&nbsp;=&nbsp;gender;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;Date&nbsp;getBirthday()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;birthday;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setBirthday(Date&nbsp;birthday)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.birthday&nbsp;=&nbsp;birthday;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;String&nbsp;getAddress()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;address;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setAddress(String&nbsp;address)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.address&nbsp;=&nbsp;address;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">}</li></ol></div><p>注意：需要在用户表中加入 订单列表</p><p>&nbsp;</p><p>② Items.java</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">package</span>&nbsp;com.test.mybatis.po;</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.util.Date;</li><li class=\"\"></li><li class=\"alt\"><span class=\"comment\">/**</span></li><li class=\"\"><span class=\"comment\">&nbsp;*&nbsp;商品的持久类</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*/</span></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;Items&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;id;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;String&nbsp;name;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">double</span>&nbsp;price;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;String&nbsp;detail;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;String&nbsp;pic;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;Date&nbsp;createTime;</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;getId()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;id;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setId(<span class=\"keyword\">int</span>&nbsp;id)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.id&nbsp;=&nbsp;id;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;String&nbsp;getName()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;name;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setName(String&nbsp;name)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.name&nbsp;=&nbsp;name;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">double</span>&nbsp;getPrice()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;price;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setPrice(<span class=\"keyword\">double</span>&nbsp;price)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.price&nbsp;=&nbsp;price;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;String&nbsp;getDetail()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;detail;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setDetail(String&nbsp;detail)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.detail&nbsp;=&nbsp;detail;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;String&nbsp;getPic()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;pic;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setPic(String&nbsp;pic)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.pic&nbsp;=&nbsp;pic;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;Date&nbsp;getCreateTime()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;createTime;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setCreateTime(Date&nbsp;createTime)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.createTime&nbsp;=&nbsp;createTime;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">}</li></ol></div><p>&nbsp;</p><p>③ Orders.java</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">package</span>&nbsp;com.test.mybatis.po;</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.util.Date;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;java.util.List;</li><li class=\"alt\"></li><li class=\"\"><span class=\"comment\">/**</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*&nbsp;订单的持久类和扩展类</span></li><li class=\"\"><span class=\"comment\">&nbsp;*/</span></li><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;Orders&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;id;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;userId;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;String&nbsp;number;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;Date&nbsp;createTime;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;String&nbsp;note;</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//订单明细</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;List<orderdetail>&nbsp;orderdetails;</orderdetail></li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;List<orderdetail>&nbsp;getOrderdetails()&nbsp;{</orderdetail></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;orderdetails;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setOrderdetails(List<orderdetail>&nbsp;orderdetails)&nbsp;{</orderdetail></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.orderdetails&nbsp;=&nbsp;orderdetails;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;getId()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;id;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setId(<span class=\"keyword\">int</span>&nbsp;id)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.id&nbsp;=&nbsp;id;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;getUserId()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;userId;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setUserId(<span class=\"keyword\">int</span>&nbsp;userId)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.userId&nbsp;=&nbsp;userId;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;String&nbsp;getNumber()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;number;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setNumber(String&nbsp;number)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.number&nbsp;=&nbsp;number;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;Date&nbsp;getCreateTime()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;createTime;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setCreateTime(Date&nbsp;createTime)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.createTime&nbsp;=&nbsp;createTime;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;String&nbsp;getNote()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;note;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setNote(String&nbsp;note)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.note&nbsp;=&nbsp;note;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">}</li></ol></div><p>注意：订单列表中，需要订单的详细信息，不需要用户信息</p><p>&nbsp;</p><p>④ Orderdetail.java</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">package</span>&nbsp;com.test.mybatis.po;</li><li class=\"\"></li><li class=\"alt\"><span class=\"comment\">/**</span></li><li class=\"\"><span class=\"comment\">&nbsp;*&nbsp;订单明细的持久类</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*/</span></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;Orderdetail&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;id;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;ordersId;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;itemsId;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;itemsNum;</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//明细对应的商品信息</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;Items&nbsp;items;</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;Items&nbsp;getItems()&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;items;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setItems(Items&nbsp;items)&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.items&nbsp;=&nbsp;items;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;getId()&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;id;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setId(<span class=\"keyword\">int</span>&nbsp;id)&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.id&nbsp;=&nbsp;id;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;getOrdersId()&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;ordersId;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setOrdersId(<span class=\"keyword\">int</span>&nbsp;ordersId)&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.ordersId&nbsp;=&nbsp;ordersId;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;getItemsId()&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;itemsId;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setItemsId(<span class=\"keyword\">int</span>&nbsp;itemsId)&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.itemsId&nbsp;=&nbsp;itemsId;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">int</span>&nbsp;getItemsNum()&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;itemsNum;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setItemsNum(<span class=\"keyword\">int</span>&nbsp;itemsNum)&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">this</span>.itemsNum&nbsp;=&nbsp;itemsNum;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">}</li></ol></div><p>注意：订单明细里，需要 商品信息</p><p>&nbsp;</p><p><strong>2、订单代理 即mapper.java</strong></p><p>OrdersMapperCustom.java</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">package</span>&nbsp;com.liuyanzhao.mybatis.mapper;</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;com.liuyanzhao.mybatis.po.User;</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.util.List;</li><li class=\"\"></li><li class=\"alt\"><span class=\"comment\">/**</span></li><li class=\"\"><span class=\"comment\">&nbsp;*&nbsp;订单&nbsp;mapper</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*/</span></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">interface</span>&nbsp;OrdersMapperCustom&nbsp;{</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//查询用户购买的商品信息</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;List<user>&nbsp;findUserAndItemsResultMap()&nbsp;<span class=\"keyword\">throws</span>&nbsp;Exception;</user></li><li class=\"\">}</li></ol></div><p>&nbsp;</p><p><span><strong>3、OrdersMapperCustom.xml &nbsp; &nbsp;映射文件</strong></span></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-xml\" start=\"1\"><li class=\"alt\"><span class=\"tag\"><!--?</span--><span class=\"tag-name\">xml</span>&nbsp;<span class=\"attribute\">version</span>=<span class=\"attribute-value\">\"1.0\"</span>&nbsp;<span class=\"attribute\">encoding</span>=<span class=\"attribute-value\">\"UTF-8\"</span>&nbsp;<span class=\"tag\">?&gt;</span></span></li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PUBLIC&nbsp;\"-//mybatis.org//DTD&nbsp;Mapper&nbsp;3.0//EN\"</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"<span class=\"tag\">&gt;</span></li><li class=\"alt\"></li><li class=\"\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">mapper</span>&nbsp;<span class=\"attribute\">namespace</span>=<span class=\"attribute-value\">\"com.test.mybatis.mapper.OrdersMapperCustom\"</span><span class=\"tag\">&gt;</span></li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!--查询用户购买的商品--></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">resultMap</span>&nbsp;<span class=\"attribute\">id</span>=<span class=\"attribute-value\">\"UserAndItemsResultMap\"</span>&nbsp;<span class=\"attribute\">type</span>=<span class=\"attribute-value\">\"com.test.mybatis.po.User\"</span><span class=\"tag\">&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!--用户信息--></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">id</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"user_id\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"id\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">id</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"username\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"username\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"gender\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"gender\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"address\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"address\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\"></li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!--订单信息--></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!--一个用户可以对应多个订单，故使用collection映射--></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">collection</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"ordersList\"</span>&nbsp;<span class=\"attribute\">ofType</span>=<span class=\"attribute-value\">\"com.test.mybatis.po.Orders\"</span><span class=\"tag\">&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">id</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"id\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"id\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">id</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"user_id\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"userId\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"number\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"number\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"createtime\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"createTime\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"node\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"node\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!--订单明细--></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!--一个订单包括多个明细，故使用collection--></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">collection</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"orderdetails\"</span>&nbsp;<span class=\"attribute\">ofType</span>=<span class=\"attribute-value\">\"com.test.mybatis.po.Orderdetail\"</span><span class=\"tag\">&gt;</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">id</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"orderdetail_id\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"id\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">id</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"items_id\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"itemsId\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"items_num\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"itemsNum\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"orders_id\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"ordersId\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!--商品信息--></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!--一个订单明细对应一个商品--></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">association</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"items\"</span>&nbsp;<span class=\"attribute\">javaType</span>=<span class=\"attribute-value\">\"com.test.mybatis.po.Items\"</span><span class=\"tag\">&gt;</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">id</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"items_id\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"id\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">id</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"items_name\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"name\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"items_price\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"price\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">result</span>&nbsp;<span class=\"attribute\">column</span>=<span class=\"attribute-value\">\"items_detail\"</span>&nbsp;<span class=\"attribute\">property</span>=<span class=\"attribute-value\">\"detail\"</span><span class=\"tag\">&gt;</span><span class=\"tag\"><!--</span--><span class=\"tag-name\">result</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">association</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">collection</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">collection</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">resultMap</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">select</span>&nbsp;<span class=\"attribute\">id</span>=<span class=\"attribute-value\">\"findUserAndItemsResultMap\"</span>&nbsp;<span class=\"attribute\">resultMap</span>=<span class=\"attribute-value\">\"UserAndItemsResultMap\"</span><span class=\"tag\">&gt;</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orders.*,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user.username,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user.gender,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user.address,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderdetail.id&nbsp;orderdetail_id,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderdetail.items_id,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderdetail.items_num,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderdetail.orders_id,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.name&nbsp;items_name,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.detail&nbsp;items_detail,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.price&nbsp;items_price</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orders,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user,</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderdetail,</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;<span class=\"attribute\">orders.user_id</span>=user.id&nbsp;AND&nbsp;<span class=\"attribute\">orders.id</span>&nbsp;=&nbsp;<span class=\"attribute-value\">orderdetail</span>.orders_id&nbsp;AND&nbsp;<span class=\"attribute\">orderdetail.items_id</span>=items.id</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">select</span><span class=\"tag\">&gt;</span></span></li><li class=\"\"></li><li class=\"alt\"><span class=\"tag\"><!--</span--><span class=\"tag-name\">mapper</span><span class=\"tag\">&gt;</span></span></li></ol></div><p>&nbsp;</p><p><span>4、测试类 OrderMapperCustomTest.java</span></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">package</span>&nbsp;com.test.mybatis.test;</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;com.test.mybatis.mapper.OrdersMapperCustom;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;com.test.mybatis.po.User;</li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;org.apache.ibatis.io.Resources;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;org.apache.ibatis.session.SqlSession;</li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;org.apache.ibatis.session.SqlSessionFactory;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;org.apache.ibatis.session.SqlSessionFactoryBuilder;</li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;org.junit.Before;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;org.junit.Test;</li><li class=\"alt\"></li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;java.io.InputStream;</li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.util.List;</li><li class=\"\"></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;OrderMapperCustomTest&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;SqlSessionFactory&nbsp;sqlSessionFactory;</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"annotation\">@Before</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;setUp()&nbsp;<span class=\"keyword\">throws</span>&nbsp;Exception&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;resource&nbsp;=&nbsp;<span class=\"string\">\"Configuration.xml\"</span>;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InputStream&nbsp;inputStream&nbsp;=&nbsp;Resources.getResourceAsStream(resource);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqlSessionFactory&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;SqlSessionFactoryBuilder()</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.build(inputStream);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"annotation\">@Test</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;testFindUserAndItemsResultMap()&nbsp;<span class=\"keyword\">throws</span>&nbsp;Exception&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlSession&nbsp;sqlSession&nbsp;=&nbsp;sqlSessionFactory.openSession();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//创建代理对象</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OrdersMapperCustom&nbsp;ordersMapperCustom&nbsp;=&nbsp;sqlSession.getMapper(OrdersMapperCustom.<span class=\"keyword\">class</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//调用mapper对象</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List<user>&nbsp;list&nbsp;=&nbsp;ordersMapperCustom.findUserAndItemsResultMap();</user></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(list);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//释放资源</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqlSession.close();</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">}</li></ol></div><p>还有其他文件就不补充了，如 mybatis 全局配置文件</p><p>&nbsp;</p><h2>小结</h2><p><span>这样多对多的映射就搞定了。不过还有个问题，就是这里多对多的查询会把所有关联的表的信息都查询出来，然后放到pojo中的对应的List或者某个类中，所以即使我只查了个用户信息，但是这个用户里包含了订单，订单项，商品等信息，感觉装的有点多，好像有时候并不需要这么多冗余的数据出来，但是如果用resultType的话查询出来的字段必须对应pojo中的属性，如果有List等，需要手动装入才行。所以下面总结一下对于这种查询数据比较多的时候，resultType和resultMap各有什么作用？</span></p><blockquote><ol><li>比如我们只需要将查询用户购买的商品信息明细清单（如用户名、用户地址、购买商品名称、购买商品时间、购买商品数量），那么我们完全不需要其他的信息，这个时候就没必要使用resultMap将所有的信息都搞出来，我们可以自己定义一个pojo，包含我们需要的字段即可，然后查询语句只查询我们需要的字段，这样使用resultType会方便很多。</li><li>如果我们需要查询该用户的所有详细信息，比如用户点击该用户或者鼠标放上去，会出来跟该用户相关的订单啊，订单明细啊，商品啊之类的，然后我们要点进去看下详细情况的时候，那就需要使用resultMap了，必须将所有信息都装到这个User中，然后具体啥信息再从User中取，很好理解。</li><li>总结一点：使用resultMap是针对那些对查询结果映射有特殊要求的功能，，比如特殊要求映射成list中包括多个list。否则使用resultType比较直接。</li></ol></blockquote><p><span>到这里，mybatis的多对多映射就总结完了。&nbsp;</span></p>', null, '1', '9', '13', '34', '2', '0', '2017-10-07 15:56:00', '2018-01-24 23:27:39', '1', '1', '1');
INSERT INTO `article` VALUES ('32', '1', 'ssm整合ehcache', '<p><b>1、引入依赖：</b></p><b>\r\n</b><p></p><b><div><pre class=\"brush:html\"> <!-- ehcache 相关依赖 -->\r\n        <dependency>\r\n            <groupid>org.ehcache</groupid>\r\n            <artifactid>ehcache</artifactid>\r\n            <version>3.1.3</version>\r\n        </dependency>\r\n        <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-ehcache -->\r\n        <dependency>\r\n            <groupid>org.mybatis</groupid>\r\n            <artifactid>mybatis-ehcache</artifactid>\r\n            <version>1.0.0</version>\r\n        </dependency>\r\n\r\n</pre></div></b><p><b>2、引入各种配置文件：</b></p><p><b>&nbsp; 2.1、ehcache.xml的配置文件：</b></p><p><b></b></p><div><pre class=\"brush:html\"><!--?xml version=\"1.0\" encoding=\"UTF-8\"?--><b>\r\n<ehcache>\r\n    <!-- java.io.tmpdir：Java临时目录。指定一个文件目录，当EhCache把数据写到硬盘上或者系统jvm内存时，将把数据写到这个文件目录下 -->\r\n    <diskstore path=\"java.io.tmpdir\">\r\n\r\n<!-- maxElementsInMemory：设置基于内存的缓存可存放对象的最大数目。  -->\r\n<!-- eternal：如果为true，表示对象永远不会过期，此时会忽略timeToIdleSeconds和timeToLiveSeconds属性，默认为false; -->\r\n<!-- timeToIdleSeconds： 设定允许对象处于空闲状态的最长时间，以秒为单位。当对象自从最近一次被访问后，如果处于空闲状态的时间超过了 -->\r\n<!-- timeToIdleSeconds属性值，这个对象就会过期。当对象过期，EHCache将把它从缓存中清空。只有当eternal属性为false，该属性才有效。 -->\r\n<!-- 如果该属性值为0，则表示对象可以无限期地处于空闲状态。  -->\r\n<!-- timeToLiveSeconds：设定对象允许存在于缓存中的最长时间，以秒为单位。当对象自从被存放到缓存中后，如果处于缓存中的时间超过了 timeToLiveSeconds属性值，这个对象就会过期。当对象过期，EHCache将把它从缓存中清除。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地存在于缓存中。timeToLiveSeconds必须大于timeToIdleSeconds属性，才有意义。  -->\r\n<!-- overflowToDisk：如果为true,表示当基于内存的缓存中的对象数目达到了maxElementsInMemory界限后，会把益出的对象写到基于硬盘的缓存中。 -->\r\n\r\n    <!-- 设定缓存的默认数据过期策略 -->\r\n    <defaultcache maxelementsinmemory=\"10000\" eternal=\"false\" overflowtodisk=\"true\" timetoidleseconds=\"10\" timetoliveseconds=\"20\" diskpersistent=\"false\" diskexpirythreadintervalseconds=\"120\">\r\n\r\n<!--  自定义缓存策略-学生信息缓存容器对应策略-->\r\n    <cache name=\"studentCache\" maxelementsinmemory=\"1000\" eternal=\"false\" overflowtodisk=\"true\" timetoidleseconds=\"10\" timetoliveseconds=\"20\">\r\n   <!--  自定义缓存策略-教师信息缓存容器对应策略-->  \r\n<!--      <cache name=\"techerCache\"          -->\r\n<!--         maxElementsInMemory=\"1000\"  -->\r\n<!--         eternal=\"false\"                 -->\r\n<!--         overflowToDisk=\"true\"       -->\r\n<!--         timeToIdleSeconds=\"10\"      -->\r\n<!--         timeToLiveSeconds=\"20\"/>        -->\r\n\r\n</cache></defaultcache></diskstore></ehcache>\r\n</b></pre></div><p></p><p><b>2.2、spring-ehcache.xml的配置文件：</b></p><p><b></b></p><div><pre class=\"brush:html\"><!--?xml version=\"1.0\" encoding=\"UTF-8\"?--><b>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:cache=\"http://www.springframework.org/schema/cache\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemalocation=\"  \r\n           http://www.springframework.org/schema/beans  \r\n           http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  \r\n           http://www.springframework.org/schema/aop  \r\n           http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\r\n           http://www.springframework.org/schema/context  \r\n           http://www.springframework.org/schema/context/spring-context-3.0.xsd\r\n           http://www.springframework.org/schema/cache \r\n           http://www.springframework.org/schema/cache/spring-cache-3.1.xsd\">\r\n    <!-- 自动扫描注解的bean -->\r\n    <context:component-scan base-package=\"com.**.cache;com.**.service;com.**.dao\">\r\n        <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\">\r\n    </context:exclude-filter></context:component-scan>\r\n    <!-- 开启spring缓存 -->\r\n    <cache:annotation-driven cache-manager=\"cacheManager\">  \r\n\r\n    <bean id=\"ehcache\" class=\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\">  \r\n        <property name=\"configLocation\" value=\"classpath:/META-INF/app_config/cache/ehcache.xml\"></property>  \r\n    </bean>  \r\n\r\n    <bean id=\"cacheManager\" class=\"org.springframework.cache.ehcache.EhCacheCacheManager\">  \r\n        <property name=\"cacheManager\" ref=\"ehcache\"></property>  \r\n    </bean>  \r\n\r\n\r\n</cache:annotation-driven></beans>\r\n</b></pre></div><p></p><p><b>3、假设创建了一张学生的信息表，对应的生成studentPojo.java:</b></p><p><b></b></p><div><pre class=\"brush:html\"><b>import java.io.Serializable;\r\n\r\npublic class StudentPojo implements Serializable {\r\n\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    private Integer id;\r\n\r\n    private String name;\r\n\r\n    private Integer age;\r\n\r\n    private String address;\r\n\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name == null ? null : name.trim();\r\n    }\r\n\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(String address) {\r\n        this.address = address == null ? null : address.trim();\r\n    }\r\n}\r\n</b></pre></div><p></p><p><b>3.1、对应dao层生成的studentDao.java的接口文件：</b></p><p><b></b></p><div><pre class=\"brush:html\"><b>import java.util.List;\r\n\r\nimport com.zhanglf.pojo.StudentPojo;\r\n/**\r\n * 注意：Dao层接口直接对应mapper.xml。\r\n * Dao层路径+接口名=mapper文件的namespace\r\n * @author wjw\r\n *\r\n */\r\npublic interface StudentDao {\r\n\r\n    int deleteByPrimaryKey(Integer id);\r\n\r\n    int insert(StudentPojo record);\r\n\r\n    int insertSelective(StudentPojo record);\r\n\r\n    StudentBo selectByPrimaryKey(Integer id);\r\n\r\n    //自己新增的方法。查询全部学生信息\r\n    List<studentpojo> selectAllStudent();\r\n\r\n    int updateByPrimaryKeySelective(StudentPojo record);\r\n\r\n    int updateByPrimaryKey(StudentPojo record);\r\n}\r\n</studentpojo></b></pre></div><p></p><p><b>3.2、对应给的studentMapper.xml文件：(在头部引入cache的策略)</b></p><p><b><mapper namespace=\"com.zhanglf.dao.StudentDao\"><cache type=\"org.mybatis.caches.ehcache.LoggingEhcache\"><div><pre class=\"brush:html\"><!--?xml version=\"1.0\" encoding=\"UTF-8\" ?--><b>\r\n\r\n<mapper namespace=\"com.zhanglf.dao.StudentDao\">\r\n    <resultmap id=\"BaseResultMap\" type=\"com.zhanglf.bo.StudentBo\">\r\n        <id column=\"id\" property=\"id\" jdbctype=\"INTEGER\">\r\n        <result column=\"name\" property=\"name\" jdbctype=\"VARCHAR\">\r\n        <result column=\"age\" property=\"age\" jdbctype=\"INTEGER\">\r\n        <result column=\"address\" property=\"address\" jdbctype=\"VARCHAR\">\r\n    </result></result></result></id></resultmap>\r\n    <sql id=\"Base_Column_List\">\r\n        id, name, age, address\r\n    </sql>\r\n\r\n    <!--在mapper文件中的头部引入缓存策略-->\r\n    <cache type=\"org.mybatis.caches.ehcache.LoggingEhcache\">\r\n\r\n    <!--自己新增的方法-->\r\n    <select id=\"selectAllStudent\" resultmap=\"BaseResultMap\">\r\n        select\r\n        *\r\n        from student\r\n    </select>\r\n\r\n\r\n    <select id=\"selectByPrimaryKey\" resultmap=\"BaseResultMap\" parametertype=\"java.lang.Integer\">\r\n        select\r\n        \r\n        from student\r\n        where id = #{id,jdbcType=INTEGER}\r\n    </select>\r\n\r\n\r\n    <delete id=\"deleteByPrimaryKey\" parametertype=\"java.lang.Integer\">\r\n        delete from student\r\n        where id = #{id,jdbcType=INTEGER}\r\n    </delete>\r\n\r\n\r\n    <insert id=\"insert\" parametertype=\"com.zhanglf.pojo.StudentPojo\">\r\n        insert into student (id, name, age,\r\n        address)\r\n        values (#{id,jdbcType=INTEGER}, #{name,jdbcType=VARCHAR},\r\n        #{age,jdbcType=INTEGER},\r\n        #{address,jdbcType=VARCHAR})\r\n    </insert>\r\n\r\n\r\n    <insert id=\"insertSelective\" parametertype=\"com.zhanglf.pojo.StudentPojo\">\r\n        insert into student\r\n        <trim prefix=\"(\" suffix=\")\" suffixoverrides=\",\">\r\n            <if test=\"id != null\">\r\n                id,\r\n            </if>\r\n            <if test=\"name != null\">\r\n                name,\r\n            </if>\r\n            <if test=\"age != null\">\r\n                age,\r\n            </if>\r\n            <if test=\"address != null\">\r\n                address,\r\n            </if>\r\n        </trim>\r\n        <trim prefix=\"values (\" suffix=\")\" suffixoverrides=\",\">\r\n            <if test=\"id != null\">\r\n                #{id,jdbcType=INTEGER},\r\n            </if>\r\n            <if test=\"name != null\">\r\n                #{name,jdbcType=VARCHAR},\r\n            </if>\r\n            <if test=\"age != null\">\r\n                #{age,jdbcType=INTEGER},\r\n            </if>\r\n            <if test=\"address != null\">\r\n                #{address,jdbcType=VARCHAR},\r\n            </if>\r\n        </trim>\r\n    </insert>\r\n\r\n\r\n    <update id=\"updateByPrimaryKeySelective\" parametertype=\"com.zhanglf.pojo.StudentPojo\">\r\n        update student\r\n        <set>\r\n            <if test=\"name != null\">\r\n                name = #{name,jdbcType=VARCHAR},\r\n            </if>\r\n            <if test=\"age != null\">\r\n                age = #{age,jdbcType=INTEGER},\r\n            </if>\r\n            <if test=\"address != null\">\r\n                address = #{address,jdbcType=VARCHAR},\r\n            </if>\r\n        </set>\r\n        where id = #{id,jdbcType=INTEGER}\r\n    </update>\r\n\r\n\r\n    <update id=\"updateByPrimaryKey\" parametertype=\"com.zhanglf.bo.StudentPojo\">\r\n        update student\r\n        set name = #{name,jdbcType=VARCHAR},\r\n        age = #{age,jdbcType=INTEGER},\r\n        address = #{address,jdbcType=VARCHAR}\r\n        where id = #{id,jdbcType=INTEGER}\r\n    </update>\r\n</cache></mapper>\r\n</b>\r\n</pre></div><br></cache></mapper>\r\n</b></p><p></p><p><b>3.3、然后就是</b><span style=\"text-align: start;\">com.zhanglf.cache包下的接口及其impl包下的实现类：</span></p><p><span style=\"text-align: start;\"></span></p><div><pre class=\"brush:html\">package com.zhanglf.cache;\r\n\r\nimport java.util.List;\r\n\r\nimport com.zhanglf.bo.StudentPojo;\r\n\r\npublic interface ICacheService {\r\n    final String SERVICEID=\"ICacheService\";\r\n    public List<studentbo> getAllStudent();\r\n\r\n    public StudentBo getStudentById(int id);\r\n\r\n}\r\n</studentbo></pre></div><div><pre class=\"brush:html\">package com.zhanglf.cache.impl;\r\n\r\nimport java.util.List;\r\n\r\nimport javax.annotation.Resource;\r\n\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport com.zhanglf.bo.StudentBo;\r\nimport com.zhanglf.cache.ICacheService;\r\nimport com.zhanglf.dao.StudentDao;\r\n\r\n@Service(ICacheService.SERVICEID)\r\npublic class CacheServiceImpl implements ICacheService {\r\n    @Resource\r\n    private StudentDao studentDao;\r\n\r\n    @Override\r\n    //@Cacheable(name = \"studentCache\")\r\n    public List<studentbo> getAllStudent() {\r\n         List<studentbo> list = studentDao.selectAllStudent();\r\n         if(list!=null&amp;&amp; list.size()&gt;0){\r\n             for (StudentBo student : list) {\r\n                System.out.println(\"查询得到的学生的姓名：\"+student.getName()+\",学生的年龄：\"+student.getAge()+\"学生地址：\"+student.getAddress());\r\n            }\r\n         }\r\n        return list;\r\n    }\r\n\r\n    @Override\r\n    public StudentBo getStudentById(int id) {\r\n        StudentBo student = studentDao.selectByPrimaryKey(id);\r\n        System.out.println(\"查询id为\"+id+\"的学生姓名是：\"+student.getName()+\",住址：\"+student.getAddress());\r\n\r\n        return student;\r\n    }\r\n\r\n}\r\n</studentbo></studentbo></pre></div><p></p><p><span style=\"text-align: start;\">4、最后的controller层：</span></p><p></p><div><pre class=\"brush:html\">package com.zhanglf.controller;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport javax.annotation.Resource;\r\nimport javax.servlet.http.HttpServletRequest;\r\n\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.ResponseBody;\r\n\r\nimport com.zhanglf.bo.StudentPojo;\r\nimport com.zhanglf.cache.ICacheService;\r\n\r\n@Controller\r\n@RequestMapping(\"/student\")\r\npublic class StudentController {\r\n\r\n    @Resource(name = ICacheService.SERVICEID)\r\n    private ICacheService cacheService;\r\n\r\n    @RequestMapping(\"/info\")\r\n    @ResponseBody\r\n    public List getAllStudentInfo() {\r\n        List<studentbo> list = new ArrayList&lt;&gt;();\r\n        list = cacheService.getAllStudent();\r\n        return list;\r\n    }\r\n\r\n    @RequestMapping(\"/byId\")\r\n    @ResponseBody\r\n    public Integer getAllStudentInfoById(HttpServletRequest request) {\r\n        List<studentbo> list = new ArrayList&lt;&gt;();\r\n        StudentBo bo = cacheService.getStudentById(Integer.valueOf(request\r\n                .getParameter(\"id\")));\r\n\r\n        return bo.getAge();\r\n    }\r\n\r\n}\r\n</studentbo></studentbo></pre></div><p></p><p>5、<span style=\"text-align: start;\">那么我们该怎样测试缓存成功了没有呢？这里我们回头看一下ehcache.xml中我们配置的缓存失效策略，如果我们访问后二十秒空置，不调用查询全部语句，则这个数据在缓存里就被清掉了。所以我们可以通过修改数据库中的数据，然后如果我们保持访问，则第一次查询操作加载到缓存中的数据会一直存在，即使20秒过了也会是一只是第一次加载进缓存的数据，而此时数据库中的数据我们已经改变了。可以证明缓存的存在的。然后我们停止查询操作20秒，这里不妨多等一会，在次执行这个链接访问数据库，可以看到查询到页面的数据已经和数据库中的一样了。这就说明之前的缓存已经被清除，证明缓存策略生效是出来效果的，也就是我们的搭建缓存框架是成功的。</span></p><p></p>', null, '1', '9', '11,12,13,20', '27', '0', '0', '2018-01-24 23:37:08', '2018-01-25 00:08:23', '1', '1', '1');
INSERT INTO `article` VALUES ('9', '1', 'Servlet 实现验证码', '<h2>分析</h2><p><strong>生成图片实现类</strong></p><p>Image<a href=\"https://liuyanzhao.com/tag/servlet/\" title=\"查看与 Servlet 相关的文章\" target=\"_blank\">Servlet</a>&nbsp;类</p><p>① 定义BufferedImage 对象</p><p>② 获得 Graphics 对象</p><p>③ 通过 Random 产生随机验证码信息</p><p>④ 使用 Graphics 绘制图片</p><p>⑤ 记录验证码信息到 session 中</p><p>⑥ 使用 ImageIO 输出图片</p><h2>代码实现</h2><p>1、新建 web 项目 CheckCode，在 WebContent 下新建 index.jsp</p><p><strong>index.jsp</strong></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-xml\" start=\"1\"><li class=\"alt\"><span class=\"tag\">&lt;</span>%@&nbsp;page&nbsp;<span class=\"attribute\">language</span>=<span class=\"attribute-value\">\"java\"</span>&nbsp;<span class=\"attribute\">contentType</span>=<span class=\"attribute-value\">\"text/html;&nbsp;charset=UTF-8\"</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"attribute\">pageEncoding</span>=<span class=\"attribute-value\">\"UTF-8\"</span>%<span class=\"tag\">&gt;</span></li><li class=\"alt\">&gt;</li><li class=\"\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">html</span><span class=\"tag\">&gt;</span></li><li class=\"alt\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">head</span><span class=\"tag\">&gt;</span></li><li class=\"\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">meta</span>&nbsp;<span class=\"attribute\">http-equiv</span>=<span class=\"attribute-value\">\"Content-Type\"</span>&nbsp;<span class=\"attribute\">content</span>=<span class=\"attribute-value\">\"text/html;&nbsp;charset=UTF-8\"</span><span class=\"tag\">&gt;</span></li><li class=\"alt\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">title</span><span class=\"tag\">&gt;</span>Insert&nbsp;title&nbsp;here<span class=\"tag\"><!--</span--><span class=\"tag-name\">title</span><span class=\"tag\">&gt;</span></span></li><li class=\"\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">script</span>&nbsp;<span class=\"attribute\">type</span>=<span class=\"attribute-value\">\"text/javascript\"</span><span class=\"tag\">&gt;</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;reloadCode()&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//传个时间参数，防止缓存</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;<span class=\"attribute\">time</span>&nbsp;=&nbsp;<span class=\"attribute-value\">new</span>&nbsp;Date().getTime();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementById(\"imageCode\")<span class=\"attribute\">.src</span>=<span class=\"attribute-value\">\"&lt;%=request.getContextPath()%&gt;/Image<a href=\"https://liuyanzhao.com/tag/servlet/\" title=\"查看与 Servlet 相关的文章\" target=\"_blank\">Servlet</a>?d=\"</span>+time;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"><span class=\"tag\"><!--</span--><span class=\"tag-name\">script</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\"><span class=\"tag\"><!--</span--><span class=\"tag-name\">head</span><span class=\"tag\">&gt;</span></span></li><li class=\"\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">body</span><span class=\"tag\">&gt;</span></li><li class=\"alt\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">form</span>&nbsp;<span class=\"attribute\">action</span>=<span class=\"attribute-value\">\"&lt;%=request.getContextPath()%&gt;/Login<a href=\"https://liuyanzhao.com/tag/servlet/\" title=\"查看与 Servlet 相关的文章\" target=\"_blank\">Servlet</a>\"</span>&nbsp;<span class=\"attribute\">method</span>=<span class=\"attribute-value\">\"post\"</span><span class=\"tag\">&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;验证码：<span class=\"tag\">&lt;</span><span class=\"tag-name\">input</span>&nbsp;<span class=\"attribute\">type</span>=<span class=\"attribute-value\">\"text\"</span>&nbsp;<span class=\"attribute\">name</span>=<span class=\"attribute-value\">\"checkcode\"</span>&nbsp;<span class=\"tag\">/&gt;</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">img</span>&nbsp;<span class=\"attribute\">id</span>=<span class=\"attribute-value\">\"imageCode\"</span>&nbsp;<span class=\"attribute\">src</span>=<span class=\"attribute-value\">\"&lt;%=request.getContextPath()%&gt;/Image<a href=\"https://liuyanzhao.com/tag/servlet/\" title=\"查看与 Servlet 相关的文章\" target=\"_blank\">Servlet</a>\"</span>&nbsp;<span class=\"attribute\">alt</span>=<span class=\"attribute-value\">\"验证码\"</span>&nbsp;<span class=\"tag\">/&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">a</span>&nbsp;<span class=\"attribute\">href</span>=<span class=\"attribute-value\">\"javascript:reloadCode();\"</span><span class=\"tag\">&gt;</span>看不清楚<span class=\"tag\"><!--</span--><span class=\"tag-name\">a</span><span class=\"tag\">&gt;</span>&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">br</span>&nbsp;<span class=\"tag\">/&gt;</span></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">input</span>&nbsp;<span class=\"attribute\">type</span>=<span class=\"attribute-value\">\"submit\"</span>&nbsp;&nbsp;<span class=\"attribute\">value</span>=<span class=\"attribute-value\">\"提交\"</span><span class=\"tag\">/&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">form</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\"><span class=\"tag\"><!--</span--><span class=\"tag-name\">body</span><span class=\"tag\">&gt;</span></span></li><li class=\"\"><span class=\"tag\"><!--</span--><span class=\"tag-name\">html</span><span class=\"tag\">&gt;</span></span></li></ol></div><p>2、在 src 下新建 com.test包，然后分别新建用于动态画图的 Image<a href=\"https://liuyanzhao.com/tag/servlet/\" title=\"查看与 Servlet 相关的文章\" target=\"_blank\">Servlet</a>&nbsp;类和用于判断验证码是否正确的 Login<a href=\"https://liuyanzhao.com/tag/servlet/\" title=\"查看与 Servlet 相关的文章\" target=\"_blank\">Servlet</a>&nbsp;类</p><p><strong>Image<a href=\"https://liuyanzhao.com/tag/servlet/\" title=\"查看与 Servlet 相关的文章\" target=\"_blank\">Servlet</a>.java</strong></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">package</span>&nbsp;com.test;</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.awt.Color;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;java.awt.Graphics;</li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.awt.image.BufferedImage;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;java.io.IOException;</li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.util.Random;</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;javax.imageio.ImageIO;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;javax.servlet.<a href=\"https://liuyanzhao.com/tag/servlet/\" title=\"查看与 Servlet 相关的文章\" target=\"_blank\">Servlet</a>Exception;</li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;javax.servlet.http.Http<a href=\"https://liuyanzhao.com/tag/servlet/\" title=\"查看与 Servlet 相关的文章\" target=\"_blank\">Servlet</a>;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;javax.servlet.http.HttpServletRequest;</li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;javax.servlet.http.HttpServletResponse;</li><li class=\"\"></li><li class=\"alt\"></li><li class=\"\"><span class=\"comment\">/*</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*&nbsp;@author wjw</span></li><li class=\"\"><span class=\"comment\">&nbsp;*/</span></li><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;ImageServlet&nbsp;<span class=\"keyword\">extends</span>&nbsp;HttpServlet&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"annotation\">@Override</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">protected</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;doGet(HttpServletRequest&nbsp;request,&nbsp;HttpServletResponse&nbsp;response)&nbsp;<span class=\"keyword\">throws</span>&nbsp;ServletException,&nbsp;IOException&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BufferedImage&nbsp;bi&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;BufferedImage(<span class=\"number\">68</span>,&nbsp;<span class=\"number\">22</span>,&nbsp;BufferedImage.TYPE_INT_RGB);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graphics&nbsp;g&nbsp;=&nbsp;bi.getGraphics();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Color&nbsp;c&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Color(<span class=\"number\">200</span>,<span class=\"number\">155</span>,<span class=\"number\">255</span>);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(c);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(<span class=\"number\">0</span>,&nbsp;<span class=\"number\">0</span>,&nbsp;<span class=\"number\">68</span>,&nbsp;<span class=\"number\">22</span>);</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">char</span>[]&nbsp;ch&nbsp;=&nbsp;<span class=\"string\">\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"</span>.toCharArray();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Random&nbsp;r&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Random();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">int</span>&nbsp;len&nbsp;=&nbsp;ch.length,index;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer&nbsp;sb&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;StringBuffer();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>&nbsp;i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;=&nbsp;r.nextInt(len);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(<span class=\"keyword\">new</span>&nbsp;Color(r.nextInt(<span class=\"number\">88</span>),r.nextInt(<span class=\"number\">188</span>),r.nextInt(<span class=\"number\">255</span>)));</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawString(ch[index]+<span class=\"string\">\"\"</span>,&nbsp;(i*<span class=\"number\">15</span>)+<span class=\"number\">3</span>,&nbsp;<span class=\"number\">18</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append(ch[index]);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;request.getSession().setAttribute(<span class=\"string\">\"piccode\"</span>,&nbsp;sb.toString());</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageIO.write(bi,&nbsp;<span class=\"string\">\"JPG\"</span>,&nbsp;response.getOutputStream());</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"annotation\">@Override</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">protected</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;doPost(HttpServletRequest&nbsp;request,&nbsp;HttpServletResponse&nbsp;response)&nbsp;<span class=\"keyword\">throws</span>&nbsp;ServletException,&nbsp;IOException&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doGet(request,&nbsp;response);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">}</li></ol></div><p><strong>LoginServlet.java</strong></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">package</span>&nbsp;com.test;</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.io.IOException;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;java.io.PrintWriter;</li><li class=\"alt\"></li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;javax.servlet.ServletException;</li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;javax.servlet.http.HttpServlet;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;javax.servlet.http.HttpServletRequest;</li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;javax.servlet.http.HttpServletResponse;</li><li class=\"\"></li><li class=\"alt\"><span class=\"comment\">/*</span></li><li class=\"\"><span class=\"comment\">&nbsp;*&nbsp;@author wjw</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*/</span></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;LoginServlet&nbsp;<span class=\"keyword\">extends</span>&nbsp;HttpServlet{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"annotation\">@Override</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">protected</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;doPost(HttpServletRequest&nbsp;request,&nbsp;HttpServletResponse&nbsp;response)&nbsp;<span class=\"keyword\">throws</span>&nbsp;ServletException,&nbsp;IOException&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;piccode&nbsp;=&nbsp;(String)request.getSession().getAttribute(<span class=\"string\">\"piccode\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;checkcode&nbsp;=&nbsp;request.getParameter(<span class=\"string\">\"checkcode\"</span>);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkcode&nbsp;=&nbsp;checkcode.toUpperCase();<span class=\"comment\">//不区分大小写</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;response.setContentType(<span class=\"string\">\"text/html;charset=utf-8\"</span>);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PrintWriter&nbsp;out&nbsp;=&nbsp;response.getWriter();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">if</span>(piccode.equals(checkcode))&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.println(<span class=\"string\">\"验证码输入正确\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class=\"keyword\">else</span>&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.println(<span class=\"string\">\"验证码输入错误\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.flush();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.close();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"annotation\">@Override</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">protected</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;doGet(HttpServletRequest&nbsp;request,&nbsp;HttpServletResponse&nbsp;response)&nbsp;<span class=\"keyword\">throws</span>&nbsp;ServletException,&nbsp;IOException&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doPost(request,&nbsp;response);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">}</li></ol></div><p>3、在 web.xml 里添加 Servlet 映射</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-xml\" start=\"1\"><li class=\"alt\"><span class=\"tag\">&lt;</span><span class=\"tag-name\">servlet</span><span class=\"tag\">&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">servlet-name</span><span class=\"tag\">&gt;</span>ImageServlet<span class=\"tag\"><!--</span--><span class=\"tag-name\">servlet-name</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">servlet-class</span><span class=\"tag\">&gt;</span>com.test.ImageServlet<span class=\"tag\"><!--</span--><span class=\"tag-name\">servlet-class</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">servlet</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">servlet-mapping</span><span class=\"tag\">&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!-- 映射为 ImageServlet --></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">servlet-name</span><span class=\"tag\">&gt;</span>ImageServlet<span class=\"tag\"><!--</span--><span class=\"tag-name\">servlet-name</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">url-pattern</span><span class=\"tag\">&gt;</span>/ImageServlet<span class=\"tag\"><!--</span--><span class=\"tag-name\">url-pattern</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">servlet-mapping</span><span class=\"tag\">&gt;</span></span></li><li class=\"\"></li><li class=\"alt\">&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">servlet</span><span class=\"tag\">&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">servlet-name</span><span class=\"tag\">&gt;</span>LoginServlet<span class=\"tag\"><!--</span--><span class=\"tag-name\">servlet-name</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">servlet-class</span><span class=\"tag\">&gt;</span>com.test.LoginServlet<span class=\"tag\"><!--</span--><span class=\"tag-name\">servlet-class</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">servlet</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">servlet-mapping</span><span class=\"tag\">&gt;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comments\"><!-- 映射为 IndexServlet --></span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">servlet-name</span><span class=\"tag\">&gt;</span>LoginServlet<span class=\"tag\"><!--</span--><span class=\"tag-name\">servlet-name</span><span class=\"tag\">&gt;</span></span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"tag\">&lt;</span><span class=\"tag-name\">url-pattern</span><span class=\"tag\">&gt;</span>/LoginServlet<span class=\"tag\"><!--</span--><span class=\"tag-name\">url-pattern</span><span class=\"tag\">&gt;</span></span></li><li class=\"alt\">&nbsp;<span class=\"tag\"><!--</span--><span class=\"tag-name\">servlet-mapping</span><span class=\"tag\">&gt;</span></span></li></ol></div><p>4、运行 Tomcat 服务器，打开浏览器，访问&nbsp;http://localhost:8080/CheckCode</p><p>效果如下</p><p><img src=\"/uploads/2017/10/20171007155723341.png\" alt=\"20171007155723341.png\"><br></p><p>验证码不区分大小写，点击 “看不清楚”可以更换</p>', null, '1', '8', '19', '20', '1', '0', '2017-10-07 15:57:38', '2018-01-24 23:24:05', '1', '1', '1');
INSERT INTO `article` VALUES ('10', '1', 'Integer与int的种种比较你知道多少？', '<p>如果面试官问Integer与int的区别：估计大多数人只会说道两点，Ingeter是int的包装类，int的初值为0，Ingeter的初值为null。但是如果面试官再问一下Integer a = 1;int b&nbsp;= 1; a==b为true还是为false？估计就有一部分人答不出来了，如果再问一下其他的，估计更多的人会头脑一片混乱。所以我对它们进行了总结，希望对大家有帮助。</p><p><strong>首先看代码：</strong></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"comment\">/*&nbsp;</span></li><li class=\"\"><span class=\"comment\">&nbsp;*&nbsp;@author wjw</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*</span></li><li class=\"\"><span class=\"comment\">&nbsp;*/</span></li><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;Test&nbsp;{</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">static</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">int</span>&nbsp;i&nbsp;=&nbsp;<span class=\"number\">128</span>;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i2&nbsp;=&nbsp;<span class=\"number\">128</span>;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i3&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Integer(<span class=\"number\">128</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//Integer会自动拆箱为int，所以为true</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i&nbsp;==&nbsp;i2);<span class=\"comment\">//true</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i&nbsp;==&nbsp;i3);<span class=\"comment\">//true</span></li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//java在编译的时候,被翻译成-&gt;&nbsp;Integer&nbsp;i5&nbsp;=&nbsp;Integer.valueOf(127);</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i5&nbsp;=&nbsp;<span class=\"number\">127</span>;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i6&nbsp;=&nbsp;<span class=\"number\">127</span>;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i5&nbsp;==&nbsp;i6);<span class=\"comment\">//true</span></li><li class=\"\"></li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i7&nbsp;=&nbsp;<span class=\"number\">128</span>;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i8&nbsp;=&nbsp;<span class=\"number\">128</span>;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i7&nbsp;==&nbsp;i8);<span class=\"comment\">//false</span></li><li class=\"alt\"></li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i9&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Integer(<span class=\"number\">127</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i10&nbsp;=&nbsp;<span class=\"number\">127</span>;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i9&nbsp;==&nbsp;i10);&nbsp;<span class=\"comment\">//false</span></li><li class=\"\"></li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i11&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Integer(<span class=\"number\">128</span>);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;i12&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Integer(<span class=\"number\">123</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(i11&nbsp;==&nbsp;i12);&nbsp;&nbsp;<span class=\"comment\">//false</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">}</li></ol></div><p><strong>详解如下：</strong></p><p>首先，13行和14行输出结果都为true,因为Integer和int比都会自动拆箱（jdk1.5以上）。</p><p>19行的结果为true,而24行则为false,很多人都不懂为什么。其实java在编译Integer i5 = 127的时候,被翻译成-&gt; Integer i5 = Integer.valueOf(127);所以关键就是看valueOf()函数了。只要看看valueOf()函数的源码就会明白了。JDK源码的valueOf函数式这样的：</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">static</span>&nbsp;Integer&nbsp;valueOf(<span class=\"keyword\">int</span>&nbsp;i)&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">assert</span>&nbsp;IntegerCache.high&nbsp;&gt;=&nbsp;<span class=\"number\">127</span>;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">if</span>&nbsp;(i&nbsp;&gt;=&nbsp;IntegerCache.low&nbsp;&amp;&amp;&nbsp;i&nbsp;&lt;=&nbsp;IntegerCache.high)</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;IntegerCache.cache[i&nbsp;+&nbsp;(-IntegerCache.low)];</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">return</span>&nbsp;<span class=\"keyword\">new</span>&nbsp;Integer(i);</li><li class=\"\">}</li></ol></div><p>看一下源码大家都会明白，对于-128到127之间的数，会进行缓存，Integer i5 = 127时，会将127进行缓存，下次再写Integer i6 = 127时，就会直接从缓存中取，就不会new了。所以22行的结果为true,而25行为false。</p><p>对于29行和34行，因为对象不一样，所以为false。</p><p>我对于以上的情况总结如下：</p><p>① 无论如何，<span><strong>Integer与new Integer不会相等</strong></span>。不会经历拆箱过程，i3的引用指向堆，而i4指向专门存放他的内存（常量池），他们的内存地址不一样，所以为false</p><p>②&nbsp;<strong><span>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false</span></strong></p><p>java在编译Integer i2 = 128的时候,被翻译成-&gt; Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存</p><p>③&nbsp;<strong><span>两</span><span>个都是new出来的,都为false</span></strong></p><p>④&nbsp;<strong><span>int和Integer(无论new否)比，都为true</span></strong>，因为会把Integer自动拆箱为int再去比</p><p>&nbsp;</p><p>参考：<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=http://www.cnblogs.com/liuling/archive/2013/05/05/intAndInteger.html\" target=\"_blank\" rel=\"noopener noreferrer\">http://www.cnblogs.com/liuling/archive/2013/05/05/intAndInteger.html</a></p><div><br></div>', null, '1', '2', '1', '11', '0', '1', '2017-10-07 15:58:51', '2018-01-24 23:21:56', '1', '1', '1');
INSERT INTO `article` VALUES ('11', '1', 'Java如何让程序一直运行，不停止', '<p>如何让程序一直运行，很容易实现，只需要一直等待输出即可啦</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.util.Scanner;</li><li class=\"\"></li><li class=\"alt\"><span class=\"comment\">/*</span></li><li class=\"\"><span class=\"comment\">&nbsp;*&nbsp;@author wjw</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*/</span></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;Test&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">private</span>&nbsp;<span class=\"keyword\">static</span>&nbsp;<span class=\"keyword\">final</span>&nbsp;String&nbsp;OPERATION_EXIT&nbsp;=&nbsp;<span class=\"string\">\"EXIT\"</span>;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">static</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"请开始您的输入，EXIT/E&nbsp;退出\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//怎么让程序一直运行</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scanner&nbsp;scan&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;Scanner(System.in);</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">while</span>(scan.hasNext())&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;in&nbsp;=&nbsp;scan.next().toString();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">if</span>(OPERATION_EXIT.equals(in.toUpperCase())</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;OPERATION_EXIT.substring(<span class=\"number\">0</span>,&nbsp;<span class=\"number\">1</span>).equals(in.toUpperCase()))&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"您成功已退出！\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">break</span>;</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"您输入的值：\"</span>+in);</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">}</li><li></li></ol></div>', null, '1', '2', '1', '14', '0', '0', '2017-10-07 15:59:33', '2018-01-24 23:21:12', '1', '1', '1');
INSERT INTO `article` VALUES ('12', '1', 'Java中静态代码块、构造代码块的区别', '<p>直接在类中定义且没有加static关键字的代码块称为{}构造代码块。</p><p><strong><span>构造代码块在创建对象时被调用，每次创建对象都会被调用</span></strong>，并且构造代码块的执行次序优先于类构造函数。</p><p>静态代码块:在java中使用static关键字声明的代码块。<span><strong>静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行</strong></span>。</p><p>注意：1 静态代码块不能存在于任何方法体内。2 静态代码块不能直接访问静态实例变量和实例方法，需要通过类的实例对象来访问。</p><p>静态代码块、构造代码块、构造函数同时存在时的执行顺序：<strong><span>静态代码块 &gt; 构造代码块 &nbsp;&gt; 构造函数</span></strong>；</p><p>&nbsp;</p><p>下面我们来举几个例子说明一切</p><p><strong>demo1：构造方法</strong></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;Test&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">static</span>&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"静态块\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"构造块，在类中定义\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;Test()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"构造方法执行\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">static</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">new</span>&nbsp;Test();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">new</span>&nbsp;Test();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">&nbsp;}</li><li class=\"alt\"><span class=\"comment\">/*</span></li><li class=\"\"><span class=\"comment\">静态块</span></li><li class=\"alt\"><span class=\"comment\">构造块，在类中定义</span></li><li class=\"\"><span class=\"comment\">构造方法执行</span></li><li class=\"alt\"><span class=\"comment\">构造块，在类中定义</span></li><li class=\"\"><span class=\"comment\">构造方法执行</span></li><li class=\"alt\"><span class=\"comment\">*/</span></li></ol></div><p><strong>demo2:普通代码块</strong></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"comment\">/*普通代码块：在方法或语句中出现的{}就称为普通代码块。</span></li><li class=\"\"><span class=\"comment\">普通代码块和一般的语句执行顺序由他们在代码中出现的次序决定--“先出现先执行”*/</span></li><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;Test&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">static</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">int</span>&nbsp;x&nbsp;=&nbsp;<span class=\"number\">3</span>;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"1,普通代码块内的变量x=\"</span>&nbsp;+&nbsp;x);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">int</span>&nbsp;x&nbsp;=&nbsp;<span class=\"number\">1</span>;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"主方法内的变量x=\"</span>&nbsp;+&nbsp;x);</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">int</span>&nbsp;y&nbsp;=&nbsp;<span class=\"number\">7</span>;</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"2,普通代码块内的变量y=\"</span>&nbsp;+&nbsp;y);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">}</li><li class=\"\"></li><li class=\"alt\"><span class=\"comment\">/*&nbsp;</span></li><li class=\"\"><span class=\"comment\">1,普通代码块内的变量x=3</span></li><li class=\"alt\"><span class=\"comment\">主方法内的变量x=1</span></li><li class=\"\"><span class=\"comment\">2,普通代码块内的变量y=7</span></li><li class=\"alt\"><span class=\"comment\">*/</span></li></ol></div><p><strong>demo3:构造代码块</strong></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"comment\">/*构造块：直接在类中定义且没有加static关键字的代码块称为{}构造代码块。</span></li><li class=\"\"><span class=\"comment\">构造代码块在创建对象时被调用，每次创建对象都会被调用，</span></li><li class=\"alt\"><span class=\"comment\">并且构造代码块的执行次序优先于类构造函数。*/</span></li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;Test&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"第一代码块\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;Test()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"构造方法\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"第二构造块\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">static</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">new</span>&nbsp;Test();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">new</span>&nbsp;Test();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">new</span>&nbsp;Test();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">}</li><li class=\"\"><span class=\"comment\">/*</span></li><li class=\"alt\"><span class=\"comment\">第一代码块</span></li><li class=\"\"><span class=\"comment\">第二构造块</span></li><li class=\"alt\"><span class=\"comment\">构造方法</span></li><li class=\"\"><span class=\"comment\">第一代码块</span></li><li class=\"alt\"><span class=\"comment\">第二构造块</span></li><li class=\"\"><span class=\"comment\">构造方法</span></li><li class=\"alt\"><span class=\"comment\">第一代码块</span></li><li class=\"\"><span class=\"comment\">第二构造块</span></li><li class=\"alt\"><span class=\"comment\">构造方法</span></li><li class=\"\"><span class=\"comment\">*/</span></li></ol></div><p><strong>demo4:静态代码块</strong></p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"comment\">/*静态代码块:在java中使用static关键字声明的代码块。</span></li><li class=\"\"><span class=\"comment\">静态块用于初始化类，为类的属性初始化。</span></li><li class=\"alt\"><span class=\"comment\">每个静态代码块只会执行一次。</span></li><li class=\"\"><span class=\"comment\">由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行。</span></li><li class=\"alt\"><span class=\"comment\">如果类中包含多个静态代码块，那么将按照\"先定义的代码先执行，后定义的代码后执行\"。</span></li><li class=\"\"><span class=\"comment\">注意：1&nbsp;静态代码块不能存在于任何方法体内。</span></li><li class=\"alt\"><span class=\"comment\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2&nbsp;静态代码块不能直接访问静态实例变量和实例方法，需要通过类的实例对象来访问。*/</span></li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">class</span>&nbsp;Code&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"Code的构造块\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">static</span>&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"Code的静态代码块\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;Code()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"Code的构造方法\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">}</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;Test&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"Test的构造块\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">static</span>&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"Test的静态代码块\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;Test()&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"Test的构造方法\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">static</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<span class=\"string\">\"Test的主方法\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">new</span>&nbsp;Code();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">new</span>&nbsp;Code();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">new</span>&nbsp;Test();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">new</span>&nbsp;Test();</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">}</li><li class=\"\"><span class=\"comment\">/*</span></li><li class=\"alt\"><span class=\"comment\">Test的静态代码块</span></li><li class=\"\"><span class=\"comment\">Test的主方法</span></li><li class=\"alt\"><span class=\"comment\">Code的静态代码块</span></li><li class=\"\"><span class=\"comment\">Code的构造块</span></li><li class=\"alt\"><span class=\"comment\">Code的构造方法</span></li><li class=\"\"><span class=\"comment\">Code的构造块</span></li><li class=\"alt\"><span class=\"comment\">Code的构造方法</span></li><li class=\"\"><span class=\"comment\">Test的构造块</span></li><li class=\"alt\"><span class=\"comment\">Test的构造方法</span></li><li class=\"\"><span class=\"comment\">Test的构造块</span></li><li class=\"alt\"><span class=\"comment\">Test的构造方法</span></li><li class=\"\"><span class=\"comment\">&nbsp;*/</span></li><li></li></ol></div>', null, '1', '2', '1', '11', '0', '0', '2017-10-07 16:00:06', '2017-10-07 16:00:06', '1', '1', '1');
INSERT INTO `article` VALUES ('13', '1', 'sql语句分为三类(DML,DDL,DCL)-介绍', '<p><span>DML（data manipulation language）：数据库操作语言</span><br><span>它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样</span></p><p>&nbsp;</p><p><span>DDL（data definition language）：的数据库定义语言</span><br><span>主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用</span></p><p>&nbsp;</p><p><span>DCL（Data Control Language）：&nbsp;数据库控制语言</span><br><span>是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL</span></p><p>&nbsp;</p><p><strong>详细解释：</strong></p><h2>一、DDL is Data Definition Language statements</h2><p>数据定义语言，用于定义和管理&nbsp;<a href=\"https://liuyanzhao.com/tag/sql/\" title=\"查看与 SQL 相关的文章\" target=\"_blank\">SQL</a>&nbsp;数据库中的所有对象的语言</p><p>1.CREATE - to create objects in the database&nbsp;&nbsp; 创建</p><p>2.ALTER - alters the structure of the database&nbsp;&nbsp; 修改</p><p>3.DROP - delete objects from the database&nbsp;&nbsp; 删除</p><p>4.TRUNCATE - remove all records from a table, including all spaces allocated for the records are removed</p><p>TRUNCATE TABLE [Table Name]。</p><p>下面是对Truncate语句在MS<a href=\"https://liuyanzhao.com/tag/sql/\" title=\"查看与 SQL 相关的文章\" target=\"_blank\">SQL</a>Server2000中用法和原理的说明：</p><p>Truncate table 表名 速度快,而且效率高,因为:</p><p>TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但</p><p>TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。</p><p>DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存</p><p>储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p><p>TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p><p>对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p><p>TRUNCATE TABLE 不能用于参与了索引视图的表。</p><p>5.COMMENT - add comments to the data dictionary 注释</p><p>6.GRANT - gives user\'s access privileges to database 授权</p><p>7.REVOKE - withdraw access privileges given with the GRANT command&nbsp;&nbsp; 收回已经授予的权限</p><p>&nbsp;</p><h2>二、DML is Data Manipulation Language statements</h2><p>数据操作语言，SQL中处理数据等操作统称为数据操纵语言</p><p>1.SELECT - retrieve data from the a database&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查询</p><p>2.INSERT - insert data into a table&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 添加</p><p>3.UPDATE - updates existing data within a table&nbsp;&nbsp;&nbsp; 更新</p><p>4.DELETE - deletes all records from a table, the space for the records remain&nbsp;&nbsp; 删除</p><p>5.CALL - call a PL/SQL or Java subprogram</p><p>6.EXPLAIN PLAN - explain access path to data</p><p>Oracle RDBMS执行每一条SQL语句，都必须经过Oracle优化器的评估。所以，了解优化器是如何选择(搜索)路径以及索引是如何被使用的，对优化SQL语句有很大的帮助。Explain可以用来迅速方便地查出对于给定SQL语句中的查询数据是如何得到的即搜索路径(我们通常称为Access Path)。从而使我们选择最优的查询方式达到最大的优化效果。</p><p>7.LOCK TABLE - control concurrency 锁，用于控制并发</p><p>&nbsp;</p><h2>三、DCL is Data Control Language statements</h2><p>数据控制语言，用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等</p><p>1.COMMIT - save work done 提交</p><p>2.SAVEPOINT - identify a point in a transaction to which you can later roll back 保存点</p><p>3.ROLLBACK - restore database to original since the last COMMIT&nbsp;&nbsp; 回滚</p><p>4.SET TRANSACTION - Change transaction options like what rollback segment to use&nbsp;&nbsp; 设置当前事务的特性，它对后面的事务没有影响</p><div><br></div>', null, '10', '13', '9,22', '15', '3', '1', '2017-10-07 16:00:50', '2017-10-07 16:01:07', '1', '1', '1');
INSERT INTO `article` VALUES ('14', '1', 'execute、executeUpdate、executeQuery三者的区别', '<p>1.&nbsp;ResultSet&nbsp;executeQuery(String sql); 执行SQL查询，并返回 ResultSet 对象。</p><p>例如：被执行最多的 SELECT 语句。</p><p>2.int&nbsp;executeUpdate(String sql); 可执行增，删，改，返回执行受到影响的行数。</p><p>例如：&nbsp;INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句</p><p>3.&nbsp;boolean&nbsp;execute(String sql); 可执行任何SQL语句，返回一个布尔值，表示是否返回 ResultSet 。</p><p><strong>&nbsp; &nbsp; &nbsp;<span>&nbsp;&nbsp;execute是executeQuery和executeUpdate的综合.</span></strong></p><p><strong><span>通常我们没有必要使用execute方法来执行SQL语句，而是使用 executeQuery 或 executeUpdate 更适合。</span></strong></p><p>-----</p><p>&nbsp;</p><p>executeUpdate() 这是 PreparedStatement 接口中的方法</p><p>executeUpdate(String sql) 这是 PreparedStatement 从父接口 Statement 中继承过来的方法</p><p>executeUpdate() 中执行 SQL 语句需要在创建 PerparedStatement 时通过 Connection 的 prepareStatement(String sql) 方法中写出，因为 PerparedStatement 中的 SQL 语句数据库需要进行预编译和缓存，因此要在创建 PerparedStatement 对象时给出 SQL 语句。</p><p>而 executeUpdate(String sql) 是 Statement 中的方法，参数中的 SQL 语句只是提交给数据库去执行，并不需要预编译。</p><p><strong>如果 SQL 语句中有 ? 占位符，那么在设置好占位符中的值后，必须使用 executeUpdate() 执行。而 executeUpdate(String sql) 只是提交一个 SQL 语句，且这个语句中不能带有 ? 占位符。</strong></p><p>当然，我们最好不要用 Statement 接口<br>参考：http://www.cnblogs.com/bukudekong/archive/2011/06/22/2086531.html</p>', null, '1', '8', '20,22', '19', '3', '0', '2017-10-07 16:02:12', '2017-10-07 16:02:12', '1', '1', '1');
INSERT INTO `article` VALUES ('15', '1', 'JSP 中 forward 转发 和 sendRedirect 重定向的区别', '<h2>本质区别：</h2><div>&nbsp; &nbsp; &nbsp;&nbsp;<b>一句话概括：</b>重定向是客户端行为，转发是服务器行为.</div><div><b>&nbsp; &nbsp; &nbsp;1.请求次数：</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;重定向：重定向行为是做了两次请求，及产生了两个request对象，重定向会导致request对象信息丢失。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;请求转发：转发做了一次请求， 浏览器的地址栏一直是第一次请求的地址。转发是服务器内部request/response控制权的移交。</div><div>&nbsp; &nbsp; &nbsp;&nbsp;<b>2.请求资源地址：</b></div><p><strong>重定向</strong>：web组件可以将请求重定向到任意一个url，而不仅仅是同一个应用。</p><p>重定向的源组件与目标组件不共用同一个HttpServletRequest对象，因此不能在request范围内共享数据。</p><p><strong>请求转发</strong>：转发的源组件与目标组件必须在同一个应用中，两者可以在request范围内共享数据。</p><div><strong>&nbsp; &nbsp; &nbsp; &nbsp;3.一种解释：</strong></div><div><p>假设你去办理某个执照</p><p><strong>重定向</strong>：你先去了A局，A局的人说：“这个事情不归我们管，去B局”，然后，你就从A退了出来，自己乘车去了B局。</p><p><strong>请求转发</strong>：你先去了A局，A局看了以后，知道这个事情其实应该B局来管，但是他没有把你退回来，而是让你坐一会儿，自己到后面办公室联系了B的人，让他们办好后，送了过来。</p></div><div><h2><b>工作流程：</b></h2></div><p><strong>1.重定向</strong></p><p>浏览器发出http请求&nbsp;&nbsp;<b>&gt;&gt;</b>&nbsp;服务器接受请求并发送302状态码和新的对应的url到浏览器&nbsp;&nbsp;<b>&gt;&gt;</b></p><p>浏览器接收响应并自动请求新的url&nbsp;&nbsp;<b>&gt;&gt;</b>&nbsp;服务器接收请求并寻找客户所需的资源响应到浏览器</p><p><strong>2.转发</strong></p><p>浏览器发出http求其&nbsp;&nbsp;<b>&gt;&gt;</b>&nbsp;服务器接收请求&nbsp;&nbsp;<b>&gt;&gt;</b>　服务器调用内部的一个方法在容器内完成请求处理和转发动作&nbsp;&nbsp;<b>&gt;&gt;</b></p><p>将客户所需资源发送到浏览</p><p>&nbsp;</p><h2><b>调用方式：</b></h2><p>我们知道，在servlet中调用转发、重定向的语句如下：</p><p>request.getRequestDispatcher(\"new.jsp\").forward(request, response);&nbsp;&nbsp; //转发到new.jsp</p><p>response.sendRedirect(\"new.jsp\");&nbsp;&nbsp; //重定向到new.jsp</p><p>在jsp页面中你也会看到通过下面的方式实现转发：</p><p>&lt;jsp:forward page=\"apage.jsp\" /&gt;</p><p>当然也可以在jsp页面中实现重定向：</p><p>&lt;%response.sendRedirect(\"new.jsp\"); %&gt;&nbsp;//重定向到new.jsp</p><p>&nbsp;</p><div>&nbsp; &nbsp;<strong>&nbsp;&nbsp;1.重定向：</strong></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1).response.sendRedirect(url);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2).response.setState(302);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;response.setHeader(\"location\",url);</div><div><strong>&nbsp; &nbsp; &nbsp;2.转发：</strong></div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1).request.getRequestDispatcher(url).forward(request,response);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2).request.getRequestDispatcher(url).include(request,response);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 3).&lt;jsp:forward page=url /&gt;</div>', null, '1', '8', '18', '17', '0', '0', '2017-10-07 16:03:08', '2017-10-07 16:03:08', '1', '1', '1');
INSERT INTO `article` VALUES ('16', '1', 'Java中File类的使用', '<h2>一、File类常用API介绍</h2><p>内容见代码和注释</p><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">package</span>&nbsp;com.test;</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.io.File;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;java.io.IOException;</li><li class=\"alt\"></li><li class=\"\"><span class=\"comment\">/*</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*</span></li><li class=\"\"><span class=\"comment\">&nbsp;*&nbsp;@author wjw</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*</span></li><li class=\"\"><span class=\"comment\">&nbsp;*/</span></li><li class=\"alt\"></li><li class=\"\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;Test&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">static</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//1.创建一个文件夹对象</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;file&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;File(<span class=\"string\">\"F:\\\\桌面\\\\music\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//判断文件是否存在</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(file.exists());<span class=\"comment\">//true</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//如果文件夹不存在创建之,否则删除之</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">if</span>(!file.exists())</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file.mkdir();<span class=\"comment\">//创建文件夹</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//else&nbsp;</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//file.delete();</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//是否是一个目录</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(file.isDirectory());<span class=\"comment\">//true</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//是否是一个文件</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(file.isFile());<span class=\"comment\">//false</span></li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//2.创建一个文件对象</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File&nbsp;file2&nbsp;=&nbsp;<span class=\"keyword\">new</span>&nbsp;File(<span class=\"string\">\"F:\\\\桌面\\\\music\\\\1.mp3\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(file.exists());</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//如果文件不存在创建之，否则删除&nbsp;&nbsp;&nbsp;之</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">if</span>(file2.exists())</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">try</span>&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file2.createNewFile();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class=\"keyword\">catch</span>&nbsp;(IOException&nbsp;e)&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//else&nbsp;</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//file2.delete();</span></li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//3.常用的File对象API</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(file);<span class=\"comment\">//file.toString()的内容，F:\\桌面\\music</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(file.getAbsolutePath());<span class=\"comment\">//file的绝对路径F:\\桌面\\music</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(file.getName());<span class=\"comment\">//music</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(file2.getName());<span class=\"comment\">//1.mp3</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(file.getParent());<span class=\"comment\">//F:\\桌面</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">}</li></ol></div><p>&nbsp;</p><h2>二、遍历目录</h2><div class=\"dp-highlighter\"><div class=\"bar\"></div><ol class=\"dp-j\" start=\"1\"><li class=\"alt\"><span class=\"keyword\">package</span>&nbsp;com.test;</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">import</span>&nbsp;java.io.File;</li><li class=\"\"><span class=\"keyword\">import</span>&nbsp;java.io.IOException;</li><li class=\"alt\"></li><li class=\"\"><span class=\"comment\">/*</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*</span></li><li class=\"\"><span class=\"comment\">&nbsp;*&nbsp;@author wjw</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;*</span></li><li class=\"\"><span class=\"comment\">&nbsp;*/</span></li><li class=\"alt\"></li><li class=\"\"><span class=\"comment\">//列出File类一些常用操作比如过滤、遍历等操作</span></li><li class=\"alt\"><span class=\"keyword\">class</span>&nbsp;FileUtils&nbsp;{</li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//列出指定目录下(包括子目录)的所有文件</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">static</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;listDirectory(File&nbsp;dir)&nbsp;<span class=\"keyword\">throws</span>&nbsp;IOException{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">if</span>(!dir.exists())&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">throw</span>&nbsp;<span class=\"keyword\">new</span>&nbsp;IllegalArgumentException(<span class=\"string\">\"目录\"</span>+dir+<span class=\"string\">\"不存在\"</span>);</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">if</span>(!dir.isDirectory())&nbsp;{&nbsp;<span class=\"comment\">//判断File类的对象是否为文件夹</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">throw</span>&nbsp;<span class=\"keyword\">new</span>&nbsp;IllegalArgumentException(dir+<span class=\"string\">\"不是目录\"</span>);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span>/*</span></li><li class=\"\"><span class=\"comment\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1.输出dir目录下的一级文件夹和文件</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;[]&nbsp;filenames&nbsp;=&nbsp;dir.list();//返回的是字符串数组&nbsp;直接子名称</span></li><li class=\"\"><span class=\"comment\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(String&nbsp;string&nbsp;:&nbsp;filenames)&nbsp;{</span></li><li class=\"alt\"><span class=\"comment\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(dir+\"\\\\\"+string);//dirstring是文件或文件夹名</span></li><li class=\"\"><span class=\"comment\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></li><li class=\"alt\"><span class=\"comment\">&nbsp; &nbsp; &nbsp; &nbsp; */</span></li><li class=\"\"></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//2.如果要遍历子目录下的目录及所有文件，就需要构造File对象做递归操作</span></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;File[]&nbsp;files&nbsp;=&nbsp;dir.listFiles();<span class=\"comment\">//返回的是直接子目录(文件)的抽象</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">if</span>(files!=<span class=\"keyword\">null</span>&amp;&amp;files.length&gt;<span class=\"number\">0</span>)&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">for</span>(File&nbsp;file:files)&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">if</span>(file.isDirectory())&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"comment\">//递归</span></li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;listDirectory(file);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class=\"keyword\">else</span>&nbsp;{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(file);</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\"></li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">}</li><li class=\"\"></li><li class=\"alt\"><span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">class</span>&nbsp;Test1&nbsp;{</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"keyword\">public</span>&nbsp;<span class=\"keyword\">static</span>&nbsp;<span class=\"keyword\">void</span>&nbsp;main(String[]&nbsp;args)&nbsp;<span class=\"keyword\">throws</span>&nbsp;IOException{</li><li class=\"alt\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileUtils.listDirectory(<span class=\"keyword\">new</span>&nbsp;File(\"C:\\\\Users\\\\filetest\"));</li><li class=\"\">&nbsp;&nbsp;&nbsp;&nbsp;}</li><li class=\"alt\">}</li></ol></div>', null, '1', '2', '1,17', '23', '0', '0', '2017-10-07 16:04:25', '2018-01-24 23:14:55', '1', '1', '1');
INSERT INTO `article` VALUES ('17', '1', 'java中ImageIcon路径问题', '<h2><strong>一、问题</strong></h2><p>ImageIcon icon = new ImageIcon(\"logo.jpg\");</p><p>执行结果是icon无法显示</p><p>&nbsp;</p><h2><strong>二、解决</strong></h2><p>类中有如下调用：</p><p><span>ImageIcon icon = new ImageIcon(\"1.jpg\");</span></p><p>&nbsp;</p><p>很自然地认为当前类文件和图片在同一路径下即可。</p><p><span><strong>其实所谓的相对路径起点是工程的根目录，即project。</strong></span></p><p>这行代码执行时在project目录下查找名为a.gif的文件，结果当然是找不到。</p><p>要得到工程的相对路径可通过System.getProperty(\"user.dir\")得到。</p><p>对图片和对文件的查找应该是一致的，如new File()。</p><p>&nbsp;</p><p>1、假如你的工程根目录为：Project1</p><p>你的图片文件放在：Project1/src/images/1.jpg</p><p>所以正确的调用是（不要加Project1）：</p><p>ImageIcon icon = new ImageIcon(\"src/images/1.jpg\");</p><p>&nbsp;</p><p>2、假如你的工程根目录为：Project1</p><p>你的图片文件在：Project1/src/com.test/1.jpg</p><p>所以正确的调用是(<strong>com.test</strong>是包名)</p><p>ImageIcon icon = new ImageIcon(\"src/com/test/1.jpg\");</p><p>这行代码执行时在project/test目录下查找到了文件</p><p>&nbsp;</p><p><strong>总结起来就是一句话：所谓相对路径就是相对于工程根目录的位置^_^</strong></p><p>&nbsp;</p><h2>三、其他</h2><p>查看了一下ImageIcon的构造函数。</p><p>Public ImageIcon(String filename)//参数可以是绝对路径也可以是相对路径</p><p>Public ImageIcon(URL url)</p><p>&nbsp;</p><p>第一种构造不在赘述。</p><p>第二种通过URL来得到图片</p><p>URL url = getClass().getResource(\"a.gif\"); //当前编译后class文件所在目录查找</p><p>ImageIcon icon = new ImageIcon(url);</p><p>&nbsp;</p><p>ImageIcon支持GIF、JPG、PNG等格式。</p>', null, '1', '2', '1', '35', '0', '0', '2017-10-07 16:05:55', '2018-01-24 23:13:31', '1', '1', '1');
INSERT INTO `article` VALUES ('33', '1', '页面代码高亮显示插件--syntaxhighlighter', '<p>1、去syntaxhighlighter官网下载插件<a href=\"http://alexgorbatchev.com/syntaxhighlighter/\" target=_blank>http://alexgorbatchev.com/syntaxhighlighter/</a></p>\r\n<p>2、在要显示代码高亮的页面引入如下代码：</p>\r\n<div><pre class=brush:html> <!-- 代码高亮start-->\r\n    <script type=text/javascript src=\"${app_path}/scripts/shcore.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushbash.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushcpp.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushcsharp.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushcss.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushdelphi.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushdiff.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushgroovy.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushjava.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushjscript.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushphp.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushplain.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushpython.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushruby.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushscala.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushsql.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushvb.js\"></script>\r\n    <script type=text/javascript src=\"${app_path}/scripts/shbrushxml.js\"></script>\r\n    <link rel=stylesheet type=text/css href=\"${app_path}/styles/shcore.css\">\r\n    <link rel=stylesheet type=text/css href=\"${app_path}/styles/shthemedefault.css\">\r\n    <script type=text/javascript>\r\n        SyntaxHighlighter.config.clipboardSwf = \'${APP_PATH}/scripts/clipboard.swf\';\r\n        SyntaxHighlighter.config.strings = {\r\n            expandSource : \'展开代码\',\r\n            viewSource : \'查看代码\',\r\n            copyToClipboard : \'复制代码\',\r\n            copyToClipboardConfirmation : \'代码复制成功\',\r\n            print : \'打印\',\r\n            help: \'?\',\r\n            alert: \'语法高亮\\n\\n\',\r\n            noBrush: \'不能找到刷子: \',\r\n            brushNotHtmlScript: \'刷子没有配置html-script选项\',\r\n            aboutDialog: \'<div></div>\'\r\n        };\r\n        SyntaxHighlighter.all();\r\n    </script>\r\n    <!--代码高亮end-->\r\n</pre></div>', null, '1', '8', '20', '15', '0', '0', '2018-01-27 22:25:55', '2018-01-30 00:19:01', '1', '1', '1');
INSERT INTO `article` VALUES ('34', '1', 'SSM博客实战(1)–正则表达式去除html标签', '<h2 id=\"h2-ssm-html-\"><a name=\"SSM博客实战（一）–正则表达式去除html标签\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>SSM博客实战（一）–正则表达式去除html标签</h2><ul>\r\n<li><p>大部分博客网站的首页文章的内容都是截取了文章的一部分，然后点击“查看更多”才能看完整的文字。所以，截取字符串是必不可少的。</p>\r\n</li><li><p>但是如果我们直接用 substring 截取，会出现很多问题。比如样式不会改变，加粗的，文字颜色都不会去掉。还有就是一个 html标签如&lt;strong&gt;&lt;/strong&gt;可能会被截成两段，导致后面的文字全部加粗之类的。这种情况绝不允许。</p>\r\n</li><li>就像下图中截取不当使得文字上出现颜色</li></ul>\r\n<p><img src=\"https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-2-1-MapleBlog_one/1.png\" alt=\"\"></p>\r\n<blockquote>\r\n<p>除去HTML标签的实现</p>\r\n</blockquote>\r\n<h3 id=\"h3-java-\"><a name=\"java的实现：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>java的实现：</h3><pre><code>import java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\npublic class Demo {\r\n    private static final String regEx_script = &quot;&lt;script[^&gt;]*?&gt;[\\\\s\\\\S]*?&lt;\\\\/script&gt;&quot;; // 定义script的正则表达式\r\n    private static final String regEx_style = &quot;&lt;style[^&gt;]*?&gt;[\\\\s\\\\S]*?&lt;\\\\/style&gt;&quot;; // 定义style的正则表达式\r\n    private static final String regEx_html = &quot;&lt;[^&gt;]+&gt;&quot;; // 定义HTML标签的正则表达式\r\n    private static final String regEx_space = &quot;\\\\s*|\\t|\\r|\\n&quot;;//定义空格回车换行符\r\n    /**\r\n     * @param htmlStr\r\n     * @return\r\n     *  删除Html标签\r\n     */\r\n    public static String delHTMLTag(String htmlStr) {\r\n        Pattern p_script = Pattern.compile(regEx_script, Pattern.CASE_INSENSITIVE);\r\n        Matcher m_script = p_script.matcher(htmlStr);\r\n        htmlStr = m_script.replaceAll(&quot;&quot;); // 过滤script标签\r\n        Pattern p_style = Pattern.compile(regEx_style, Pattern.CASE_INSENSITIVE);\r\n        Matcher m_style = p_style.matcher(htmlStr);\r\n        htmlStr = m_style.replaceAll(&quot;&quot;); // 过滤style标签\r\n        Pattern p_html = Pattern.compile(regEx_html, Pattern.CASE_INSENSITIVE);\r\n        Matcher m_html = p_html.matcher(htmlStr);\r\n        htmlStr = m_html.replaceAll(&quot;&quot;); // 过滤html标签\r\n        Pattern p_space = Pattern.compile(regEx_space, Pattern.CASE_INSENSITIVE);\r\n        Matcher m_space = p_space.matcher(htmlStr);\r\n        htmlStr = m_space.replaceAll(&quot;&quot;); // 过滤空格回车标签\r\n        return htmlStr.trim(); // 返回文本字符串\r\n    }\r\n    public static String getTextFromHtml(String htmlStr){\r\n        htmlStr = delHTMLTag(htmlStr);\r\n        htmlStr = htmlStr.replaceAll(&quot; &quot;, &quot;&quot;);\r\n        htmlStr = htmlStr.substring(0,100);\r\n        return htmlStr;\r\n    }\r\n    public static void main(String[] args) {\r\n        String str = &quot;ubuntu 安装 phpmyadmin  两种 （两者选一）:\\n&quot; +\r\n            &quot;&lt;h4&gt;1: apt-get 安装  然后使用 已有的虚拟主机目录建立软连接&lt;/h4&gt;\\n&quot; +\r\n            &quot;&lt;div class=\\&quot;dp-highlighter\\&quot;&gt;\\n&quot; +\r\n            &quot;&lt;ol class=\\&quot;dp-xml\\&quot; start=\\&quot;1\\&quot;&gt;\\n&quot; +\r\n            &quot; \\t&lt;li class=\\&quot;alt\\&quot;&gt;sudo  apt-get install  phpmyadmin&lt;/li&gt;\\n&quot; +\r\n            &quot; \\t&lt;li class=\\&quot;\\&quot;&gt;sudo  ln-s /usr/share/phpmyadmin/      /var/www/pma&lt;/li&gt;\\n&quot; +\r\n            &quot;&lt;/ol&gt;\\n&quot; +\r\n            &quot;&lt;/div&gt;\\n&quot; +\r\n            &quot;&lt;h4&gt;2:手动上传&lt;/h4&gt;\\n&quot; +\r\n            &quot;网上下载 phpmyadmin软件包,使用 filezilla 上传到 /var/www/pma (pma自己创建)\\n&quot; +\r\n            &quot;\\n&quot; +\r\n            &quot;使用 ip/pma 查看 phpmyadmin\\n&quot; +\r\n            &quot;\\n&quot; +\r\n            &quot;其实 还可以 考虑给phpmyadmin 配置虚拟主机\\n&quot; ;\r\n         System.out.println(getTextFromHtml(str));\r\n    }\r\n}\r\n</code></pre><h3 id=\"h3-jsp-\"><a name=\"JSP 实现\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>JSP 实现</h3><p>这里我们需要 <strong>自定义标签</strong></p>\r\n<h4 id=\"h4-1-web-inf-mytag-dtd-\"><a name=\"1、在WEB-INF 下新建一个 myTag.dtd 文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、在WEB-INF 下新建一个 myTag.dtd 文件</h4><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\r\n    &lt;!DOCTYPE taglib\r\n            PUBLIC &quot;-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN&quot;\r\n            &quot;http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd&quot;&gt;\r\n    &lt;taglib&gt;\r\n        &lt;tlib-version&gt;1.0&lt;/tlib-version&gt;&lt;!-- 代表标签库的版本号 --&gt;\r\n        &lt;jsp-version&gt;1.2&lt;/jsp-version&gt;&lt;!-- 代表jsp的版本 --&gt;\r\n        &lt;short-name&gt;SimpleTag&lt;/short-name&gt;&lt;!-- 你的标签库的简称 --&gt;\r\n       &lt;!-- &lt;uri&gt;http://wjwcloud.com&lt;/uri&gt;--&gt;&lt;!-- 你标签库的引用uri --&gt;\r\n        &lt;tag&gt;\r\n            &lt;name&gt;htmlFilter&lt;/name&gt;\r\n            &lt;tag-class&gt;com.wujiawei.blog.util.others.HtmlFilterTag&lt;/tag-class&gt;\r\n            &lt;body-content&gt;scriptless&lt;/body-content&gt;\r\n        &lt;/tag&gt;\r\n    &lt;/taglib&gt;\r\n</code></pre><p>注意：</p>\r\n<p><code>&lt;short-name&gt;</code>  和  <code>&lt;uri&gt;</code>  可以随便填</p>\r\n<p><code>&lt;tag&gt;</code> 标签内的 <code>&lt;name&gt;</code>  和下面的类名一致， <code>&lt;tag-class&gt;</code> 是类的地址， <code>&lt;body-content&gt;</code>  这里就填 scriptless好了，意思是标签体内可以放文本，jsp标签和其他任意标签</p>\r\n<h4 id=\"h4-2-htmlfiltertag-java\"><a name=\"2、在对应位置新建 HtmlFilterTag.java\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、在对应位置新建 HtmlFilterTag.java</h4><pre><code>    package com.wujiawei.blog.util.others;\r\n    /**\r\n     * Created by wjw \r\n     */\r\n        import java.io.IOException;\r\n        import java.io.StringWriter;\r\n        import java.util.regex.Matcher;\r\n        import java.util.regex.Pattern;\r\n        import javax.servlet.jsp.JspException;\r\n        import javax.servlet.jsp.PageContext;\r\n        import javax.servlet.jsp.tagext.JspFragment;\r\n        import javax.servlet.jsp.tagext.SimpleTagSupport;\r\n    public class HtmlFilterTag extends SimpleTagSupport {\r\n        private static final int subLength = 200; //截取字符串长度\r\n        private static final String regEx_script = &quot;&lt;script[^&gt;]*?&gt;[\\\\s\\\\S]*?&lt;\\\\/script&gt;&quot;; // 定义script的正则表达式\r\n        private static final String regEx_style = &quot;&lt;style[^&gt;]*?&gt;[\\\\s\\\\S]*?&lt;\\\\/style&gt;&quot;; // 定义style的正则表达式\r\n        private static final String regEx_html = &quot;&lt;[^&gt;]+&gt;&quot;; // 定义HTML标签的正则表达式\r\n        private static final String regEx_space = &quot;\\\\s*|\\t|\\r|\\n&quot;;//定义空格回车换行符\r\n        public static String filter(String htmlStr) {\r\n            Pattern p_script = Pattern.compile(regEx_script, Pattern.CASE_INSENSITIVE);\r\n            Matcher m_script = p_script.matcher(htmlStr);\r\n            htmlStr = m_script.replaceAll(&quot;&quot;); // 过滤script标签\r\n            Pattern p_style = Pattern.compile(regEx_style, Pattern.CASE_INSENSITIVE);\r\n            Matcher m_style = p_style.matcher(htmlStr);\r\n            htmlStr = m_style.replaceAll(&quot;&quot;); // 过滤style标签\r\n            Pattern p_html = Pattern.compile(regEx_html, Pattern.CASE_INSENSITIVE);\r\n            Matcher m_html = p_html.matcher(htmlStr);\r\n            htmlStr = m_html.replaceAll(&quot;&quot;); // 过滤html标签\r\n            Pattern p_space = Pattern.compile(regEx_space, Pattern.CASE_INSENSITIVE);\r\n            Matcher m_space = p_space.matcher(htmlStr);\r\n            htmlStr = m_space.replaceAll(&quot;&quot;); // 过滤空格回车标签\r\n            return htmlStr.trim(); // 返回文本字符串\r\n        }\r\n        @Override\r\n        public void doTag() throws JspException, IOException {\r\n            StringWriter sw = new StringWriter();\r\n            JspFragment jf = this.getJspBody();\r\n            jf.invoke(sw);\r\n            String content = sw.getBuffer().toString();\r\n            content = filter(content);\r\n            content = content.replaceAll(&quot; &quot;, &quot;&quot;);\r\n            int contentLength =content.length();\r\n            if(contentLength&gt;subLength) {\r\n                content = content.substring(0,subLength);\r\n            } else {\r\n                content = content.substring(0,contentLength);\r\n            }\r\n            ((PageContext) this.getJspContext()).getOut().write(content);\r\n        }\r\n    }\r\n</code></pre><p>注意：</p>\r\n<p>大家也可以按照自己的需求，修改上面的代码</p>\r\n<h4 id=\"h4-3-jsp-jsp-\"><a name=\"3、在 jsp 里调用，以下是部分 jsp 代码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3、在 jsp 里调用，以下是部分 jsp 代码</h4><pre><code>    &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;\r\n             pageEncoding=&quot;UTF-8&quot;%&gt;\r\n    &lt;%@ taglib uri=&quot;/WEB-INF/myTag.dtd&quot; prefix=&quot;wjw&quot;%&gt;  \r\n    &lt;!DOCTYPE html&gt;\r\n    &lt;html lang=&quot;zh-CN&quot;&gt;\r\n    &lt;head&gt;\r\n        &lt;meta charset=&quot;utf-8&quot;&gt;\r\n    &lt;/head&gt;\r\n    &lt;body&gt;\r\n           &lt;wjw:htmlFilter&gt;  ${article.content} &lt;/wjw:htmlFilter&gt;  \r\n    &lt;/body&gt;\r\n    &lt;/html&gt;\r\n</code></pre><p>注意：</p>\r\n<p>一定要引入 dtd 文件，注意你的路径，prefix 填你的标签前缀，比如我填的是 wjw，下面调用的话，前缀保持正确即可</p>\r\n<p>4、最终效果如下</p>\r\n<p><img src=\"https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-2-1-MapleBlog_one/2.png\" alt=\"\"></p>\r\n<h2 id=\"h2-star\"><a name=\"Star\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Star</h2><p>如果觉得这篇教程还有点用，请点播关注，给我的<a href=\"https://github.com/wjw0315/wjw0315.github.io\">github仓库</a> 点个 <strong>star</strong> 吧，谢谢！</p>\r\n<p><img src=\"https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/star.png\" alt=\"\"></p>\r\n<p>点上面 <strong>↑</strong> 那个星星</p>', '## SSM博客实战（一）–正则表达式去除html标签\r\n\r\n\r\n- 大部分博客网站的首页文章的内容都是截取了文章的一部分，然后点击“查看更多”才能看完整的文字。所以，截取字符串是必不可少的。\r\n\r\n- 但是如果我们直接用 substring 截取，会出现很多问题。比如样式不会改变，加粗的，文字颜色都不会去掉。还有就是一个 html标签如<strong></strong>可能会被截成两段，导致后面的文字全部加粗之类的。这种情况绝不允许。\r\n- 就像下图中截取不当使得文字上出现颜色\r\n \r\n![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-2-1-MapleBlog_one/1.png)\r\n\r\n> 除去HTML标签的实现\r\n\r\n### java的实现：\r\n\r\n```\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\npublic class Demo {\r\n    private static final String regEx_script = \"<script[^>]*?>[\\\\s\\\\S]*?<\\\\/script>\"; // 定义script的正则表达式\r\n    private static final String regEx_style = \"<style[^>]*?>[\\\\s\\\\S]*?<\\\\/style>\"; // 定义style的正则表达式\r\n    private static final String regEx_html = \"<[^>]+>\"; // 定义HTML标签的正则表达式\r\n    private static final String regEx_space = \"\\\\s*|\\t|\\r|\\n\";//定义空格回车换行符\r\n    /**\r\n     * @param htmlStr\r\n     * @return\r\n     *  删除Html标签\r\n     */\r\n    public static String delHTMLTag(String htmlStr) {\r\n        Pattern p_script = Pattern.compile(regEx_script, Pattern.CASE_INSENSITIVE);\r\n        Matcher m_script = p_script.matcher(htmlStr);\r\n        htmlStr = m_script.replaceAll(\"\"); // 过滤script标签\r\n        Pattern p_style = Pattern.compile(regEx_style, Pattern.CASE_INSENSITIVE);\r\n        Matcher m_style = p_style.matcher(htmlStr);\r\n        htmlStr = m_style.replaceAll(\"\"); // 过滤style标签\r\n        Pattern p_html = Pattern.compile(regEx_html, Pattern.CASE_INSENSITIVE);\r\n        Matcher m_html = p_html.matcher(htmlStr);\r\n        htmlStr = m_html.replaceAll(\"\"); // 过滤html标签\r\n        Pattern p_space = Pattern.compile(regEx_space, Pattern.CASE_INSENSITIVE);\r\n        Matcher m_space = p_space.matcher(htmlStr);\r\n        htmlStr = m_space.replaceAll(\"\"); // 过滤空格回车标签\r\n        return htmlStr.trim(); // 返回文本字符串\r\n    }\r\n    public static String getTextFromHtml(String htmlStr){\r\n        htmlStr = delHTMLTag(htmlStr);\r\n        htmlStr = htmlStr.replaceAll(\" \", \"\");\r\n        htmlStr = htmlStr.substring(0,100);\r\n        return htmlStr;\r\n    }\r\n    public static void main(String[] args) {\r\n        String str = \"ubuntu 安装 phpmyadmin  两种 （两者选一）:\\n\" +\r\n            \"<h4>1: apt-get 安装  然后使用 已有的虚拟主机目录建立软连接</h4>\\n\" +\r\n            \"<div class=\\\"dp-highlighter\\\">\\n\" +\r\n            \"<ol class=\\\"dp-xml\\\" start=\\\"1\\\">\\n\" +\r\n            \" \\t<li class=\\\"alt\\\">sudo  apt-get install  phpmyadmin</li>\\n\" +\r\n            \" \\t<li class=\\\"\\\">sudo  ln-s /usr/share/phpmyadmin/      /var/www/pma</li>\\n\" +\r\n            \"</ol>\\n\" +\r\n            \"</div>\\n\" +\r\n            \"<h4>2:手动上传</h4>\\n\" +\r\n            \"网上下载 phpmyadmin软件包,使用 filezilla 上传到 /var/www/pma (pma自己创建)\\n\" +\r\n            \"\\n\" +\r\n            \"使用 ip/pma 查看 phpmyadmin\\n\" +\r\n            \"\\n\" +\r\n            \"其实 还可以 考虑给phpmyadmin 配置虚拟主机\\n\" ;\r\n         System.out.println(getTextFromHtml(str));\r\n    }\r\n}\r\n```\r\n\r\n### JSP 实现\r\n\r\n这里我们需要 **自定义标签**\r\n#### 1、在WEB-INF 下新建一个 myTag.dtd 文件\r\n```\r\n    <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n    <!DOCTYPE taglib\r\n            PUBLIC \"-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN\"\r\n            \"http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd\">\r\n    <taglib>\r\n        <tlib-version>1.0</tlib-version><!-- 代表标签库的版本号 -->\r\n        <jsp-version>1.2</jsp-version><!-- 代表jsp的版本 -->\r\n        <short-name>SimpleTag</short-name><!-- 你的标签库的简称 -->\r\n       <!-- <uri>http://wjwcloud.com</uri>--><!-- 你标签库的引用uri -->\r\n        <tag>\r\n            <name>htmlFilter</name>\r\n            <tag-class>com.wujiawei.blog.util.others.HtmlFilterTag</tag-class>\r\n            <body-content>scriptless</body-content>\r\n        </tag>\r\n    </taglib>\r\n```\r\n注意：\r\n\r\n`<short-name>`  和  `<uri>`  可以随便填\r\n\r\n`<tag>` 标签内的 `<name>`  和下面的类名一致， `<tag-class>` 是类的地址， `<body-content>`  这里就填 scriptless好了，意思是标签体内可以放文本，jsp标签和其他任意标签\r\n\r\n#### 2、在对应位置新建 HtmlFilterTag.java\r\n```\r\n    package com.wujiawei.blog.util.others;\r\n    /**\r\n     * Created by wjw \r\n     */\r\n        import java.io.IOException;\r\n        import java.io.StringWriter;\r\n        import java.util.regex.Matcher;\r\n        import java.util.regex.Pattern;\r\n        import javax.servlet.jsp.JspException;\r\n        import javax.servlet.jsp.PageContext;\r\n        import javax.servlet.jsp.tagext.JspFragment;\r\n        import javax.servlet.jsp.tagext.SimpleTagSupport;\r\n    public class HtmlFilterTag extends SimpleTagSupport {\r\n        private static final int subLength = 200; //截取字符串长度\r\n        private static final String regEx_script = \"<script[^>]*?>[\\\\s\\\\S]*?<\\\\/script>\"; // 定义script的正则表达式\r\n        private static final String regEx_style = \"<style[^>]*?>[\\\\s\\\\S]*?<\\\\/style>\"; // 定义style的正则表达式\r\n        private static final String regEx_html = \"<[^>]+>\"; // 定义HTML标签的正则表达式\r\n        private static final String regEx_space = \"\\\\s*|\\t|\\r|\\n\";//定义空格回车换行符\r\n        public static String filter(String htmlStr) {\r\n            Pattern p_script = Pattern.compile(regEx_script, Pattern.CASE_INSENSITIVE);\r\n            Matcher m_script = p_script.matcher(htmlStr);\r\n            htmlStr = m_script.replaceAll(\"\"); // 过滤script标签\r\n            Pattern p_style = Pattern.compile(regEx_style, Pattern.CASE_INSENSITIVE);\r\n            Matcher m_style = p_style.matcher(htmlStr);\r\n            htmlStr = m_style.replaceAll(\"\"); // 过滤style标签\r\n            Pattern p_html = Pattern.compile(regEx_html, Pattern.CASE_INSENSITIVE);\r\n            Matcher m_html = p_html.matcher(htmlStr);\r\n            htmlStr = m_html.replaceAll(\"\"); // 过滤html标签\r\n            Pattern p_space = Pattern.compile(regEx_space, Pattern.CASE_INSENSITIVE);\r\n            Matcher m_space = p_space.matcher(htmlStr);\r\n            htmlStr = m_space.replaceAll(\"\"); // 过滤空格回车标签\r\n            return htmlStr.trim(); // 返回文本字符串\r\n        }\r\n        @Override\r\n        public void doTag() throws JspException, IOException {\r\n            StringWriter sw = new StringWriter();\r\n            JspFragment jf = this.getJspBody();\r\n            jf.invoke(sw);\r\n            String content = sw.getBuffer().toString();\r\n            content = filter(content);\r\n            content = content.replaceAll(\" \", \"\");\r\n            int contentLength =content.length();\r\n            if(contentLength>subLength) {\r\n                content = content.substring(0,subLength);\r\n            } else {\r\n                content = content.substring(0,contentLength);\r\n            }\r\n            ((PageContext) this.getJspContext()).getOut().write(content);\r\n        }\r\n    }\r\n```\r\n注意：\r\n\r\n大家也可以按照自己的需求，修改上面的代码\r\n\r\n#### 3、在 jsp 里调用，以下是部分 jsp 代码\r\n```\r\n    <%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\r\n             pageEncoding=\"UTF-8\"%>\r\n    <%@ taglib uri=\"/WEB-INF/myTag.dtd\" prefix=\"wjw\"%>  \r\n    <!DOCTYPE html>\r\n    <html lang=\"zh-CN\">\r\n    <head>\r\n        <meta charset=\"utf-8\">\r\n    </head>\r\n    <body>\r\n           <wjw:htmlFilter>  ${article.content} </wjw:htmlFilter>  \r\n    </body>\r\n    </html>\r\n```\r\n注意：\r\n\r\n一定要引入 dtd 文件，注意你的路径，prefix 填你的标签前缀，比如我填的是 wjw，下面调用的话，前缀保持正确即可\r\n\r\n4、最终效果如下\r\n\r\n![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-2-1-MapleBlog_one/2.png)\r\n\r\n## Star\r\n如果觉得这篇教程还有点用，请点播关注，给我的[github仓库](https://github.com/wjw0315/wjw0315.github.io) 点个 **star** 吧，谢谢！\r\n\r\n![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/star.png)\r\n\r\n点上面 **↑** 那个星星', '1', '19', '1,11,12,13,18,20', '24', '0', '0', '2018-01-30 01:12:22', '2018-02-05 09:45:42', '1', '1', '1');
INSERT INTO `article` VALUES ('36', '1', 'git配置（Windows+Linux）', '<h2 id=\"h2-git-\"><a name=\"Git的基础配置：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Git的基础配置：</h2><p>1、配置用户名（提交时会进行引用）</p>\r\n<blockquote>\r\n<p>Git config —global user.name “wjw0215”</p>\r\n</blockquote>\r\n<p>2、配置邮箱（提交时会引用）：</p>\r\n<blockquote>\r\n<p>Git config —global user.email “<a href=\"mailto:821060818@qq.com\">821060818@qq.com</a>”</p>\r\n</blockquote>\r\n<p>3、其他配置：</p>\r\n<blockquote>\r\n<p>git config —global merge.tool “kdiff3”</p>\r\n<h1 id=\"h1--kdiff3-\"><a name=\"如果没有装kdiff3就不需要设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如果没有装kdiff3就不需要设置</h1><p>Git config —global core.autocrlf false</p>\r\n<h1 id=\"h1--git-windows-unix-\"><a name=\"让Git不要管Windows/unix 换行符转换的事。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>让Git不要管Windows/unix 换行符转换的事。</h1></blockquote>\r\n<p>4、编码配置：</p>\r\n<blockquote>\r\n<p>Git config —global gui.encoding utf-8</p>\r\n<p>git config —global core.quotepath off</p>\r\n<h1 id=\"h1--git-status-\"><a name=\"避免Git status显示的中文文件名乱码\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>避免Git status显示的中文文件名乱码</h1></blockquote>\r\n<p>5、Windows上还需要的配置：</p>\r\n<blockquote>\r\n<p>Git config —global core.ignorecase false</p>\r\n</blockquote>\r\n<h2 id=\"h2-git-ssh-key-pair-\"><a name=\"git ssh key pair 配置：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>git ssh key pair 配置：</h2><p>1、在Linux的命令行下，或者Windows上的Git bash 命令行窗口中键入：</p>\r\n<blockquote>\r\n<p>ssh-keygen -t rsa -C “<a href=\"mailto:821060818@qq.com\">821060818@qq.com</a>”<br>2、然后一路回车，不要输入任何的密码之类的，生成ssh key pair</p>\r\n</blockquote>\r\n<p>3、</p>\r\n<blockquote>\r\n<p>ssh-add ~/.ssh/id_rsa<br>4、<br>cat ~/.ssh/id_rsa.pub<br>将生成出来的文件全部的复制出来，</p>\r\n</blockquote>\r\n<p>【注】执行ssh-add时出现Could not open a connection to your authentication agent ，如果有报错就先执行eval <code>ssh-agent</code>(此处不是单引号，是~键上的那个`)，之后再执行ssh-add ~/.ssh/id_rsa成功后执行ssh-add –l 就会有新加的rsa了</p>\r\n<h2 id=\"h2-git-\"><a name=\"Git的验证：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Git的验证：</h2><blockquote>\r\n<p>Git —version 出现版本信息就是安装成功。</p>\r\n</blockquote>\r\n<p>Git的常用命令：</p>\r\n<p> 切换分支：git checkout 分支名<br> 拉取：git pull<br> 提交：git push</p>', '## Git的基础配置：\r\n\r\n1、配置用户名（提交时会进行引用）\r\n>Git config --global user.name \"wjw0215\"\r\n\r\n2、配置邮箱（提交时会引用）：\r\n>Git config --global user.email \"821060818@qq.com\"\r\n\r\n3、其他配置：\r\n>git config --global merge.tool \"kdiff3\"\r\n#如果没有装kdiff3就不需要设置\r\n\r\n>Git config --global core.autocrlf false\r\n#让Git不要管Windows/unix 换行符转换的事。\r\n\r\n \r\n4、编码配置：\r\n>Git config --global gui.encoding utf-8\r\n\r\n>git config --global core.quotepath off\r\n#避免Git status显示的中文文件名乱码\r\n\r\n5、Windows上还需要的配置：\r\n>Git config --global core.ignorecase false\r\n \r\n\r\n## git ssh key pair 配置：\r\n\r\n1、在Linux的命令行下，或者Windows上的Git bash 命令行窗口中键入：\r\n>ssh-keygen -t rsa -C \"821060818@qq.com\"\r\n2、然后一路回车，不要输入任何的密码之类的，生成ssh key pair\r\n\r\n3、\r\n>ssh-add ~/.ssh/id_rsa\r\n4、\r\n>cat ~/.ssh/id_rsa.pub\r\n将生成出来的文件全部的复制出来，\r\n\r\n【注】执行ssh-add时出现Could not open a connection to your authentication agent ，如果有报错就先执行eval `ssh-agent`(此处不是单引号，是~键上的那个`)，之后再执行ssh-add ~/.ssh/id_rsa成功后执行ssh-add –l 就会有新加的rsa了\r\n\r\n \r\n\r\n## Git的验证：\r\n\r\n>Git --version 出现版本信息就是安装成功。\r\n\r\nGit的常用命令：\r\n\r\n 切换分支：git checkout 分支名\r\n 拉取：git pull\r\n 提交：git push', '15', '20', '23', '7', '0', '0', '2018-02-05 09:48:42', '2018-02-05 09:50:19', '1', '1', '1');
INSERT INTO `article` VALUES ('37', '1', 'Markdown编写博文教程', '<blockquote>\r\n<p>下面是基本markdown编写博文的教程  </p>\r\n<ul>\r\n<li>首先Markdown 是一套标记语法，这些标记字符就是用来赋予文字不同格式；其次，能将标记字符转换，最终呈现出我们想要的排版效果。</li></ul>\r\n</blockquote>\r\n<h2 id=\"h2-u6587u7AE0u7684u683Cu5F0F\"><a name=\"文章的格式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>文章的格式</h2><p>每一篇文章文件命名采用的是<code>2017-02-04-Hello_edit.md</code>时间+标题的形式，空格用<code>-</code>替换连接。</p>\r\n<p>文件的格式是 <code>.md</code> 的 <a href=\"http://sspai.com/25137/\">MarkDown</a> 文件。</p>\r\n<p>我的jykell搭建的博客文章格式采用是 <strong>MarkDown</strong>+ <strong>YAML</strong> 的方式。<a href=\"http://www.ruanyifeng.com/blog/2016/07/yaml.html?f=tt\">YAML</a> 就是我们配置 <code>_config</code>文件用的语言。</p>\r\n<p><a href=\"http://sspai.com/25137/\">MarkDown</a>  是一种轻量级的「标记语言」，很简单。花半个小时看一下就能熟练使用了</p>\r\n<h2 id=\"h2-markdown-\"><a name=\"markdown基本语法格式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>markdown基本语法格式</h2><h3 id=\"h3-u6807u9898\"><a name=\"标题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>标题</h3><p>这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。</p>\r\n<p>而在 Markdown 中，你只需要在文本前面加上 <strong>#</strong> 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 <strong>#</strong> 即可，标题字号相应降低。</p>\r\n<blockquote>\r\n<p>注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。</p>\r\n</blockquote>\r\n<p>你可以你的编辑器中尝试输入这六级标题，可以参考下方的截图：</p>\r\n<p><img src=\"https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-1-31-markdown_edit/1.png\" alt=\"\"></p>\r\n<h3 id=\"h3-u5217u8868\"><a name=\"列表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>列表</h3><p>列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 <strong>-</strong> 就可以了。&lt;br&gt;<br>如果你希望有序列表，<br>也可以在文字前面加上 <code>1. 2. 3.</code> 就可以了，</p>\r\n<blockquote>\r\n<p>注：<code>-、1.</code> 和文本之间要保留一个字符的空格。</p>\r\n</blockquote>\r\n<p>列表案例截图如下：<br><img src=\"https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-1-31-markdown_edit/2.png\" alt=\"\"></p>\r\n<h3 id=\"h3-u94FEu63A5u548Cu56FEu7247\"><a name=\"链接和图片\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>链接和图片</h3><p>在 Markdown 中，插入链接不需要其他按钮，你只需要使用 <code>[显示文本](链接地址)</code> 这样的语法即可，例如：&lt;br&gt;<br><code>[简书](http://www.jianshu.com)</code></p>\r\n<p>在 Markdown 中，插入图片不需要其他按钮，你只需要使用 <code>[图片上传失败...(image-5fdc5-1510890177031)]</code> 这样的语法即可，例如：</p>\r\n<p><code>![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-1-31-markdown_edit/1.png)</code></p>\r\n<h3 id=\"h3-u5F15u7528\"><a name=\"引用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>引用</h3><p>在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 <code>&gt;</code> 就好了，例如：</p>\r\n<p><code>&gt; 一盏灯， 一片昏黄</code></p>\r\n<p>显示结果为：</p>\r\n<blockquote>\r\n<p>一盏灯， 一片昏黄</p>\r\n</blockquote>\r\n<h3 id=\"h3-u659Cu4F53u548Cu7C97u4F53\"><a name=\"斜体和粗体\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>斜体和粗体</h3><p>Markdown 的粗体和斜体也非常简单，用两个 <code>*</code> 包含一段文本就是粗体的语法，用一个 <code>*</code> 包含一段文本就是斜体的语法。例如：</p>\r\n<p><code>*一盏灯*， **一片昏黄**</code></p>\r\n<p>显示结果为</p>\r\n<p><em>一盏灯</em>， <strong>一片昏黄</strong></p>\r\n<h3 id=\"h3-u4EE3u7801u5F15u7528\"><a name=\"代码引用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>代码引用</h3><p>需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。<br>如果引用的语句为多行，可以将```置于这段代码的首行和末行。<br>代码引用的案例截图：</p>\r\n<p><img src=\"https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-1-31-markdown_edit/3.png\" alt=\"\"></p>\r\n<h3 id=\"h3-u8868u683C\"><a name=\"表格\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>表格</h3><p>相关代码：</p>\r\n<pre><code>|Tables        | Are           | Cool  |\r\n| ------------- |:-------------:| -----:|\r\n| col 3 is      | right-aligned | $1600 |\r\n| col 2 is      | centered      |   $12 |\r\n| zebra stripes | are neat      |    $1 |\r\n</code></pre><p>显示结果为</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>Tables</th>\r\n<th style=\"text-align:center\">Are</th>\r\n<th style=\"text-align:right\">Cool</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>col 3 is</td>\r\n<td style=\"text-align:center\">right-aligned</td>\r\n<td style=\"text-align:right\">$1600</td>\r\n</tr>\r\n<tr>\r\n<td>col 2 is</td>\r\n<td style=\"text-align:center\">centered</td>\r\n<td style=\"text-align:right\">$12</td>\r\n</tr>\r\n<tr>\r\n<td>zebra stripes</td>\r\n<td style=\"text-align:center\">are neat</td>\r\n<td style=\"text-align:right\">$1</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>相关代码：</p>\r\n<pre><code>dog | bird | cat\r\n----|------|----\r\nfoo | foo  | foo\r\nbar | bar  | bar\r\nbaz | baz  | baz\r\n</code></pre><p>显示结果：</p>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>dog</th>\r\n<th>bird</th>\r\n<th>cat</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>foo</td>\r\n<td>foo</td>\r\n<td>foo</td>\r\n</tr>\r\n<tr>\r\n<td>bar</td>\r\n<td>bar</td>\r\n<td>bar</td>\r\n</tr>\r\n<tr>\r\n<td>baz</td>\r\n<td>baz</td>\r\n<td>baz</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"h2-star\"><a name=\"Star\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Star</h2><p>如果觉得这篇教程还有点用，请点播关注，或者给我的<a href=\"https://github.com/wjw0315/wjw0315.github.io\">github仓库</a> 点个 <strong>star</strong> 吧！</p>\r\n<p><img src=\"https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/star.png\" alt=\"\"></p>\r\n<p>点上面 <strong>↑</strong> 那个星星</p>', '>下面是基本markdown编写博文的教程  \r\n- 首先Markdown 是一套标记语法，这些标记字符就是用来赋予文字不同格式；其次，能将标记字符转换，最终呈现出我们想要的排版效果。\r\n\r\n## 文章的格式\r\n\r\n每一篇文章文件命名采用的是`2017-02-04-Hello_edit.md`时间+标题的形式，空格用`-`替换连接。\r\n\r\n文件的格式是 `.md` 的 [MarkDown](http://sspai.com/25137/) 文件。\r\n\r\n我的jykell搭建的博客文章格式采用是 **MarkDown**+ **YAML** 的方式。[YAML](http://www.ruanyifeng.com/blog/2016/07/yaml.html?f=tt) 就是我们配置 `_config`文件用的语言。\r\n\r\n[MarkDown](http://sspai.com/25137/)  是一种轻量级的「标记语言」，很简单。花半个小时看一下就能熟练使用了\r\n\r\n\r\n\r\n## markdown基本语法格式\r\n\r\n### 标题\r\n这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。\r\n\r\n而在 Markdown 中，你只需要在文本前面加上 **#** 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 **#** 即可，标题字号相应降低。\r\n\r\n>注：# 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。\r\n\r\n你可以你的编辑器中尝试输入这六级标题，可以参考下方的截图：\r\n\r\n![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-1-31-markdown_edit/1.png)\r\n\r\n### 列表\r\n列表格式也很常用，在 Markdown 中，你只需要在文字前面加上 **-** 就可以了。<br>\r\n如果你希望有序列表，\r\n也可以在文字前面加上 `1. 2. 3.` 就可以了，\r\n\r\n>注：`-、1.` 和文本之间要保留一个字符的空格。\r\n\r\n列表案例截图如下：\r\n![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-1-31-markdown_edit/2.png)\r\n\r\n### 链接和图片\r\n在 Markdown 中，插入链接不需要其他按钮，你只需要使用 `[显示文本](链接地址)` 这样的语法即可，例如：<br>\r\n`[简书](http://www.jianshu.com)`\r\n\r\n在 Markdown 中，插入图片不需要其他按钮，你只需要使用 `[图片上传失败...(image-5fdc5-1510890177031)]` 这样的语法即可，例如：\r\n\r\n`![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-1-31-markdown_edit/1.png)`\r\n\r\n### 引用\r\n\r\n在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 `>` 就好了，例如：\r\n\r\n`> 一盏灯， 一片昏黄`\r\n\r\n显示结果为：\r\n\r\n>一盏灯， 一片昏黄\r\n\r\n### 斜体和粗体\r\n\r\nMarkdown 的粗体和斜体也非常简单，用两个 `*` 包含一段文本就是粗体的语法，用一个 `*` 包含一段文本就是斜体的语法。例如：\r\n\r\n`*一盏灯*， **一片昏黄**`\r\n\r\n显示结果为\r\n\r\n*一盏灯*， **一片昏黄**\r\n\r\n### 代码引用\r\n\r\n需要引用代码时，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。\r\n如果引用的语句为多行，可以将```置于这段代码的首行和末行。\r\n代码引用的案例截图：\r\n\r\n![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-1-31-markdown_edit/3.png)\r\n\r\n### 表格\r\n\r\n相关代码：\r\n\r\n```\r\n|Tables        | Are           | Cool  |\r\n| ------------- |:-------------:| -----:|\r\n| col 3 is      | right-aligned | $1600 |\r\n| col 2 is      | centered      |   $12 |\r\n| zebra stripes | are neat      |    $1 |\r\n```\r\n显示结果为\r\n\r\n|Tables        | Are           | Cool  |\r\n| ------------- |:-------------:| -----:|\r\n| col 3 is      | right-aligned | $1600 |\r\n| col 2 is      | centered      |   $12 |\r\n| zebra stripes | are neat      |    $1 |\r\n\r\n相关代码：\r\n\r\n```\r\ndog | bird | cat\r\n----|------|----\r\nfoo | foo  | foo\r\nbar | bar  | bar\r\nbaz | baz  | baz\r\n```\r\n显示结果：\r\n\r\ndog | bird | cat\r\n----|------|----\r\nfoo | foo  | foo\r\nbar | bar  | bar\r\nbaz | baz  | baz\r\n\r\n\r\n\r\n\r\n## Star\r\n如果觉得这篇教程还有点用，请点播关注，或者给我的[github仓库](https://github.com/wjw0315/wjw0315.github.io) 点个 **star** 吧！\r\n\r\n![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/star.png)\r\n\r\n点上面 **↑** 那个星星', '15', '20', '24', '8', '0', '0', '2018-02-05 10:08:41', '2018-03-03 19:22:59', '1', '1', '10');
INSERT INTO `article` VALUES ('38', '1', 'java多线程面试题型（搜罗中）', '<blockquote>\r\n<p>在典型的Java面试中， 面试官会从线程的基本概念问起, 如：为什么你需要使用线程， 如何创建线程，用什么方式创建线程比较好（比如：继承thread类还是调用Runnable接口），然后逐渐问到并发问题像在Java并发编程的过程中遇到了什么挑战，Java内存模型，JDK1.5引入了哪些更高阶的并发工具，并发编程常用的设计模式，经典多线程问题如生产者消费者，哲学家就餐，读写器或者简单的有界缓冲区问题。仅仅知道线程的基本概念是远远不够的， 你必须知道如何处理死锁，竞态条件，内存冲突和线程安全等并发问题。掌握了这些技巧，你就可以轻松应对多线程和并发面试了。</p>\r\n</blockquote>\r\n<ul>\r\n<li>1) 什么是线程？</li></ul>\r\n<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。</p>\r\n<ul>\r\n<li>2) 线程和进程有什么区别？</li></ul>\r\n<p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。（通俗的讲：进程是执行中的应用程序，有自己的内存空间；线程是进程执行的基本单元，也可以称为执行路径。）</p>\r\n<ul>\r\n<li>3) 如何在Java中实现线程？</li></ul>\r\n<p>在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。<br>1） 继承Thread类<br>2） 实现Runnable，Callable接口<br>3） 创建线程池</p>\r\n<ul>\r\n<li>4) 用Runnable还是Thread？</li></ul>\r\n<p>java不能实现多继承，但可以调用多个接口</p>\r\n<ul>\r\n<li>6) Thread 类中的start() 和 run() 方法有什么区别？</li></ul>\r\n<p>这个问题经常被问到， start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>\r\n<ul>\r\n<li>7) Java中Runnable和Callable有什么不同？</li></ul>\r\n<p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以<code>返回值</code>和<code>抛出异常</code>，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。</p>\r\n<ul>\r\n<li>8) Java中CyclicBarrier 和 CountDownLatch有什么不同？</li></ul>\r\n<p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。</p>\r\n<ul>\r\n<li><p>9) Java内存模型是什么？<br>Java线程之间的通信采用的是共享内存模型，这里提到的共享内存模型指的就是Java内存模型(简称JMM)，java内存模型的理解请看这篇文章<a href=\"http://wjwcloud.cn/article/39\">理解JMM</a></p>\r\n</li><li><p>10) Java中的volatile 变量是什么？</p>\r\n</li></ul>\r\n<p>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。</p>\r\n<ul>\r\n<li>11) 什么是线程安全？Vector是一个线程安全类吗？ </li></ul>\r\n<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。我们可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p>\r\n<ul>\r\n<li>12) Java中什么是竞态条件？ 举个例子说明。</li></ul>\r\n<p>竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理。</p>', '>在典型的Java面试中， 面试官会从线程的基本概念问起, 如：为什么你需要使用线程， 如何创建线程，用什么方式创建线程比较好（比如：继承thread类还是调用Runnable接口），然后逐渐问到并发问题像在Java并发编程的过程中遇到了什么挑战，Java内存模型，JDK1.5引入了哪些更高阶的并发工具，并发编程常用的设计模式，经典多线程问题如生产者消费者，哲学家就餐，读写器或者简单的有界缓冲区问题。仅仅知道线程的基本概念是远远不够的， 你必须知道如何处理死锁，竞态条件，内存冲突和线程安全等并发问题。掌握了这些技巧，你就可以轻松应对多线程和并发面试了。\r\n\r\n- 1) 什么是线程？\r\n\r\n线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。\r\n\r\n- 2) 线程和进程有什么区别？\r\n\r\n线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。（通俗的讲：进程是执行中的应用程序，有自己的内存空间；线程是进程执行的基本单元，也可以称为执行路径。）\r\n\r\n- 3) 如何在Java中实现线程？\r\n\r\n在语言层面有两种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。\r\n1） 继承Thread类\r\n2） 实现Runnable，Callable接口\r\n3） 创建线程池\r\n\r\n\r\n- 4) 用Runnable还是Thread？\r\n\r\njava不能实现多继承，但可以调用多个接口\r\n\r\n- 6) Thread 类中的start() 和 run() 方法有什么区别？\r\n\r\n这个问题经常被问到， start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。\r\n\r\n- 7) Java中Runnable和Callable有什么不同？\r\n\r\nRunnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以`返回值`和`抛出异常`，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。\r\n\r\n- 8) Java中CyclicBarrier 和 CountDownLatch有什么不同？\r\n\r\nCyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。\r\n\r\n- 9) Java内存模型是什么？\r\nJava线程之间的通信采用的是共享内存模型，这里提到的共享内存模型指的就是Java内存模型(简称JMM)，java内存模型的理解请看这篇文章[理解JMM](http://wjwcloud.cn/article/39)\r\n\r\n- 10) Java中的volatile 变量是什么？\r\n\r\nvolatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生，就是上一题的volatile变量规则。\r\n\r\n- 11) 什么是线程安全？Vector是一个线程安全类吗？ \r\n\r\n如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。我们可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。\r\n\r\n- 12) Java中什么是竞态条件？ 举个例子说明。\r\n\r\n竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现而且会重复出现，因为线程间的随机竞争。一个例子就是无序处理。', '1', '3', '1,8,25', '11', '0', '0', '2018-02-06 15:33:46', '2018-02-12 13:40:26', '1', '1', '1');
INSERT INTO `article` VALUES ('39', '1', '理解java内存模型（JMM）', '<blockquote>\r\n<p>Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。</p>\r\n</blockquote>\r\n<p>如果我们要想深入了解Java并发编程，就要先理解好Java内存模型。Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。原始的Java内存模型效率并不是很理想，因此Java1.5版本对其进行了重构，现在的Java8仍沿用了Java1.5的版本。</p>\r\n<h2 id=\"h2-u5173u4E8Eu5E76u53D1u7F16u7A0B\"><a name=\"关于并发编程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关于并发编程</h2><p>在并发编程领域，有两个关键问题：线程之间的通信和同步。</p>\r\n<h2 id=\"h2-u7EBFu7A0Bu4E4Bu95F4u7684u901Au4FE1\"><a name=\"线程之间的通信\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线程之间的通信</h2><blockquote>\r\n<p>线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种共享内存和消息传递。</p>\r\n</blockquote>\r\n<ul>\r\n<li><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。</p>\r\n</li><li><p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是wait()和notify()。</p>\r\n</li></ul>\r\n<p>关于Java线程之间的通信，可以参考线程之间的通信（thread signal）。</p>\r\n<h2 id=\"h2-u7EBFu7A0Bu4E4Bu95F4u7684u540Cu6B65\"><a name=\"线程之间的同步\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线程之间的同步</h2><blockquote>\r\n<p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。</p>\r\n</blockquote>\r\n<ul>\r\n<li><p>在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</p>\r\n</li><li><p>在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p>\r\n</li></ul>\r\n<h2 id=\"h2-java-\"><a name=\"Java的并发采用的是共享内存模型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Java的并发采用的是共享内存模型</h2><p>Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。</p>\r\n<h2 id=\"h2-java-\"><a name=\"Java内存模型\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Java内存模型</h2><p>上面讲到了Java线程之间的通信采用的是过共享内存模型，这里提到的共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p>\r\n<p>这里写图片描述</p>\r\n<p><img src=\"https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-2-6-JMM/1.png\" alt=\"\"></p>\r\n<p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>\r\n<pre><code>1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。\r\n2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。\r\n</code></pre><p>下面通过示意图来说明这两个步骤：<br>这里写图片描述</p>\r\n<p><img src=\"https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-2-6-JMM/2.png\" alt=\"\"></p>\r\n<p>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。</p>\r\n<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>', '>Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。\r\n\r\n如果我们要想深入了解Java并发编程，就要先理解好Java内存模型。Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。原始的Java内存模型效率并不是很理想，因此Java1.5版本对其进行了重构，现在的Java8仍沿用了Java1.5的版本。\r\n## 关于并发编程\r\n\r\n在并发编程领域，有两个关键问题：线程之间的通信和同步。\r\n## 线程之间的通信\r\n\r\n>线程的通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种共享内存和消息传递。\r\n\r\n- 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。\r\n\r\n- 在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是wait()和notify()。\r\n\r\n关于Java线程之间的通信，可以参考线程之间的通信（thread signal）。\r\n## 线程之间的同步\r\n\r\n>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。\r\n\r\n- 在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。\r\n\r\n- 在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。\r\n\r\n## Java的并发采用的是共享内存模型\r\n\r\nJava线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。\r\n\r\n## Java内存模型\r\n\r\n上面讲到了Java线程之间的通信采用的是过共享内存模型，这里提到的共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。\r\n\r\n这里写图片描述\r\n\r\n![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-2-6-JMM/1.png)\r\n\r\n从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：\r\n```\r\n1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。\r\n2. 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。 \r\n```\r\n下面通过示意图来说明这两个步骤：\r\n这里写图片描述\r\n\r\n![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018-2-6-JMM/2.png)\r\n\r\n如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。\r\n\r\n从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。', '1', '3', '1,25', '9', '1', '0', '2018-02-06 15:50:19', '2018-02-06 15:50:19', '1', '1', '1');
INSERT INTO `article` VALUES ('40', '1', 'java程序的执行顺序', '<p><strong>先来一题看程序结果：</strong></p>\r\n<pre><code>public class Test1 {\r\npublic static String name;\r\n    public static String name=get();\r\n    public Test1() {\r\n    }\r\n    public static String get() {\r\n        System.out.println(&quot;Test start&quot;);\r\n        return &quot;test name&quot;;\r\n    }\r\n    public static void main(String[] args) {\r\n        System.out.println(&quot;main start&quot;);\r\n        Text bb = new Text();\r\n    }\r\n}\r\n</code></pre><p>那么答案是什么？</p>\r\n<pre><code>main start\r\ntest start\r\n</code></pre><p><strong>那你就out啦</strong></p>\r\n<p>正确答案是：</p>\r\n<pre><code>test start\r\nmain start\r\n</code></pre><p>不是从main方法执行的吗？是怎么回事呢？</p>\r\n<p>Java程序运行时，第一件事情就是试图访问main方法，因为main相等于程序的入口，如果没有main方法，程序将无法启动，main方法更是占一个独立的线程，找到main方法后，是不是就会执行mian方法块里的第一句话呢？答案是不一定</p>\r\n<p>分析：</p>\r\n<pre><code>因为静态部分是依赖于类，而不是依赖于对象存在的，所以静态部分的加载优先于对象存在。\r\n</code></pre><p>当找到main方法后，因为main方法虽然是一个特殊的静态方法，但是还是静态方法，此时JVM会加载main方法所在的类，试图找到类中其他静态部分，即首先会找main方法所在的类，然后会按照顺序执行类中的静态代码，包括静态变量，静态方法和静态代码块，静态方法在不会主动调用，但会加载。静态方法执行完之后，才是动态代码的执行，包括动态属性赋值和代码块</p>\r\n<p><strong>执行顺序大致分类：</strong></p>\r\n<p>1.静态属性，静态方法声明，静态块。</p>\r\n<p>2.动态属性，普通方法声明，构造块。</p>\r\n<p>3.构造方法。</p>\r\n<ul>\r\n<li>1.1 静态：</li></ul>\r\n<p>当加载一个类时，JVM会根据属性的数据类型第一时间赋默认值（一举生成的）。然后再进行静态属性初始化，并为静态属性分配内存空间，静态方法的声明，静态块的加载，没有优先级之分，按出现顺序执行，静态部分仅仅加载一次。至此为止，必要的类都已经加载完毕，对象就可以被创建了。</p>\r\n<ul>\r\n<li>1.2 普通：</li></ul>\r\n<p>当new一个对象时，此时会调用构造方法，但是在调用构造方法之前，（此刻1.1已经完成，除非被打断而暂停）执行动态属性定义并设置默认值（一举生成的）。然后动态属性初始化，分配内存，构造块，普通方法声明（只是加载，它不需要初始化，只有调用它时才分配内存，当方法执行完毕后内存立即释放），没有优先级之分，按出现顺序执行。最后进行构造方法中赋值。当再次创建一个对象，不再执行静态部分，仅仅重复执行普通部分。</p>\r\n<p><strong>现在是否有些理解了呢？</strong></p>\r\n<p>我们再来分析下刚开始的测试题：</p>\r\n<p>1、首先jvm找到main入口，加载整个类<br>2、找到整个类所有的静态部分，包括静态变量和静态代码块，静态方法，这里是先找到name，发现它调用了get()方法，就先执行get方法，打印 test start ,返回值给name,执行完成之后，发现没有其他的静态变量或代码块啦，就执行main方法，打印main start</p>\r\n<p>再来道测试题：</p>\r\n<pre><code>class A {\r\n    public A() {\r\n        System.out.println(&quot;A的构造方法&quot;);\r\n    }\r\n    {\r\n        System.out.println(&quot;A的构造块&quot;);\r\n    }\r\n    public static int j = print();\r\n\r\n    public static int print() {\r\n        System.out.println(&quot;A print&quot;);\r\n        return 521;\r\n    }\r\n    public void b(){\r\n        System.out.println(&quot;A的普通函数&quot;);\r\n    }\r\n}\r\n\r\npublic class Test1 extends A {\r\n    public Test1() {\r\n        System.out.println(&quot;Test1的构造方法&quot;);\r\n    }\r\n    {\r\n        System.out.println(&quot;Test1的构造块&quot;);\r\n    }\r\n    public static int k = print();\r\n\r\n    public static int print() {\r\n        System.out.println(&quot;Test print&quot;);\r\n        return 522;\r\n    }\r\n    public void c(){\r\n        System.out.println(&quot;Test1的普通函数&quot;);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(&quot;main start&quot;);\r\n        Test1 t1 = new Test1();\r\n        t1.c();\r\n        t1.b();\r\n        //t1.c();\r\n    }\r\n}\r\n</code></pre><p>运行结果：</p>\r\n<p>A print<br>Test print<br>main start<br>A的构造块<br>A的构造方法<br>Test1的构造块<br>Test1的构造方<br>Test1的普通函<br>A的普通函数</p>\r\n<p>如果存在继承关系，会先执行父类的静态部分，再执行子类的静态部分，再执行父类的动态部分，再执行子类的动态部分。</p>\r\n<p>创建对象时，依然会首先进行动态属性进行定义并设默认值，然后父类的构造器才会被调用，其他一切都是先父类再子类（因为子类的static初始化可能会依赖于父类成员能否被正确初始化），如果父类还有父类，依次类推，不管你是否打算产生一个该父类的对象，这都是自然发生的。</p>\r\n<p>再来一个测试题：</p>\r\n<pre><code>public class Base\r\n{\r\n    private String baseName = &quot;base&quot;;\r\n    public Base()\r\n    {\r\n        callName();\r\n    }\r\n\r\n    public void callName()\r\n    {\r\n        System. out. println(baseName);\r\n    }\r\n\r\n    static class Sub extends Base\r\n    {\r\n        private String baseName = &quot;sub&quot;;\r\n        public void callName()\r\n        {\r\n            System. out. println (baseName) ;\r\n        }\r\n    }\r\n    public static void main(String[] args)\r\n    {\r\n        Base b = new Sub();\r\n    }\r\n}\r\n</code></pre><p>你认为的结果是什么？null？sub?还是base?</p>\r\n<p>正确的结果为：<strong>null</strong></p>\r\n<p>分析：<br>new sub();之后，首先是父类成员初始化，父类的构造函数调用callName（）的方法，在子类中有对父类方法的重写，所以覆盖了父类的callName（），此时的子类还并没有进行初始化，所以重写的方法打印出来的值为null。</p>', '**先来一题看程序结果：**\r\n\r\n```\r\npublic class Test1 {\r\npublic static String name;\r\n    public static String name=get();\r\n    public Test1() {\r\n    }\r\n    public static String get() {\r\n        System.out.println(\"Test start\");\r\n        return \"test name\";\r\n    }\r\n    public static void main(String[] args) {\r\n        System.out.println(\"main start\");\r\n        Text bb = new Text();\r\n    }\r\n}\r\n```\r\n\r\n那么答案是什么？\r\n```\r\nmain start\r\ntest start\r\n```\r\n\r\n**那你就out啦**\r\n\r\n正确答案是：\r\n```\r\ntest start\r\nmain start\r\n```\r\n\r\n不是从main方法执行的吗？是怎么回事呢？\r\n\r\nJava程序运行时，第一件事情就是试图访问main方法，因为main相等于程序的入口，如果没有main方法，程序将无法启动，main方法更是占一个独立的线程，找到main方法后，是不是就会执行mian方法块里的第一句话呢？答案是不一定\r\n\r\n分析：\r\n\r\n    因为静态部分是依赖于类，而不是依赖于对象存在的，所以静态部分的加载优先于对象存在。\r\n	\r\n当找到main方法后，因为main方法虽然是一个特殊的静态方法，但是还是静态方法，此时JVM会加载main方法所在的类，试图找到类中其他静态部分，即首先会找main方法所在的类，然后会按照顺序执行类中的静态代码，包括静态变量，静态方法和静态代码块，静态方法在不会主动调用，但会加载。静态方法执行完之后，才是动态代码的执行，包括动态属性赋值和代码块\r\n\r\n**执行顺序大致分类：**\r\n\r\n1.静态属性，静态方法声明，静态块。\r\n\r\n2.动态属性，普通方法声明，构造块。\r\n\r\n3.构造方法。\r\n\r\n- 1.1 静态：\r\n\r\n当加载一个类时，JVM会根据属性的数据类型第一时间赋默认值（一举生成的）。然后再进行静态属性初始化，并为静态属性分配内存空间，静态方法的声明，静态块的加载，没有优先级之分，按出现顺序执行，静态部分仅仅加载一次。至此为止，必要的类都已经加载完毕，对象就可以被创建了。\r\n\r\n- 1.2 普通：\r\n\r\n当new一个对象时，此时会调用构造方法，但是在调用构造方法之前，（此刻1.1已经完成，除非被打断而暂停）执行动态属性定义并设置默认值（一举生成的）。然后动态属性初始化，分配内存，构造块，普通方法声明（只是加载，它不需要初始化，只有调用它时才分配内存，当方法执行完毕后内存立即释放），没有优先级之分，按出现顺序执行。最后进行构造方法中赋值。当再次创建一个对象，不再执行静态部分，仅仅重复执行普通部分。\r\n\r\n**现在是否有些理解了呢？**\r\n\r\n我们再来分析下刚开始的测试题：\r\n\r\n1、首先jvm找到main入口，加载整个类\r\n2、找到整个类所有的静态部分，包括静态变量和静态代码块，静态方法，这里是先找到name，发现它调用了get()方法，就先执行get方法，打印 test start ,返回值给name,执行完成之后，发现没有其他的静态变量或代码块啦，就执行main方法，打印main start\r\n\r\n再来道测试题：\r\n\r\n```\r\nclass A {\r\n    public A() {\r\n        System.out.println(\"A的构造方法\");\r\n    }\r\n	{\r\n		System.out.println(\"A的构造块\");\r\n	}\r\n    public static int j = print();\r\n\r\n    public static int print() {\r\n        System.out.println(\"A print\");\r\n        return 521;\r\n    }\r\n	public void b(){\r\n		System.out.println(\"A的普通函数\");\r\n	}\r\n}\r\n\r\npublic class Test1 extends A {\r\n    public Test1() {\r\n        System.out.println(\"Test1的构造方法\");\r\n    }\r\n	{\r\n		System.out.println(\"Test1的构造块\");\r\n	}\r\n    public static int k = print();\r\n\r\n    public static int print() {\r\n        System.out.println(\"Test print\");\r\n        return 522;\r\n    }\r\n	public void c(){\r\n		System.out.println(\"Test1的普通函数\");\r\n	}\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(\"main start\");\r\n        Test1 t1 = new Test1();\r\n		t1.c();\r\n		t1.b();\r\n		//t1.c();\r\n    }\r\n}\r\n```\r\n\r\n运行结果：\r\n\r\nA print\r\nTest print\r\nmain start\r\nA的构造块\r\nA的构造方法\r\nTest1的构造块\r\nTest1的构造方\r\nTest1的普通函\r\nA的普通函数\r\n\r\n如果存在继承关系，会先执行父类的静态部分，再执行子类的静态部分，再执行父类的动态部分，再执行子类的动态部分。\r\n\r\n创建对象时，依然会首先进行动态属性进行定义并设默认值，然后父类的构造器才会被调用，其他一切都是先父类再子类（因为子类的static初始化可能会依赖于父类成员能否被正确初始化），如果父类还有父类，依次类推，不管你是否打算产生一个该父类的对象，这都是自然发生的。\r\n\r\n再来一个测试题：\r\n\r\n```\r\npublic class Base\r\n{\r\n    private String baseName = \"base\";\r\n    public Base()\r\n    {\r\n        callName();\r\n    }\r\n\r\n    public void callName()\r\n    {\r\n        System. out. println(baseName);\r\n    }\r\n\r\n    static class Sub extends Base\r\n    {\r\n        private String baseName = \"sub\";\r\n        public void callName()\r\n        {\r\n            System. out. println (baseName) ;\r\n        }\r\n    }\r\n    public static void main(String[] args)\r\n    {\r\n        Base b = new Sub();\r\n    }\r\n}\r\n```\r\n\r\n你认为的结果是什么？null？sub?还是base?\r\n\r\n正确的结果为：**null**\r\n\r\n分析：\r\nnew sub();之后，首先是父类成员初始化，父类的构造函数调用callName（）的方法，在子类中有对父类方法的重写，所以覆盖了父类的callName（），此时的子类还并没有进行初始化，所以重写的方法打印出来的值为null。', '1', '2', '1,8', '12', '0', '0', '2018-02-12 12:07:52', '2018-03-03 19:23:25', '1', '1', '10');
INSERT INTO `article` VALUES ('41', '1', 'java多线程', '<p><strong>进程</strong>：正在执行中的程序，其实是应用程序在内存中运行的那片空间。</p>\r\n<p><strong>线程</strong>：进程中的一个执行单元，负责进程中程序的执行。一个进程中至少有一个线程，也可以有多个线程，此时称为多线程程序。</p>\r\n<p>CPU处理程序是通过快速切换完成的，与我们来说是随机的；多线程的使用可以合理的使用CPU资源，如果线程过多会导致降低性能。</p>\r\n<h2 id=\"h2-thread-\"><a name=\"Thread 的相关方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Thread 的相关方法</h2><pre><code>Thread.currentThread().getName(): 获得当前线程的名称(主线程:main；自定义线程:Thread-N)。\r\nisAlive:判断线程是否未终止\r\ngetPriority:获得线程的优先级数值\r\nsetPriority:设置线程的优先级数值\r\nsetName:设置线程的名字\r\n</code></pre><h2 id=\"h2-u521Bu5EFAu7EBFu7A0Bu7684u4E24u79CDu65B9u5F0F\"><a name=\"创建线程的两种方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建线程的两种方式</h2><h3 id=\"h3--thread-\"><a name=\"一、继承Thread类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>一、继承Thread类</h3><pre><code>继承Thread类\r\n重写Thread的run方法。\r\n创建子类对象，即线程对象\r\n调用start方法，开启线程并让线程执行，同时告诉jvm去调用run方法。\r\n</code></pre><pre><code>class Demo extends Thread{\r\n    private String name;\r\n\r\n    public Demo(String name) {\r\n        super();\r\n        this.name = name;\r\n    }\r\n\r\n    public void run() {\r\n        for (int i = 1; i &lt;= 10; i++) {\r\n            System.out.println(&quot;=====&quot;+ Thread.currentThread().getName() +&quot;=====&quot; + this.name + i);\r\n        }\r\n    }\r\n}\r\n\r\npublic class ThreadDemo {\r\n    public static void main(String[] args) {\r\n        // 创建了两个线程对象\r\n        Demo d1 = new Demo(&quot;张三&quot;);\r\n        Demo d2 = new Demo(&quot;李四&quot;);\r\n        d2.start();//将d2线程开启\r\n        d1.run();// 由主线程负责\r\n    }\r\n}\r\n</code></pre><p><strong>问题</strong></p>\r\n<pre><code>线程对象调用run方法和调用start方法的区别？\r\n调用run方法不开启线程,仅是对象调用方法.\r\n调用start开启线程,并让jvm调用run方法在开启的线程中执行.\r\n</code></pre><p><strong>多线程内存</strong></p>\r\n<pre><code>多线程执行时,在栈内存中,每一个线程都有一片属于自己的栈内存空间,进行方法的压栈和弹栈.\r\n当执行线程的任务结束了,线程自动在栈内存中释放.\r\n当所有的执行线程都结束了,进程才结束\r\n</code></pre><h3 id=\"h3--runnable-\"><a name=\"二、实现 Runnable 接口\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二、实现 Runnable 接口</h3><pre><code>定义类实现Runnable接口: 避免继承Thread类的单继承局限性\r\n覆盖接口中的run方法。将线程任务代码定义到run方法中\r\n创建Thread类的对象，并将Runnable接口的子类对象作为参数传递给Thread类的构造函数。因为线程被封装到Runnable接口的run方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给THread的构造函数。这样，线程对象创建时就可以明确要运行的线程任务。\r\n调用Thread类的start方法开启线程\r\n</code></pre><pre><code>class Demo implements Runnable{\r\n    private String name;\r\n\r\n    public Demo(String name) {\r\n        super();\r\n        this.name = name;\r\n    }\r\n   // 覆盖了接口Runnable中的run方法 \r\n    public void run() {\r\n        for (int i = 1; i &lt;= 10; i++) {\r\n            System.out.println(&quot;=====&quot;+ Thread.currentThread().getName() +&quot;=====&quot; + this.name + i);\r\n        }\r\n    }\r\n}\r\n\r\npublic class ThreadDemo {\r\n    public static void main(String[] args) {\r\n       // 创建Runnable子类的对象，注意它并不是线程对象\r\n        Demo d1 = new Demo(&quot;张三&quot;);\r\n        Demo d2 = new Demo(&quot;李四&quot;);\r\n        Thread t1 = new Thread(d1); \r\n        Thread t2 = new Thread(d2); \r\n        t1.start();\r\n        t2.start();\r\n        System.out.println(Thread.currentThread().getName());\r\n    }\r\n}\r\n</code></pre><p><strong>优势</strong></p>\r\n<pre><code>实现Runnable接口避免了单继承的局限性，所以较为常用。\r\n实现Runnable接口的方式，更加符合面向对象。线程分为两部分，一部分线程对象，一部分线程任务。\r\n    继承Thread类，线程对象和任务耦合在一起，一旦创建Thread子类对象，即使线程对象，又是线程任务。\r\n    实现Runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口，实现了解耦。\r\n</code></pre><h2 id=\"h2-u7EBFu7A0Bu72B6u6001\"><a name=\"线程状态\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线程状态</h2><p><img src=\"https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018/2/3/java_Thread/1.png\" alt=\"\"></p>\r\n<h3 id=\"h3-u591Au7EBFu7A0Bu7684u5B89u5168u95EEu9898\"><a name=\"多线程的安全问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>多线程的安全问题</h3><p>由于线程的随机性，会出现多线程的安全问题。</p>\r\n<p><strong>原因</strong></p>\r\n<pre><code>线程任务操作共享的数据\r\n线程任务操作数据的运算有多个\r\n</code></pre><p><strong>解决</strong></p>\r\n<p>1、synchronized 同步代码块</p>\r\n<pre><code>synchronized(对象){\r\n    // 需要被同步的代码\r\n}\r\n</code></pre><p><strong>原理</strong></p>\r\n<p>线程1读到synchronized，会找后面括号中的对象(可任意，一般写this)并拿到该对象，之后往下执行。当线程2读到synchronized的时候，也会找后面括号中的对象，发现被线程1拿走了，所以线程2进不来了。直到线程1执行完synchronized代码块并释放对象之后，线程2才能继续执行。(对象相当于锁)—&gt;火车上的卫生间</p>\r\n<p><strong>注意:</strong>必须保证多个线程在同步中使用的同一个锁，即synchronized后面括号中为同一个对象</p>\r\n<p><strong>同步弊端：</strong>降低了程序性能。</p>\r\n<h3 id=\"h3-2-\"><a name=\"2、 同步函数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、 同步函数</h3><p>同步函数使用的锁是固定的this。当线程任务只需要一个同步时完全可以使用同步函数。<br>同步代码块使用的锁是任意对象。当线程中需要多个同步时 ，必须通过锁来区分(较为常用)</p>\r\n<pre><code>public synchronized void method(){\r\n    // 需要被同步的代码\r\n}\r\n</code></pre><p><strong>注意:</strong>static同步函数public static synchronized void method(){}，使用的锁不是this，而是字节码文件对象(类名.class)。因为万物皆对象，字节码文件也被视为对象存在。因此相应的synchronized代码块后的对象也要用类名.class:synchronized(类名.class){}.</p>\r\n<p><strong>分析</strong></p>\r\n<pre><code>既然是多线程的问题，必然发生在线程任务内\r\n分析线程任务内是否有共享数据\r\n是否有对数据进行多次运算\r\n</code></pre><h3 id=\"h3-u61D2u6C49u5F0Fu7EBFu7A0Bu5B89u5168u95EEu9898\"><a name=\"懒汉式线程安全问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>懒汉式线程安全问题</h3><p> 饿汉式:线程安全，调用率高，但是不能延时加载，类初始化时，立即加载这个对象</p>\r\n<pre><code>public class Demo01 {\r\n    private static Demo01 instance = new Demo01();\r\n    private Demo01() { }\r\n    public static Demo01 getInstance() {\r\n        return instance;\r\n    }\r\n}\r\n</code></pre><p>懒汉式:可以延时加载，存在线程问题，可以加锁，并且为了兼顾效率，再加一次判断，减少判断锁的次数</p>\r\n<pre><code>public class Single {\r\n    private static Single instance;\r\n    private Single() { }\r\n    public static  Single getInstance() {\r\n        if(instance == null){\r\n            synchronized(Single.class){\r\n                if (instance == null) {\r\n                instance = new Single();\r\n             }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n</code></pre><h2 id=\"h2-u6B7Bu9501\"><a name=\"死锁\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>死锁</h2><p>当线程任务中出现了多个同步(多个锁)时，如果同步中嵌套了其他同步，容易引发死锁。如下:</p>\r\n<pre><code>//Thread_0\r\nsynchronized(obj1){\r\n    //Thread-0 obj1--&gt;\r\n    synchronized(obj2){\r\n    }\r\n}\r\n\r\n//Thread_1\r\nsynchronized(obj2){\r\n    //Thread-1 obj2--&gt;\r\n    synchronized(obj1){\r\n    }\r\n}\r\n</code></pre><p><strong>一个死锁程序</strong></p>\r\n<pre><code>public class DeadLock {\r\n    public static void main(String[] args) {\r\n        Test t1 = new Test(true);\r\n        Test t2 = new Test(false);\r\n        Thread t11 = new Thread(t1);\r\n        Thread t22 = new Thread(t2);\r\n        t11.start();\r\n        t22.start();\r\n    }\r\n}\r\n\r\nclass Test implements Runnable {\r\n    private boolean flag = false;\r\n\r\n    Test(boolean flag) {\r\n        this.flag = flag;\r\n    }\r\n\r\n    public void run() {\r\n        if (flag) {\r\n            while (true) {\r\n                synchronized (MyLock.LOCKA) {\r\n                    System.out.println(Thread.currentThread().getName() + &quot;...if...lock a&quot;);\r\n                    synchronized (MyLock.LOCKB) {\r\n                        System.out.println(Thread.currentThread().getName() + &quot;...if...lock b&quot;);\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else {\r\n            while (true) {\r\n                synchronized (MyLock.LOCKB) {\r\n                    System.out.println(Thread.currentThread().getName() + &quot;...if...lock b&quot;);\r\n                    synchronized (MyLock.LOCKA) {\r\n                        System.out.println(Thread.currentThread().getName() + &quot;...if...lock a&quot;);\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n}\r\n\r\nclass MyLock {\r\n    public static final Object LOCKA = new Object();\r\n    public static final Object LOCKB = new Object();\r\n}\r\n</code></pre><h2 id=\"h2-u591Au7EBFu7A0Bu901Au8BAF\"><a name=\"多线程通讯\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>多线程通讯</h2><h3 id=\"h3-u751Fu4EA7u8005u6D88u8D39u8005u95EEu9898\"><a name=\"生产者消费者问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>生产者消费者问题</h3><p>这是多线程中最为常见的案例(重要)<br>生产者和消费者同时执行，需要多线程；但是任务却不相同，处理的资源是相同的:线程间的通信</p>\r\n<p><strong>生产消费实例:</strong></p>\r\n<pre><code>public class ProduceConsumer {\r\n    public static void main(String[] args) {\r\n        Resource r = new Resource();\r\n        Produce produce = new Produce(r);\r\n        Consumer consumer = new Consumer(r);\r\n        Thread t1 = new Thread(produce);\r\n        Thread t11 = new Thread(produce);\r\n        Thread t2 = new Thread(consumer);\r\n        Thread t22 = new Thread(consumer);\r\n        // 开启多个生产多个消费\r\n        t1.start();\r\n        t11.start();\r\n        t2.start();\r\n        t22.start();\r\n    }\r\n}\r\n\r\n// 资源\r\nclass Resource {\r\n    private String name;\r\n    private int num = 1;\r\n    private boolean flag = false;\r\n\r\n    // 生产\r\n    public synchronized void set(String name) {\r\n        while (flag) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        this.name = name + num;\r\n        num++;\r\n        System.out.println(Thread.currentThread().getName() + &quot;---生产者---&quot; + this.name);\r\n        flag = true;\r\n        notifyAll();\r\n    }\r\n\r\n    // 消费\r\n    public synchronized void get() {\r\n        while (!flag) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        System.out.println(Thread.currentThread().getName() + &quot;---消费者---&quot; + this.name);\r\n        flag = false;\r\n        notifyAll();\r\n    }\r\n}\r\n\r\n// 生产者\r\nclass Produce implements Runnable {\r\n    private Resource r;\r\n\r\n    public Produce(Resource r) {\r\n        this.r = r;\r\n    }\r\n\r\n    public void run() {\r\n        for (int i = 50; i &lt; 200; i++) {\r\n            r.set(&quot;面包&quot;); // 开始生产\r\n        }\r\n    }\r\n}\r\n\r\n// 消费者\r\nclass Consumer implements Runnable {\r\n    private Resource r;\r\n\r\n    public Consumer(Resource r) {\r\n        this.r = r;\r\n    }\r\n\r\n    public void run() {\r\n        for (int i = 0; i &lt; 200; i++) {\r\n            r.get(); // 开始消费\r\n        }\r\n    }\r\n}\r\n</code></pre><p><strong>注意:</strong></p>\r\n<pre><code>当多个生产消费的时候，为防止被唤醒的线程没有判断标记，要用while判断标记，而不是if。\r\n用while时会出现死锁，因为本方唤醒了本方,希望唤醒对方，所以使用notifyAll方法。\r\n</code></pre><h3 id=\"h3-u7B49u5F85u5524u9192u673Au5236\"><a name=\"等待唤醒机制\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>等待唤醒机制</h3><pre><code>wait(): 会让线程处于等待状态，将线程临时存进了线程池中\r\nnotify(): 会唤醒线程池中的任意一个等待线程。\r\nnotifyAll(): 会唤醒线程池中所有的等待线程。\r\n</code></pre><p><strong>注意:</strong></p>\r\n<pre><code>这些方法必须使用在同步中，因为必须要标识wait、notify等方法所使用的锁。同一个锁上的notify，只能唤醒该锁上的wait方法。\r\n这些方法必须标识所属的锁，而锁可以是任意对象，任意对象可以调用的方法必须是Object的方法，所以这些方法定义在Object类中\r\n</code></pre><h2 id=\"h2-lock\"><a name=\"Lock\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Lock</h2><p>在 JDK 1.5 之后，Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。</p>\r\n<pre><code>Lock l = ...; \r\n     l.lock();\r\n     try {\r\n         // access the resource protected by this lock\r\n     } finally {\r\n         l.unlock(); // 因为必须要释放锁，所以放到finally中\r\n     }\r\n</code></pre><p>因为必须要释放锁，所以lock.lock()放到finally 块中。</p>\r\n<p>之前用synchronized同步，锁可以是任意对象，并且锁对象和锁的方法是在一块的(Object 对象中的object()、notify()、notifyAll()方法)，而在Lock中把所有的监视器方法封装到Condition 对象中，实现了锁对象和监视器方法(锁方法)的分离，更加的面向对象。</p>\r\n<pre><code>Lock lock = new ReentrantLock(); // 获得锁对象\r\nCondition con = lock.newCondition(); // 获得lock上的监视器方法对象\r\nlock.lock();    // 得到锁\r\ncon.await();    //  让线程处于等待状态\r\ncon.signal();   // 唤醒任意一个等待的线程\r\ncon.singnalAll(); // 唤醒所有等待的线程\r\nlock.unlock();  // 释放锁\r\n</code></pre><p><strong>一个实例</strong></p>\r\n<pre><code>class BoundedBuffer {\r\n   final Lock lock = new ReentrantLock();\r\n   final Condition notFull  = lock.newCondition(); \r\n   final Condition notEmpty = lock.newCondition(); \r\n\r\n   final Object[] items = new Object[100];\r\n   int putptr, takeptr, count;\r\n\r\n   public void put(Object x) throws InterruptedException {\r\n     lock.lock();\r\n     try {\r\n       while (count == items.length) \r\n         notFull.await();\r\n       items[putptr] = x; \r\n       if (++putptr == items.length) putptr = 0;\r\n       ++count;\r\n       notEmpty.signal();\r\n     } finally {\r\n       lock.unlock();\r\n     }\r\n   }\r\n\r\n   public Object take() throws InterruptedException {\r\n     lock.lock();\r\n     try {\r\n       while (count == 0) \r\n         notEmpty.await();\r\n       Object x = items[takeptr]; \r\n       if (++takeptr == items.length) takeptr = 0;\r\n       --count;\r\n       notFull.signal();\r\n       return x;\r\n     } finally {\r\n       lock.unlock();\r\n     }\r\n   } \r\n }\r\n</code></pre><h2 id=\"h2-u591Au7EBFu7A0Bu7684u7EC6u8282u95EEu9898\"><a name=\"多线程的细节问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>多线程的细节问题</h2><h3 id=\"h3-1-sleep-wait-\"><a name=\"1. sleep 和 wait 方法的异同点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. sleep 和 wait 方法的异同点</h3><pre><code>- 相同点\r\n    都可以让线程处于冻结状态\r\n- 不同点\r\n    sleep 必须指定时间；wait 可以指定时间，也可以不指定时间\r\n    sleep 时间到，线程处于临时阻塞或者运行；wait 如果没指定时间，必须通过notify 或者 notifyAll唤醒。\r\n    sleep 不一定非要定义在同步中；wait 必须定义在同步中。\r\n    都定义在同步中\r\n        线程执行到 sleep，不会释放所\r\n        线程执行到 wait，会释放锁\r\n</code></pre><h3 id=\"h3-2-\"><a name=\"2. 线程如何停止\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. 线程如何停止</h3><p>所谓线程结束，就是让线程任务代码完成，run方法结束。</p>\r\n<pre><code>stop 方法(过时):具有固定的不安全性，用Thread.stop来终止线程，将释放它已经锁定的所有监视器。\r\n定义循环，控制住循环就行了\r\n如果目标线程等待很长时间(处于冻结状态)，应用interrupt方法中断该线程(将线程的冻结状态清除，让线程重新获得cpu的执行资格)，并且收到一个InterruptException，在catch块中捕获，在异常处理中改变标记，让循环结束。\r\n</code></pre><h3 id=\"h3-interrupt-\"><a name=\"Interrupt 实例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Interrupt 实例</h3><pre><code>package thread;\r\n\r\nclass Task implements Runnable {\r\n    boolean flag = true;\r\n    public synchronized void run() {\r\n        while (flag) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + e.toString());\r\n                changeFlag();\r\n            }\r\n            System.out.println(Thread.currentThread().getName());\r\n        }\r\n    }\r\n    public void changeFlag() {\r\n        flag = false;\r\n    }\r\n}\r\npublic class InterruptDemo {\r\n    public static void main(String[] args) {\r\n        Task d = new Task();\r\n        Thread t1 = new Thread(d,&quot;线程1&quot;);\r\n        Thread t2 = new Thread(d,&quot;线程2&quot;);\r\n        t1.start();\r\n        t2.start();\r\n        int x = 0;\r\n        while (true) {\r\n            if (++x == 50) {\r\n                // d.changeFlag();\r\n                t1.interrupt();\r\n                t2.interrupt();\r\n                break;\r\n            }\r\n            System.out.println(Thread.currentThread().getName());\r\n        }\r\n        System.out.println(&quot;over...&quot;);\r\n    }\r\n}\r\n</code></pre><h2 id=\"h2-3-\"><a name=\"3. 守护线程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 守护线程</h2><p>守护线程，可以理解为后台线程，一般创建的为前台线程，前后台运行线程的时候都是一样的，获取cpu的执行权限。但是结束的时候有些不同，前台线程和后台线程只要run方法结束，线程结束，但是在所有前台线程结束的时候，后台线程无论处于什么状态都会结束，从而进程结束。进程结束依赖的都是前台线程。</p>\r\n<p>方法: setDaemon(boolean on)</p>\r\n<pre><code>该方法必须在线程启动前调用:t.setDaemon(true); t.start; // t 线程设置为了守护线程\r\non如果为true，该线程标记为守护线程\r\n</code></pre><h2 id=\"h2-4-\"><a name=\"4. 线程的优先级\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4. 线程的优先级</h2><p>Thread.currentThread.toString: 返回该线程的字符串表示形式，包括『线程名称』、『优先级』、『线程组』</p>\r\n<p>优先级:</p>\r\n<pre><code>用数字标识的0-10；其中默认的初始化优先级是5；\r\n最明显的三个优先级 : 1，5，10。\r\nThread.MAX_PRIORITY 线程可以具有的最高优先级。\r\nThread.MIN_PRIORITY 线程可以具有的最低优先级。\r\nThread.NORM_PRIORITY 分配给线程的默认优先级。\r\n得到线程的优先级:getPriority()\r\n更改线程的优先级:setPriority()\r\n</code></pre><h2 id=\"h2-5-\"><a name=\"5. 线程组\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5. 线程组</h2><p>ThreadGroup: 可以通过Thread构造函数明确新线程对象所属的线程组</p>\r\n<p>线程组的好处: 可以对多个同组线程，进行统一的操作。默认都属于main线程。</p>\r\n<h2 id=\"h2-6-join-yield-\"><a name=\"6. join() 和 yield() 方法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6. join() 和 yield() 方法</h2><p><strong>join() 方法</strong></p>\r\n<p>用于临时加入一个运算的线程。让该线程执行完，程序才会执行。</p>\r\n<pre><code>Demo d  = new Demo();\r\nThread t1 = new Thread(d);\r\nThread t2 = new Thread(d);\r\nt1.start();\r\ntry{\r\n    // 主线程执行到这里，知道t1要加入执行，主线程释放了执行权(仅仅是释放，至于执行权给谁，有cpu随机决定)\r\n    // 主线程的执行资格处于冻结状态，直至t1线程执行完恢复\r\n    t1.join;\r\n    }catch(InterruptException e){}\r\nt2.start();\r\n</code></pre><p><strong>yield() 方法</strong></p>\r\n<p>暂停当前正在执行的线程对象，并执行其他线程。</p>\r\n<pre><code>class Demo implements Runnable{\r\n    public void run(){\r\n        for(int i = 0; i &lt; 30; i++){\r\n            // 线程临时停止，将执行权释放，让其他线程有机会获得执行权\r\n            Thread.yield();\r\n        }\r\n    }\r\n}\r\n</code></pre><p>线程中匿名内部类使用</p>\r\n<pre><code>Runnable r = new Runnable(){\r\n    public void run (){\r\n        code....\r\n    }    \r\n};\r\nnew Thread(r).start();\r\n\r\nnew Thread(){\r\n    public void run (){\r\n        code....\r\n}      \r\n}.start();\r\n</code></pre><p>哪一个执行？</p>\r\n<pre><code>new Thread(new Runnable(){\r\n        public void run(){\r\n            System.out.println(&quot;runnable run&quot;);\r\n        }\r\n    }){\r\n        public void run(){\r\n            System.out.println(&quot;subthread run&quot;); // 执行\r\n        }\r\n    }.start();\r\n</code></pre><h3 id=\"h3-u7EBFu7A0Bu6C60\"><a name=\"线程池\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>线程池</h3><p>自JDK5之后，Java推出了一个并发包：java.util.concurrent，在Java开发中，我们接触到了好多池的技术，String类的对象池、Integer的共享池、连接数据库的连接池、Struts1.3的对象池等等，池的最终目的都是节约资源，以更小的开销做更多的事情，从而提高性能。</p>\r\n<p>我们的web项目都是部署在服务器上，浏览器端的每一个request就是一个线程，那么服务器需要并发的处理多个请求，就需要线程池技术，下面来看一下Java并发包下如何创建线程池。</p>\r\n<pre><code>创建一个可重用固定线程集合的线程池，以共享的无界队列方式来运行这些线程。\r\n</code></pre><pre><code>ExecutorService threadPool = Executors.newFixedThreadPool(3);// 创建可以容纳3个线程的线程池\r\n\r\n    创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。\r\n\r\nExecutorService threadPool = Executors.newCachedThreadPool();// 线程池的大小会根据执行的任务数动态分配\r\n\r\n    创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。\r\n\r\nExecutorService threadPool = Executors.newSingleThreadExecutor();\r\n// 创建单个线程的线程池，如果当前线程在执行任务时突然中断，则会创建一个新的线程替代它继续执行任务\r\n\r\n    创建一个可安排在给定延迟后运行命令或者定期地执行的线程池。\r\n\r\nScheduledExecutorService threadPool = Executors.newScheduledThreadPool(3); // 效果类似于Timer定时器\r\n\r\n每种线程池都有不同的使用场景，下面看一下这四种线程池使用起来有什么不同。\r\n</code></pre><h3 id=\"h3-fixedthreadpool\"><a name=\"FixedThreadPool\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>FixedThreadPool</h3><pre><code>import java.util.concurrent.ExecutorService;  \r\nimport java.util.concurrent.Executors;  \r\npublicclass ThreadPoolTest {  \r\npublic static void main(String[] args) {  \r\n    ExecutorService threadPool = Executors.newFixedThreadPool(3);  \r\n    for(int i = 1; i &lt; 5; i++) {  \r\n        final int taskID = i;  \r\n        threadPool.execute(new Runnable() {  \r\n            public void run() {  \r\n                for(int i = 1; i &lt; 5; i++) {  \r\n                    try {  \r\n                        Thread.sleep(20);// 为了测试出效果，让每次任务执行都需要一定时间\r\n                    } catch (InterruptedException e) {  \r\n                        e.printStackTrace();  \r\n                    }  \r\n                        System.out.println(&quot;第&quot; + taskID + &quot;次任务的第&quot; + i + &quot;次执行&quot;);  \r\n                    }  \r\n                }  \r\n            });  \r\n        }  \r\n        threadPool.shutdown();// 任务执行完毕，关闭线程池\r\n    }  \r\n}\r\n</code></pre><p>输出结果：</p>\r\n<pre><code>第1次任务的第1次执行  \r\n第2次任务的第1次执行  \r\n第3次任务的第1次执行  \r\n第2次任务的第2次执行  \r\n第3次任务的第2次执行  \r\n第1次任务的第2次执行  \r\n第3次任务的第3次执行  \r\n第1次任务的第3次执行  \r\n第2次任务的第3次执行  \r\n第3次任务的第4次执行  \r\n第2次任务的第4次执行  \r\n第1次任务的第4次执行  \r\n第4次任务的第1次执行  \r\n第4次任务的第2次执行  \r\n第4次任务的第3次执行  \r\n第4次任务的第4次执行\r\n</code></pre><p>上段代码中，创建了一个固定大小的线程池，容量为3，然后循环执行了4个任务，由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4个任务，在FixedThreadPool中，有一个固定大小的池，如果当前需要执行的任务超过了池大小，那么多余的任务等待状态，直到有空闲下来的线程执行任务，而当执行的任务小于池大小，空闲的线程也不会去销毁。</p>\r\n<h3 id=\"h3-cachedthreadpool\"><a name=\"CachedThreadPool\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>CachedThreadPool</h3><p>上段代码其它地方不变，将newFixedThreadPool(3)方法换成newCachedThreadPool()方法。</p>\r\n<p>输出结果：</p>\r\n<pre><code>第3次任务的第1次执行  \r\n第4次任务的第1次执行  \r\n第1次任务的第1次执行  \r\n第2次任务的第1次执行  \r\n第4次任务的第2次执行  \r\n第3次任务的第2次执行  \r\n第2次任务的第2次执行  \r\n第1次任务的第2次执行  \r\n第2次任务的第3次执行  \r\n第3次任务的第3次执行  \r\n第1次任务的第3次执行  \r\n第4次任务的第3次执行  \r\n第2次任务的第4次执行  \r\n第4次任务的第4次执行  \r\n第3次任务的第4次执行  \r\n第1次任务的第4次执行\r\n</code></pre><p>可见，4个任务是交替执行的，CachedThreadPool会创建一个缓存区，将初始化的线程缓存起来，如果线程有可用的，就使用之前创建好的线程，如果没有可用的，就新创建线程，终止并且从缓存中移除已有60秒未被使用的线程。</p>\r\n<h3 id=\"h3-singlethreadexecutor\"><a name=\"SingleThreadExecutor\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>SingleThreadExecutor</h3><p>上段代码其它地方不变，将newFixedThreadPool方法换成newSingleThreadExecutor方法。</p>\r\n<p>输出结果：</p>\r\n<pre><code>第1次任务的第1次执行  \r\n第1次任务的第2次执行  \r\n第1次任务的第3次执行  \r\n第1次任务的第4次执行  \r\n第2次任务的第1次执行  \r\n第2次任务的第2次执行  \r\n第2次任务的第3次执行  \r\n第2次任务的第4次执行  \r\n第3次任务的第1次执行  \r\n第3次任务的第2次执行  \r\n第3次任务的第3次执行  \r\n第3次任务的第4次执行  \r\n第4次任务的第1次执行  \r\n第4次任务的第2次执行  \r\n第4次任务的第3次执行  \r\n第4次任务的第4次执行\r\n</code></pre><p>4个任务是顺序执行的，SingleThreadExecutor得到的是一个单个的线程，这个线程会保证你的任务执行完成，如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。</p>\r\n<h3 id=\"h3-4-scheduledthreadpool\"><a name=\"4.ScheduledThreadPool\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.ScheduledThreadPool</h3><pre><code>import java.util.concurrent.Executors;\r\nimport java.util.concurrent.ScheduledExecutorService;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class ThreadPoolTest {\r\n    public static void main(String[] args) {\r\n        ScheduledExecutorService schedulePool = Executors.newScheduledThreadPool(1);\r\n        // 5秒后执行任务\r\n        schedulePool.schedule(new Runnable() {\r\n            public void run() {\r\n                System.out.println(&quot;爆炸&quot;);\r\n            }\r\n        }, 5, TimeUnit.SECONDS);\r\n        // 5秒后执行任务，以后每2秒执行一次\r\n        schedulePool.scheduleAtFixedRate(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(&quot;爆炸&quot;);\r\n            }\r\n        }, 5, 2, TimeUnit.SECONDS);\r\n    }\r\n}\r\n</code></pre><p><code>ScheduledThreadPool</code>可以定时的或延时的执行任务。</p>', '**进程**：正在执行中的程序，其实是应用程序在内存中运行的那片空间。\r\n\r\n**线程**：进程中的一个执行单元，负责进程中程序的执行。一个进程中至少有一个线程，也可以有多个线程，此时称为多线程程序。\r\n\r\n\r\nCPU处理程序是通过快速切换完成的，与我们来说是随机的；多线程的使用可以合理的使用CPU资源，如果线程过多会导致降低性能。\r\n\r\n## Thread 的相关方法\r\n\r\n    Thread.currentThread().getName(): 获得当前线程的名称(主线程:main；自定义线程:Thread-N)。\r\n    isAlive:判断线程是否未终止\r\n    getPriority:获得线程的优先级数值\r\n    setPriority:设置线程的优先级数值\r\n    setName:设置线程的名字\r\n\r\n## 创建线程的两种方式\r\n\r\n### 一、继承Thread类\r\n\r\n    继承Thread类\r\n    重写Thread的run方法。\r\n    创建子类对象，即线程对象\r\n    调用start方法，开启线程并让线程执行，同时告诉jvm去调用run方法。\r\n```\r\nclass Demo extends Thread{\r\n    private String name;\r\n\r\n    public Demo(String name) {\r\n        super();\r\n        this.name = name;\r\n    }\r\n\r\n    public void run() {\r\n        for (int i = 1; i <= 10; i++) {\r\n            System.out.println(\"=====\"+ Thread.currentThread().getName() +\"=====\" + this.name + i);\r\n        }\r\n    }\r\n}\r\n\r\npublic class ThreadDemo {\r\n    public static void main(String[] args) {\r\n        // 创建了两个线程对象\r\n        Demo d1 = new Demo(\"张三\");\r\n        Demo d2 = new Demo(\"李四\");\r\n        d2.start();//将d2线程开启\r\n        d1.run();// 由主线程负责\r\n    }\r\n}\r\n```\r\n\r\n**问题**\r\n\r\n    线程对象调用run方法和调用start方法的区别？\r\n    调用run方法不开启线程,仅是对象调用方法.\r\n    调用start开启线程,并让jvm调用run方法在开启的线程中执行.\r\n\r\n**多线程内存**\r\n\r\n    多线程执行时,在栈内存中,每一个线程都有一片属于自己的栈内存空间,进行方法的压栈和弹栈.\r\n    当执行线程的任务结束了,线程自动在栈内存中释放.\r\n    当所有的执行线程都结束了,进程才结束\r\n\r\n### 二、实现 Runnable 接口\r\n\r\n    定义类实现Runnable接口: 避免继承Thread类的单继承局限性\r\n    覆盖接口中的run方法。将线程任务代码定义到run方法中\r\n    创建Thread类的对象，并将Runnable接口的子类对象作为参数传递给Thread类的构造函数。因为线程被封装到Runnable接口的run方法中，而这个run方法所属于Runnable接口的子类对象，所以将这个子类对象作为参数传递给THread的构造函数。这样，线程对象创建时就可以明确要运行的线程任务。\r\n    调用Thread类的start方法开启线程\r\n```\r\nclass Demo implements Runnable{\r\n    private String name;\r\n\r\n    public Demo(String name) {\r\n        super();\r\n        this.name = name;\r\n    }\r\n   // 覆盖了接口Runnable中的run方法 \r\n    public void run() {\r\n        for (int i = 1; i <= 10; i++) {\r\n            System.out.println(\"=====\"+ Thread.currentThread().getName() +\"=====\" + this.name + i);\r\n        }\r\n    }\r\n}\r\n\r\npublic class ThreadDemo {\r\n    public static void main(String[] args) {\r\n       // 创建Runnable子类的对象，注意它并不是线程对象\r\n        Demo d1 = new Demo(\"张三\");\r\n        Demo d2 = new Demo(\"李四\");\r\n        Thread t1 = new Thread(d1); \r\n        Thread t2 = new Thread(d2); \r\n        t1.start();\r\n        t2.start();\r\n        System.out.println(Thread.currentThread().getName());\r\n    }\r\n}\r\n```\r\n\r\n**优势**\r\n\r\n    实现Runnable接口避免了单继承的局限性，所以较为常用。\r\n    实现Runnable接口的方式，更加符合面向对象。线程分为两部分，一部分线程对象，一部分线程任务。\r\n        继承Thread类，线程对象和任务耦合在一起，一旦创建Thread子类对象，即使线程对象，又是线程任务。\r\n        实现Runnable接口，将线程任务单独分离出来封装成对象，类型就是Runnable接口，实现了解耦。\r\n\r\n## 线程状态\r\n![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018/2/3/java_Thread/1.png)\r\n### 多线程的安全问题\r\n\r\n由于线程的随机性，会出现多线程的安全问题。\r\n\r\n**原因**\r\n\r\n    线程任务操作共享的数据\r\n    线程任务操作数据的运算有多个\r\n\r\n**解决**\r\n\r\n1、synchronized 同步代码块\r\n\r\n```\r\nsynchronized(对象){\r\n    // 需要被同步的代码\r\n}\r\n```\r\n\r\n**原理**\r\n\r\n线程1读到synchronized，会找后面括号中的对象(可任意，一般写this)并拿到该对象，之后往下执行。当线程2读到synchronized的时候，也会找后面括号中的对象，发现被线程1拿走了，所以线程2进不来了。直到线程1执行完synchronized代码块并释放对象之后，线程2才能继续执行。(对象相当于锁)-->火车上的卫生间\r\n\r\n**注意:**必须保证多个线程在同步中使用的同一个锁，即synchronized后面括号中为同一个对象\r\n\r\n**同步弊端：**降低了程序性能。\r\n\r\n### 2、 同步函数\r\n\r\n同步函数使用的锁是固定的this。当线程任务只需要一个同步时完全可以使用同步函数。\r\n同步代码块使用的锁是任意对象。当线程中需要多个同步时 ，必须通过锁来区分(较为常用)\r\n```\r\npublic synchronized void method(){\r\n    // 需要被同步的代码\r\n}\r\n```\r\n**注意:**static同步函数public static synchronized void method(){}，使用的锁不是this，而是字节码文件对象(类名.class)。因为万物皆对象，字节码文件也被视为对象存在。因此相应的synchronized代码块后的对象也要用类名.class:synchronized(类名.class){}.\r\n\r\n**分析**\r\n\r\n    既然是多线程的问题，必然发生在线程任务内\r\n    分析线程任务内是否有共享数据\r\n    是否有对数据进行多次运算\r\n\r\n### 懒汉式线程安全问题\r\n\r\n 饿汉式:线程安全，调用率高，但是不能延时加载，类初始化时，立即加载这个对象\r\n\r\n```\r\npublic class Demo01 {\r\n    private static Demo01 instance = new Demo01();\r\n    private Demo01() { }\r\n    public static Demo01 getInstance() {\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n懒汉式:可以延时加载，存在线程问题，可以加锁，并且为了兼顾效率，再加一次判断，减少判断锁的次数\r\n\r\n\r\n```\r\npublic class Single {\r\n    private static Single instance;\r\n    private Single() { }\r\n    public static  Single getInstance() {\r\n        if(instance == null){\r\n            synchronized(Single.class){\r\n                if (instance == null) {\r\n                instance = new Single();\r\n             }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n}\r\n```\r\n\r\n## 死锁\r\n\r\n当线程任务中出现了多个同步(多个锁)时，如果同步中嵌套了其他同步，容易引发死锁。如下:\r\n```\r\n//Thread_0\r\nsynchronized(obj1){\r\n    //Thread-0 obj1-->\r\n    synchronized(obj2){\r\n    }\r\n}\r\n\r\n//Thread_1\r\nsynchronized(obj2){\r\n    //Thread-1 obj2-->\r\n    synchronized(obj1){\r\n    }\r\n}\r\n```\r\n\r\n**一个死锁程序**\r\n```\r\npublic class DeadLock {\r\n    public static void main(String[] args) {\r\n        Test t1 = new Test(true);\r\n        Test t2 = new Test(false);\r\n        Thread t11 = new Thread(t1);\r\n        Thread t22 = new Thread(t2);\r\n        t11.start();\r\n        t22.start();\r\n    }\r\n}\r\n\r\nclass Test implements Runnable {\r\n    private boolean flag = false;\r\n\r\n    Test(boolean flag) {\r\n        this.flag = flag;\r\n    }\r\n\r\n    public void run() {\r\n        if (flag) {\r\n            while (true) {\r\n                synchronized (MyLock.LOCKA) {\r\n                    System.out.println(Thread.currentThread().getName() + \"...if...lock a\");\r\n                    synchronized (MyLock.LOCKB) {\r\n                        System.out.println(Thread.currentThread().getName() + \"...if...lock b\");\r\n                    }\r\n                }\r\n            }\r\n\r\n        } else {\r\n            while (true) {\r\n                synchronized (MyLock.LOCKB) {\r\n                    System.out.println(Thread.currentThread().getName() + \"...if...lock b\");\r\n                    synchronized (MyLock.LOCKA) {\r\n                        System.out.println(Thread.currentThread().getName() + \"...if...lock a\");\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n}\r\n\r\nclass MyLock {\r\n    public static final Object LOCKA = new Object();\r\n    public static final Object LOCKB = new Object();\r\n}\r\n```\r\n\r\n## 多线程通讯\r\n\r\n### 生产者消费者问题\r\n\r\n这是多线程中最为常见的案例(重要)\r\n生产者和消费者同时执行，需要多线程；但是任务却不相同，处理的资源是相同的:线程间的通信\r\n\r\n**生产消费实例:**\r\n```\r\npublic class ProduceConsumer {\r\n    public static void main(String[] args) {\r\n        Resource r = new Resource();\r\n        Produce produce = new Produce(r);\r\n        Consumer consumer = new Consumer(r);\r\n        Thread t1 = new Thread(produce);\r\n        Thread t11 = new Thread(produce);\r\n        Thread t2 = new Thread(consumer);\r\n        Thread t22 = new Thread(consumer);\r\n        // 开启多个生产多个消费\r\n        t1.start();\r\n        t11.start();\r\n        t2.start();\r\n        t22.start();\r\n    }\r\n}\r\n\r\n// 资源\r\nclass Resource {\r\n    private String name;\r\n    private int num = 1;\r\n    private boolean flag = false;\r\n\r\n    // 生产\r\n    public synchronized void set(String name) {\r\n        while (flag) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        this.name = name + num;\r\n        num++;\r\n        System.out.println(Thread.currentThread().getName() + \"---生产者---\" + this.name);\r\n        flag = true;\r\n        notifyAll();\r\n    }\r\n\r\n    // 消费\r\n    public synchronized void get() {\r\n        while (!flag) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n        System.out.println(Thread.currentThread().getName() + \"---消费者---\" + this.name);\r\n        flag = false;\r\n        notifyAll();\r\n    }\r\n}\r\n\r\n// 生产者\r\nclass Produce implements Runnable {\r\n    private Resource r;\r\n\r\n    public Produce(Resource r) {\r\n        this.r = r;\r\n    }\r\n\r\n    public void run() {\r\n        for (int i = 50; i < 200; i++) {\r\n            r.set(\"面包\"); // 开始生产\r\n        }\r\n    }\r\n}\r\n\r\n// 消费者\r\nclass Consumer implements Runnable {\r\n    private Resource r;\r\n\r\n    public Consumer(Resource r) {\r\n        this.r = r;\r\n    }\r\n\r\n    public void run() {\r\n        for (int i = 0; i < 200; i++) {\r\n            r.get(); // 开始消费\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**注意:**\r\n\r\n    当多个生产消费的时候，为防止被唤醒的线程没有判断标记，要用while判断标记，而不是if。\r\n    用while时会出现死锁，因为本方唤醒了本方,希望唤醒对方，所以使用notifyAll方法。\r\n\r\n### 等待唤醒机制\r\n\r\n    wait(): 会让线程处于等待状态，将线程临时存进了线程池中\r\n    notify(): 会唤醒线程池中的任意一个等待线程。\r\n    notifyAll(): 会唤醒线程池中所有的等待线程。\r\n\r\n**注意:**\r\n\r\n    这些方法必须使用在同步中，因为必须要标识wait、notify等方法所使用的锁。同一个锁上的notify，只能唤醒该锁上的wait方法。\r\n    这些方法必须标识所属的锁，而锁可以是任意对象，任意对象可以调用的方法必须是Object的方法，所以这些方法定义在Object类中\r\n\r\n## Lock\r\n\r\n在 JDK 1.5 之后，Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。\r\n```\r\nLock l = ...; \r\n     l.lock();\r\n     try {\r\n         // access the resource protected by this lock\r\n     } finally {\r\n         l.unlock(); // 因为必须要释放锁，所以放到finally中\r\n     }\r\n```\r\n因为必须要释放锁，所以lock.lock()放到finally 块中。\r\n\r\n之前用synchronized同步，锁可以是任意对象，并且锁对象和锁的方法是在一块的(Object 对象中的object()、notify()、notifyAll()方法)，而在Lock中把所有的监视器方法封装到Condition 对象中，实现了锁对象和监视器方法(锁方法)的分离，更加的面向对象。\r\n```\r\nLock lock = new ReentrantLock(); // 获得锁对象\r\nCondition con = lock.newCondition(); // 获得lock上的监视器方法对象\r\nlock.lock();    // 得到锁\r\ncon.await();    //  让线程处于等待状态\r\ncon.signal();   // 唤醒任意一个等待的线程\r\ncon.singnalAll(); // 唤醒所有等待的线程\r\nlock.unlock();  // 释放锁\r\n```\r\n\r\n**一个实例**\r\n```\r\nclass BoundedBuffer {\r\n   final Lock lock = new ReentrantLock();\r\n   final Condition notFull  = lock.newCondition(); \r\n   final Condition notEmpty = lock.newCondition(); \r\n\r\n   final Object[] items = new Object[100];\r\n   int putptr, takeptr, count;\r\n\r\n   public void put(Object x) throws InterruptedException {\r\n     lock.lock();\r\n     try {\r\n       while (count == items.length) \r\n         notFull.await();\r\n       items[putptr] = x; \r\n       if (++putptr == items.length) putptr = 0;\r\n       ++count;\r\n       notEmpty.signal();\r\n     } finally {\r\n       lock.unlock();\r\n     }\r\n   }\r\n\r\n   public Object take() throws InterruptedException {\r\n     lock.lock();\r\n     try {\r\n       while (count == 0) \r\n         notEmpty.await();\r\n       Object x = items[takeptr]; \r\n       if (++takeptr == items.length) takeptr = 0;\r\n       --count;\r\n       notFull.signal();\r\n       return x;\r\n     } finally {\r\n       lock.unlock();\r\n     }\r\n   } \r\n }\r\n```\r\n\r\n## 多线程的细节问题\r\n\r\n### 1. sleep 和 wait 方法的异同点\r\n\r\n    - 相同点\r\n        都可以让线程处于冻结状态\r\n    - 不同点\r\n        sleep 必须指定时间；wait 可以指定时间，也可以不指定时间\r\n        sleep 时间到，线程处于临时阻塞或者运行；wait 如果没指定时间，必须通过notify 或者 notifyAll唤醒。\r\n        sleep 不一定非要定义在同步中；wait 必须定义在同步中。\r\n        都定义在同步中\r\n            线程执行到 sleep，不会释放所\r\n            线程执行到 wait，会释放锁\r\n\r\n### 2. 线程如何停止\r\n\r\n所谓线程结束，就是让线程任务代码完成，run方法结束。\r\n\r\n    stop 方法(过时):具有固定的不安全性，用Thread.stop来终止线程，将释放它已经锁定的所有监视器。\r\n    定义循环，控制住循环就行了\r\n    如果目标线程等待很长时间(处于冻结状态)，应用interrupt方法中断该线程(将线程的冻结状态清除，让线程重新获得cpu的执行资格)，并且收到一个InterruptException，在catch块中捕获，在异常处理中改变标记，让循环结束。\r\n\r\n### Interrupt 实例\r\n```\r\npackage thread;\r\n\r\nclass Task implements Runnable {\r\n    boolean flag = true;\r\n    public synchronized void run() {\r\n        while (flag) {\r\n            try {\r\n                wait();\r\n            } catch (InterruptedException e) {\r\n                System.out.println(Thread.currentThread().getName() + \"-->\" + e.toString());\r\n                changeFlag();\r\n            }\r\n            System.out.println(Thread.currentThread().getName());\r\n        }\r\n    }\r\n    public void changeFlag() {\r\n        flag = false;\r\n    }\r\n}\r\npublic class InterruptDemo {\r\n    public static void main(String[] args) {\r\n        Task d = new Task();\r\n        Thread t1 = new Thread(d,\"线程1\");\r\n        Thread t2 = new Thread(d,\"线程2\");\r\n        t1.start();\r\n        t2.start();\r\n        int x = 0;\r\n        while (true) {\r\n            if (++x == 50) {\r\n                // d.changeFlag();\r\n                t1.interrupt();\r\n                t2.interrupt();\r\n                break;\r\n            }\r\n            System.out.println(Thread.currentThread().getName());\r\n        }\r\n        System.out.println(\"over...\");\r\n    }\r\n}\r\n```\r\n## 3. 守护线程\r\n\r\n守护线程，可以理解为后台线程，一般创建的为前台线程，前后台运行线程的时候都是一样的，获取cpu的执行权限。但是结束的时候有些不同，前台线程和后台线程只要run方法结束，线程结束，但是在所有前台线程结束的时候，后台线程无论处于什么状态都会结束，从而进程结束。进程结束依赖的都是前台线程。\r\n\r\n方法: setDaemon(boolean on)\r\n\r\n    该方法必须在线程启动前调用:t.setDaemon(true); t.start; // t 线程设置为了守护线程\r\n    on如果为true，该线程标记为守护线程\r\n\r\n## 4. 线程的优先级\r\n\r\nThread.currentThread.toString: 返回该线程的字符串表示形式，包括『线程名称』、『优先级』、『线程组』\r\n\r\n优先级:\r\n\r\n    用数字标识的0-10；其中默认的初始化优先级是5；\r\n    最明显的三个优先级 : 1，5，10。\r\n    Thread.MAX_PRIORITY 线程可以具有的最高优先级。\r\n    Thread.MIN_PRIORITY 线程可以具有的最低优先级。\r\n    Thread.NORM_PRIORITY 分配给线程的默认优先级。\r\n    得到线程的优先级:getPriority()\r\n    更改线程的优先级:setPriority()\r\n\r\n## 5. 线程组\r\n\r\nThreadGroup: 可以通过Thread构造函数明确新线程对象所属的线程组\r\n\r\n线程组的好处: 可以对多个同组线程，进行统一的操作。默认都属于main线程。\r\n\r\n## 6. join() 和 yield() 方法\r\n\r\n**join() 方法**\r\n\r\n用于临时加入一个运算的线程。让该线程执行完，程序才会执行。\r\n```\r\nDemo d  = new Demo();\r\nThread t1 = new Thread(d);\r\nThread t2 = new Thread(d);\r\nt1.start();\r\ntry{\r\n    // 主线程执行到这里，知道t1要加入执行，主线程释放了执行权(仅仅是释放，至于执行权给谁，有cpu随机决定)\r\n    // 主线程的执行资格处于冻结状态，直至t1线程执行完恢复\r\n    t1.join;\r\n    }catch(InterruptException e){}\r\nt2.start();\r\n```\r\n\r\n**yield() 方法**\r\n\r\n暂停当前正在执行的线程对象，并执行其他线程。\r\n```\r\nclass Demo implements Runnable{\r\n    public void run(){\r\n        for(int i = 0; i < 30; i++){\r\n            // 线程临时停止，将执行权释放，让其他线程有机会获得执行权\r\n            Thread.yield();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n线程中匿名内部类使用\r\n```\r\nRunnable r = new Runnable(){\r\n    public void run (){\r\n        code....\r\n    }    \r\n};\r\nnew Thread(r).start();\r\n\r\nnew Thread(){\r\n    public void run (){\r\n        code....\r\n}      \r\n}.start();\r\n```\r\n\r\n哪一个执行？\r\n```\r\nnew Thread(new Runnable(){\r\n        public void run(){\r\n            System.out.println(\"runnable run\");\r\n        }\r\n    }){\r\n        public void run(){\r\n            System.out.println(\"subthread run\"); // 执行\r\n        }\r\n    }.start();\r\n```\r\n\r\n### 线程池\r\n\r\n自JDK5之后，Java推出了一个并发包：java.util.concurrent，在Java开发中，我们接触到了好多池的技术，String类的对象池、Integer的共享池、连接数据库的连接池、Struts1.3的对象池等等，池的最终目的都是节约资源，以更小的开销做更多的事情，从而提高性能。\r\n\r\n我们的web项目都是部署在服务器上，浏览器端的每一个request就是一个线程，那么服务器需要并发的处理多个请求，就需要线程池技术，下面来看一下Java并发包下如何创建线程池。\r\n\r\n    创建一个可重用固定线程集合的线程池，以共享的无界队列方式来运行这些线程。\r\n```\r\nExecutorService threadPool = Executors.newFixedThreadPool(3);// 创建可以容纳3个线程的线程池\r\n\r\n    创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。\r\n\r\nExecutorService threadPool = Executors.newCachedThreadPool();// 线程池的大小会根据执行的任务数动态分配\r\n\r\n    创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。\r\n\r\nExecutorService threadPool = Executors.newSingleThreadExecutor();\r\n// 创建单个线程的线程池，如果当前线程在执行任务时突然中断，则会创建一个新的线程替代它继续执行任务\r\n\r\n    创建一个可安排在给定延迟后运行命令或者定期地执行的线程池。\r\n\r\nScheduledExecutorService threadPool = Executors.newScheduledThreadPool(3); // 效果类似于Timer定时器\r\n\r\n每种线程池都有不同的使用场景，下面看一下这四种线程池使用起来有什么不同。\r\n```\r\n### FixedThreadPool\r\n```\r\nimport java.util.concurrent.ExecutorService;  \r\nimport java.util.concurrent.Executors;  \r\npublicclass ThreadPoolTest {  \r\npublic static void main(String[] args) {  \r\n    ExecutorService threadPool = Executors.newFixedThreadPool(3);  \r\n    for(int i = 1; i < 5; i++) {  \r\n        final int taskID = i;  \r\n        threadPool.execute(new Runnable() {  \r\n            public void run() {  \r\n                for(int i = 1; i < 5; i++) {  \r\n                    try {  \r\n                        Thread.sleep(20);// 为了测试出效果，让每次任务执行都需要一定时间\r\n                    } catch (InterruptedException e) {  \r\n                        e.printStackTrace();  \r\n                    }  \r\n                        System.out.println(\"第\" + taskID + \"次任务的第\" + i + \"次执行\");  \r\n                    }  \r\n                }  \r\n            });  \r\n        }  \r\n        threadPool.shutdown();// 任务执行完毕，关闭线程池\r\n    }  \r\n}\r\n```\r\n输出结果：\r\n```\r\n第1次任务的第1次执行  \r\n第2次任务的第1次执行  \r\n第3次任务的第1次执行  \r\n第2次任务的第2次执行  \r\n第3次任务的第2次执行  \r\n第1次任务的第2次执行  \r\n第3次任务的第3次执行  \r\n第1次任务的第3次执行  \r\n第2次任务的第3次执行  \r\n第3次任务的第4次执行  \r\n第2次任务的第4次执行  \r\n第1次任务的第4次执行  \r\n第4次任务的第1次执行  \r\n第4次任务的第2次执行  \r\n第4次任务的第3次执行  \r\n第4次任务的第4次执行  \r\n```\r\n上段代码中，创建了一个固定大小的线程池，容量为3，然后循环执行了4个任务，由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4个任务，在FixedThreadPool中，有一个固定大小的池，如果当前需要执行的任务超过了池大小，那么多余的任务等待状态，直到有空闲下来的线程执行任务，而当执行的任务小于池大小，空闲的线程也不会去销毁。\r\n\r\n### CachedThreadPool\r\n\r\n上段代码其它地方不变，将newFixedThreadPool(3)方法换成newCachedThreadPool()方法。\r\n\r\n输出结果：\r\n```\r\n第3次任务的第1次执行  \r\n第4次任务的第1次执行  \r\n第1次任务的第1次执行  \r\n第2次任务的第1次执行  \r\n第4次任务的第2次执行  \r\n第3次任务的第2次执行  \r\n第2次任务的第2次执行  \r\n第1次任务的第2次执行  \r\n第2次任务的第3次执行  \r\n第3次任务的第3次执行  \r\n第1次任务的第3次执行  \r\n第4次任务的第3次执行  \r\n第2次任务的第4次执行  \r\n第4次任务的第4次执行  \r\n第3次任务的第4次执行  \r\n第1次任务的第4次执行  \r\n```\r\n可见，4个任务是交替执行的，CachedThreadPool会创建一个缓存区，将初始化的线程缓存起来，如果线程有可用的，就使用之前创建好的线程，如果没有可用的，就新创建线程，终止并且从缓存中移除已有60秒未被使用的线程。\r\n\r\n### SingleThreadExecutor\r\n\r\n上段代码其它地方不变，将newFixedThreadPool方法换成newSingleThreadExecutor方法。\r\n\r\n输出结果：\r\n```\r\n第1次任务的第1次执行  \r\n第1次任务的第2次执行  \r\n第1次任务的第3次执行  \r\n第1次任务的第4次执行  \r\n第2次任务的第1次执行  \r\n第2次任务的第2次执行  \r\n第2次任务的第3次执行  \r\n第2次任务的第4次执行  \r\n第3次任务的第1次执行  \r\n第3次任务的第2次执行  \r\n第3次任务的第3次执行  \r\n第3次任务的第4次执行  \r\n第4次任务的第1次执行  \r\n第4次任务的第2次执行  \r\n第4次任务的第3次执行  \r\n第4次任务的第4次执行  \r\n```\r\n4个任务是顺序执行的，SingleThreadExecutor得到的是一个单个的线程，这个线程会保证你的任务执行完成，如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。\r\n\r\n### 4.ScheduledThreadPool\r\n```\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.ScheduledExecutorService;\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class ThreadPoolTest {\r\n    public static void main(String[] args) {\r\n        ScheduledExecutorService schedulePool = Executors.newScheduledThreadPool(1);\r\n        // 5秒后执行任务\r\n        schedulePool.schedule(new Runnable() {\r\n            public void run() {\r\n                System.out.println(\"爆炸\");\r\n            }\r\n        }, 5, TimeUnit.SECONDS);\r\n        // 5秒后执行任务，以后每2秒执行一次\r\n        schedulePool.scheduleAtFixedRate(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                System.out.println(\"爆炸\");\r\n            }\r\n        }, 5, 2, TimeUnit.SECONDS);\r\n    }\r\n}\r\n```\r\n`ScheduledThreadPool`可以定时的或延时的执行任务。', '1', '3', '1,8,25', '18', '0', '0', '2018-02-12 13:39:51', '2018-02-12 13:46:53', '1', '1', '1');
INSERT INTO `article` VALUES ('42', '1', '简单排序算法', '<h2 id=\"h2-u5192u6CE1u6392u5E8F\"><a name=\"冒泡排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>冒泡排序</h2><pre><code>public class BubbleSort {\r\n\r\n    public static void bubble(long[] arr){\r\n        long tmp;\r\n        for(int i=0;i&lt;arr.length-1;i++){\r\n            for(int j=arr.length-1;j&lt;i;j--){\r\n                if(arr[j-1]&gt;arr[j]){\r\n                    tmp=arr[j-1];arr[j-1]=arr[j];arr[j]=tmp;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n</code></pre><h2 id=\"h2-u9009u62E9u6392u5E8F\"><a name=\"选择排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>选择排序</h2><blockquote>\r\n<p>从后往前，找到后面小的数字跟前面的数字进行交换</p>\r\n</blockquote>\r\n<pre><code>public class SelectionSort {\r\n\r\n    public static void SelectionSort(long[] arr){\r\n        long tmp;\r\n        int key=0;\r\n        for(int i=0;i&lt;arr.length-1;i++){\r\n            key=i;\r\n            for(int j=i+1;j&lt;arr.length;j++){\r\n                if(arr[key]&gt;arr[j]){\r\n                    key=j;\r\n                }\r\n            }\r\n            if(key!=i){\r\n                tmp=arr[i];arr[i]=arr[key];arr[key]=tmp;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n</code></pre><h2 id=\"h2-u63D2u5165u6392u5E8F\"><a name=\"插入排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>插入排序</h2><blockquote>\r\n<p>从前面依次截取数据进行比较</p>\r\n</blockquote>\r\n<pre><code>public class InsertSort {\r\n    public static void InsertSort(long[] arr ){\r\n        long tmp;\r\n        for (int i=1;i&lt;arr.length;i++){\r\n            for(int j=i;j&lt;0;j--){\r\n                if (arr[j]&lt;arr[j-1]){\r\n                    tmp=arr[j];arr[j]=arr[j-1];arr[j-1]=tmp;\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n</code></pre>', '## 冒泡排序\r\n \r\n```\r\npublic class BubbleSort {\r\n\r\n    public static void bubble(long[] arr){\r\n		long tmp;\r\n		for(int i=0;i<arr.length-1;i++){\r\n			for(int j=arr.length-1;j<i;j--){\r\n				if(arr[j-1]>arr[j]){\r\n					tmp=arr[j-1];arr[j-1]=arr[j];arr[j]=tmp;\r\n				}\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\n```\r\n\r\n## 选择排序\r\n\r\n> 从后往前，找到后面小的数字跟前面的数字进行交换\r\n\r\n```\r\npublic class SelectionSort {\r\n\r\n    public static void SelectionSort(long[] arr){\r\n		long tmp;\r\n		int key=0;\r\n		for(int i=0;i<arr.length-1;i++){\r\n			key=i;\r\n			for(int j=i+1;j<arr.length;j++){\r\n				if(arr[key]>arr[j]){\r\n					key=j;\r\n				}\r\n			}\r\n			if(key!=i){\r\n				tmp=arr[i];arr[i]=arr[key];arr[key]=tmp;\r\n			}\r\n		}\r\n	}\r\n	\r\n}\r\n```\r\n\r\n## 插入排序\r\n\r\n> 从前面依次截取数据进行比较\r\n\r\n```\r\npublic class InsertSort {\r\n    public static void InsertSort(long[] arr ){\r\n		long tmp;\r\n		for (int i=1;i<arr.length;i++){\r\n			for(int j=i;j<0;j--){\r\n				if (arr[j]<arr[j-1]){\r\n					tmp=arr[j];arr[j]=arr[j-1];arr[j-1]=tmp;\r\n				}\r\n			}\r\n		}\r\n		\r\n	}\r\n\r\n}\r\n\r\n```', '10', '11', '2', '9', '0', '0', '2018-02-25 12:15:03', '2018-03-03 19:23:54', '1', '1', '1');
INSERT INTO `article` VALUES ('43', '1', '算法的时间复杂度和空间复杂度', '<blockquote>\r\n<p>常用算法的时间复杂度和空间复杂度</p>\r\n</blockquote>\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>排序算法</th>\r\n<th>最差时间分析</th>\r\n<th>平均时间复杂度</th>\r\n<th>稳定度</th>\r\n<th>空间复杂度</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>冒泡排序</td>\r\n<td>o(n^2)</td>\r\n<td>o(n^2)</td>\r\n<td>稳定</td>\r\n<td>o(1) </td>\r\n</tr>\r\n<tr>\r\n<td>选择排序</td>\r\n<td>o(n^2)</td>\r\n<td>o(n^2)</td>\r\n<td>不稳定</td>\r\n<td>o(1) </td>\r\n</tr>\r\n<tr>\r\n<td>插入排序</td>\r\n<td>o(n^2)</td>\r\n<td>o(n^2)</td>\r\n<td>稳定</td>\r\n<td>o(1) </td>\r\n</tr>\r\n<tr>\r\n<td>快速排序</td>\r\n<td>o(n^2)</td>\r\n<td>o(n*log2^n)</td>\r\n<td>不稳定</td>\r\n<td>(log2^n)~o(n) </td>\r\n</tr>\r\n<tr>\r\n<td>二叉树排序</td>\r\n<td>o(n^2)</td>\r\n<td>o(n*log2^n)</td>\r\n<td>不一定</td>\r\n<td>o(n)</td>\r\n</tr>\r\n<tr>\r\n<td>堆排序</td>\r\n<td>o(n*log2^n)</td>\r\n<td>o(n*log2^n)</td>\r\n<td>不稳定</td>\r\n<td>o(1)</td>\r\n</tr>\r\n<tr>\r\n<td>希尔排序</td>\r\n<td>o</td>\r\n<td>o</td>\r\n<td>不稳定</td>\r\n<td>o(1)</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>o(<span class=\"editormd-tex\">n^2</span>)<br>o(n*log<span class=\"editormd-tex\">2^n</span>)</p>', '> 常用算法的时间复杂度和空间复杂度\r\n\r\n排序算法 | 最差时间分析 | 平均时间复杂度 | 稳定度 | 空间复杂度\r\n------- | ----------- | ------------ | ----- | --------\r\n冒泡排序 | o(n^2) | o(n^2) | 稳定 | o(1) \r\n选择排序 | o(n^2) | o(n^2) | 不稳定 | o(1) \r\n插入排序 | o(n^2) | o(n^2) | 稳定 | o(1) \r\n快速排序 | o(n^2) | o(n*log2^n)  |不稳定 | (log2^n)~o(n) \r\n二叉树排序 | o(n^2) | o(n*log2^n) | 不一定 | o(n)\r\n堆排序 | o(n*log2^n) | o(n*log2^n) | 不稳定 | o(1)\r\n希尔排序 | o | o | 不稳定 | o(1)\r\n\r\no($$n^2$$)\r\no(n*log$$2^n$$)', '10', '11', '2', '12', '0', '0', '2018-02-25 12:17:07', '2018-02-25 14:10:31', '1', '1', '1');
INSERT INTO `article` VALUES ('44', '1', '递归的应用', '<h2 id=\"h2-u9012u5F52u7684u4F7Fu7528\"><a name=\"递归的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>递归的使用</h2><ul>\r\n<li>自己调用自己本身</li></ul>\r\n<h2 id=\"h2-u4E09u89D2u6570u7684u5E94u7528\"><a name=\"三角数的应用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>三角数的应用</h2><p>三角数1,3,6,10,15…n</p>\r\n<p>1、使用循环求解</p>\r\n<pre><code>int total=0;\r\nint n;\r\nwhile(n&gt;0){\r\n    total=total+n;\r\n    n--;\r\n}\r\n</code></pre><p>1、使用递归</p>\r\n<pre><code>public void test(int n){\r\n    if(n==1){\r\n        return 1;\r\n        }else{\r\n        return test(n-1)+n;\r\n    }\r\n}\r\n</code></pre><h2 id=\"h2-u6590u6CE2u90A3u5951u6570u5217u7684u5E94u7528\"><a name=\"斐波那契数列的应用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>斐波那契数列的应用</h2><p>数列的第一项0，第二项为1，第n项为第n-1项加上第n-2项的和。</p>\r\n<pre><code>public class feiboshulie {\r\n    public static int feibo(int n){\r\n        if(n==1){\r\n            return 0;\r\n        }\r\n        if(n==2){\r\n            return 1;\r\n        }else {\r\n            return feibo(n-1)+feibo(n-2);\r\n        }\r\n    }\r\n}\r\n</code></pre><h2 id=\"h2--\"><a name=\"递归的高级应用（汉诺塔）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>递归的高级应用（汉诺塔）</h2><p>topN移动的盘子数，from起始的塔座，inter中间的塔座，to目标塔座</p>\r\n<pre><code>public class HanNuoTa {\r\n    public static void test(int topN,char from,char inter,char to) {\r\n        if (topN==1) {\r\n            System.out.println(&quot;盘子从&quot;+from+&quot;塔座到&quot;+to+&quot;塔座&quot;);\r\n        }else {\r\n            test(topN, from, to, inter);\r\n            System.out.println(&quot;盘子从&quot;+from+&quot;塔座到&quot;+to+&quot;塔座&quot;);\r\n            test(topN, inter, from, to);\r\n        }\r\n    }\r\n}\r\n</code></pre>', '## 递归的使用\r\n\r\n- 自己调用自己本身\r\n\r\n\r\n## 三角数的应用\r\n\r\n三角数1,3,6,10,15...n\r\n\r\n1、使用循环求解\r\n\r\n```\r\nint total=0;\r\nint n;\r\nwhile(n>0){\r\n    total=total+n;\r\n    n--;\r\n}\r\n```\r\n\r\n1、使用递归\r\n\r\n```\r\npublic void test(int n){\r\n    if(n==1){\r\n        return 1;\r\n        }else{\r\n        return test(n-1)+n;\r\n    }\r\n}  \r\n```\r\n\r\n## 斐波那契数列的应用\r\n\r\n数列的第一项0，第二项为1，第n项为第n-1项加上第n-2项的和。\r\n\r\n```\r\npublic class feiboshulie {\r\n    public static int feibo(int n){\r\n		if(n==1){\r\n			return 0;\r\n		}\r\n		if(n==2){\r\n			return 1;\r\n		}else {\r\n			return feibo(n-1)+feibo(n-2);\r\n		}\r\n	}\r\n}\r\n\r\n```\r\n\r\n## 递归的高级应用（汉诺塔）\r\n\r\ntopN移动的盘子数，from起始的塔座，inter中间的塔座，to目标塔座\r\n\r\n```\r\npublic class HanNuoTa {\r\n    public static void test(int topN,char from,char inter,char to) {\r\n		if (topN==1) {\r\n			System.out.println(\"盘子从\"+from+\"塔座到\"+to+\"塔座\");\r\n		}else {\r\n			test(topN, from, to, inter);\r\n			System.out.println(\"盘子从\"+from+\"塔座到\"+to+\"塔座\");\r\n			test(topN, inter, from, to);\r\n		}\r\n	}\r\n}\r\n\r\n```', '10', '11', '2,3', '16', '0', '1', '2018-02-25 12:18:03', '2018-03-03 19:24:25', '1', '1', '10');
INSERT INTO `article` VALUES ('45', '1', '快速排序算法', '<blockquote>\r\n<p>1、将数组分成两个子数组，然后使用递归调用自身为每个子数组排序。<br>2、设置关键字，比关键字小的为一组，比关键字大的为一组。</p>\r\n</blockquote>\r\n<ul>\r\n<li>设置最左边的为关键字</li></ul>\r\n<h2 id=\"h2-u5FEBu901Fu6392u5E8F\"><a name=\"快速排序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>快速排序</h2><pre><code>public class QuickSort {\r\n    public static int QuickSort(int[] arr,int left,int right){\r\n        //选择最左边的数为关键字\r\n        int key=arr[left];\r\n        while(true){\r\n            //从右开始，找到比关键字小的数放到左边\r\n            while(left&lt;right &amp;&amp; arr[right]&gt;=key)\r\n                right--;\r\n            arr[left]=arr[right];\r\n            //找到比关键字大的数移动到右边\r\n            while(left&lt;right &amp;&amp; arr[left]&lt;=key)\r\n                left++;\r\n            arr[right]=arr[left];\r\n            }\r\n        //关键字到了最终位置\r\n        arr[left] = key;\r\n        //返回关键字的位置\r\n        return left;\r\n\r\n    }\r\n    public void sort(int[] arr,int left,int right){\r\n        if(left&lt;right){\r\n            int result=QuickSort(arr, left, right);\r\n            sort(arr,left,result-1);\r\n            sort(arr,result+1,right);\r\n        }\r\n    }\r\n}\r\n</code></pre>', '> \r\n1、将数组分成两个子数组，然后使用递归调用自身为每个子数组排序。\r\n2、设置关键字，比关键字小的为一组，比关键字大的为一组。\r\n\r\n- 设置最左边的为关键字\r\n\r\n## 快速排序\r\n\r\n```\r\npublic class QuickSort {\r\n    public static int QuickSort(int[] arr,int left,int right){\r\n		//选择最左边的数为关键字\r\n		int key=arr[left];\r\n		while(true){\r\n			//从右开始，找到比关键字小的数放到左边\r\n			while(left<right && arr[right]>=key)\r\n				right--;\r\n			arr[left]=arr[right];\r\n			//找到比关键字大的数移动到右边\r\n			while(left<right && arr[left]<=key)\r\n				left++;\r\n			arr[right]=arr[left];\r\n			}\r\n		//关键字到了最终位置\r\n		arr[left] = key;\r\n		//返回关键字的位置\r\n		return left;\r\n\r\n	}\r\n	public void sort(int[] arr,int left,int right){\r\n		if(left<right){\r\n			int result=QuickSort(arr, left, right);\r\n			sort(arr,left,result-1);\r\n			sort(arr,result+1,right);\r\n		}\r\n	}\r\n}\r\n```', '10', '11', '2', '12', '0', '0', '2018-02-25 16:27:51', '2018-02-28 12:26:34', '1', '1', '1');
INSERT INTO `article` VALUES ('46', '1', '二叉树的遍历', '<h2 id=\"h2-u4E8Cu53C9u6811u7684u904Du5386\"><a name=\"二叉树的遍历\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>二叉树的遍历</h2><p>二叉树的遍历有三种方式，如下：</p>\r\n<p>（1）前序遍历（DLR），首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。</p>\r\n<p>（2）中序遍历（LDR），首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。</p>\r\n<p>（3）后序遍历（LRD），首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。</p>\r\n<ul>\r\n<li>举个例子，看下图</li></ul>\r\n<p><img src=\"https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018/2/1.jpg\" alt=\"\"></p>\r\n<p>先序遍历：ABCDEFGHK</p>\r\n<p>中序遍历：BDCAEHGKF</p>\r\n<p>后序遍历：DCBHKGFEA</p>\r\n<ul>\r\n<li>以中序遍历为例：</li></ul>\r\n<p>中序遍历的规则是【左根右】，我们从root节点A看起；</p>\r\n<p>此时A是根节点，遍历A的左子树；</p>\r\n<p>A的左子树存在，找到B，此时B看做根节点，遍历B的左子树；</p>\r\n<p>B的左子树不存在，返回B，根据【左根右】的遍历规则，<code>记录B</code>，遍历B的右子树；</p>\r\n<p>B的右子树存在，找到C，此时C看做根节点，遍历C的左子树；</p>\r\n<p>C的左子树存在，找到D，由于D是叶子节点，无左子树，<code>记录D</code>，无右子树，返回C，根据【左根右】的遍历规则，<code>记录C</code>，遍历C的右子树；</p>\r\n<p>C的右子树不存在，返回B，B的右子树遍历完，返回A；</p>\r\n<p>至此，A的左子树遍历完毕，根据【左根右】的遍历规则，<code>记录A</code>，遍历A的右子树；</p>\r\n<p>A的右子树存在，找到E，此时E看做根节点，遍历E的左子树；</p>\r\n<p>E的左子树不存在，返回E，根据【左根右】的遍历规则，<code>记录E</code>，遍历E的右子树；</p>\r\n<p>E的右子树存在，找到F，此时F看做根节点，遍历F的左子树；</p>\r\n<p>F的左子树存在，找到G，此时G看做根节点，遍历G的左子树；</p>\r\n<p>G的左子树存在，找到H，由于H是叶子节点，无左子树，<code>记录H</code>，无右子树，返回G，根据【左根右】的遍历规则，<code>记录G</code>，遍历G的右子树；</p>\r\n<p>G的右子树存在，找到K，由于K是叶子节点，无左子树，<code>记录K</code>，无右子树，返回G，根据【左根右】的遍历规则，<code>记录F</code>，遍历F的右子树；</p>\r\n<p>F的右子树不存在，返回F，E的右子树遍历完毕，返回A；</p>\r\n<p>至此，A的右子树也遍历完毕；</p>\r\n<p>最终我们得到上图的中序遍历为BDCAEHGKF，无非是按照遍历规则来的</p>', '##二叉树的遍历\r\n\r\n二叉树的遍历有三种方式，如下：\r\n\r\n（1）前序遍历（DLR），首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。\r\n\r\n（2）中序遍历（LDR），首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。\r\n\r\n（3）后序遍历（LRD），首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。\r\n\r\n- 举个例子，看下图\r\n\r\n![](https://raw.githubusercontent.com/wjw0315/blog_gitalk/master/2018/2/1.jpg)\r\n\r\n先序遍历：ABCDEFGHK\r\n\r\n中序遍历：BDCAEHGKF\r\n\r\n后序遍历：DCBHKGFEA\r\n\r\n- 以中序遍历为例：\r\n\r\n中序遍历的规则是【左根右】，我们从root节点A看起；\r\n\r\n此时A是根节点，遍历A的左子树；\r\n\r\nA的左子树存在，找到B，此时B看做根节点，遍历B的左子树；\r\n\r\nB的左子树不存在，返回B，根据【左根右】的遍历规则，`记录B`，遍历B的右子树；\r\n\r\nB的右子树存在，找到C，此时C看做根节点，遍历C的左子树；\r\n\r\nC的左子树存在，找到D，由于D是叶子节点，无左子树，`记录D`，无右子树，返回C，根据【左根右】的遍历规则，`记录C`，遍历C的右子树；\r\n\r\nC的右子树不存在，返回B，B的右子树遍历完，返回A；\r\n\r\n至此，A的左子树遍历完毕，根据【左根右】的遍历规则，`记录A`，遍历A的右子树；\r\n\r\nA的右子树存在，找到E，此时E看做根节点，遍历E的左子树；\r\n\r\nE的左子树不存在，返回E，根据【左根右】的遍历规则，`记录E`，遍历E的右子树；\r\n\r\nE的右子树存在，找到F，此时F看做根节点，遍历F的左子树；\r\n\r\nF的左子树存在，找到G，此时G看做根节点，遍历G的左子树；\r\n\r\nG的左子树存在，找到H，由于H是叶子节点，无左子树，`记录H`，无右子树，返回G，根据【左根右】的遍历规则，`记录G`，遍历G的右子树；\r\n\r\nG的右子树存在，找到K，由于K是叶子节点，无左子树，`记录K`，无右子树，返回G，根据【左根右】的遍历规则，`记录F`，遍历F的右子树；\r\n\r\nF的右子树不存在，返回F，E的右子树遍历完毕，返回A；\r\n\r\n至此，A的右子树也遍历完毕；\r\n\r\n\r\n最终我们得到上图的中序遍历为BDCAEHGKF，无非是按照遍历规则来的', '10', '11', '2,3', '9', '0', '0', '2018-02-26 11:57:44', '2018-03-01 15:43:20', '1', '1', '1');
INSERT INTO `article` VALUES ('47', '1', 'java线程问题', '<h2 id=\"h2-1-t1-t2-\"><a name=\"1\\假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1\\假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（）</h2><pre><code>public static void main(String[]args)throws Exception {\r\n    final Object obj = new Object();\r\n    Thread t1 = new Thread() {\r\n        public void run() {\r\n            synchronized (obj) {\r\n                try {\r\n                    obj.wait();\r\n                    System.out.println(&quot;Thread 1 wake up.&quot;);\r\n                } catch (InterruptedException e) {\r\n                }\r\n            }\r\n        }\r\n    };\r\n    t1.start();\r\n    Thread.sleep(1000);//We assume thread 1 must start up within 1 sec.\r\n    Thread t2 = new Thread() {\r\n        public void run() {\r\n            synchronized (obj) {\r\n                obj.notifyAll();\r\n                System.out.println(&quot;Thread 2 sent notify.&quot;);\r\n            }\r\n        }\r\n    };\r\n    t2.start();\r\n}\r\n</code></pre><p>A\\ Thread 1 wake up<br>Thread 2 sent notify.</p>\r\n<p>B\\ Thread 2 sent notify.<br>Thread 1 wake up</p>\r\n<p>C\\ A、B皆有可能</p>\r\n<p>D\\ 程序无输出卡死</p>\r\n<p><code>正确答案: B</code></p>\r\n<ul>\r\n<li>解析：</li></ul>\r\n<p>wait()执行后进入线程等待，知道其他线程使用notify()方法将其唤醒。</p>\r\n<pre><code>obj.notifyAll();\r\nSystem.out.println(&quot;Thread 2 sent notify.&quot;);\r\n</code></pre><p>这两句是在同步代码块里的，即使notifyAll()了也会先执行完同步代码块的全部代码再释放锁</p>\r\n<h2 id=\"h2-2-\"><a name=\"2\\\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2\\</h2>', '## 1\\假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（） \r\n\r\n```\r\npublic static void main(String[]args)throws Exception {\r\n    final Object obj = new Object();\r\n    Thread t1 = new Thread() {\r\n        public void run() {\r\n            synchronized (obj) {\r\n                try {\r\n                    obj.wait();\r\n                    System.out.println(\"Thread 1 wake up.\");\r\n                } catch (InterruptedException e) {\r\n                }\r\n            }\r\n        }\r\n    };\r\n    t1.start();\r\n    Thread.sleep(1000);//We assume thread 1 must start up within 1 sec.\r\n    Thread t2 = new Thread() {\r\n        public void run() {\r\n            synchronized (obj) {\r\n                obj.notifyAll();\r\n                System.out.println(\"Thread 2 sent notify.\");\r\n            }\r\n        }\r\n    };\r\n    t2.start();\r\n}\r\n```\r\n\r\n\r\n\r\nA\\ Thread 1 wake up\r\nThread 2 sent notify.\r\n\r\nB\\ Thread 2 sent notify.\r\nThread 1 wake up\r\n\r\nC\\ A、B皆有可能\r\n\r\nD\\ 程序无输出卡死\r\n\r\n\r\n`正确答案: B `\r\n\r\n- 解析：\r\n\r\nwait()执行后进入线程等待，知道其他线程使用notify()方法将其唤醒。\r\n```\r\nobj.notifyAll();\r\nSystem.out.println(\"Thread 2 sent notify.\");\r\n```\r\n这两句是在同步代码块里的，即使notifyAll()了也会先执行完同步代码块的全部代码再释放锁\r\n\r\n## 2\\', '1', '3', '1,2,3,8,25', '6', '0', '0', '2018-03-01 17:34:28', '2018-03-05 12:11:39', '1', '1', '1');
INSERT INTO `article` VALUES ('48', '1', 'java基础', '<h2 id=\"h2-1-jdk1-8-java-\"><a name=\"1、jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是？</h2><p>A 抽象类可以有构造方法，接口中不能有构造方法</p>\r\n<p>B 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法</p>\r\n<p>C 一个类可以实现多个接口，但只能继承一个抽象类</p>\r\n<p>D 接口中可以有普通成员变量，抽象类中没有普通成员变量</p>\r\n<p>正确答案: B D</p>\r\n<ul>\r\n<li>解析：</li></ul>\r\n<p><strong>抽象类</strong><br>特点:<br>1.抽象类中可以构造方法<br>2.抽象类中可以存在普通属性，方法，静态属性和方法。<br>3.抽象类中可以存在抽象方法。<br>4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。<br>5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。<br><strong>接口</strong><br>1.在接口中只有方法的声明，没有方法体。<br>2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上<br>public static final<br>3.在接口中的方法，永远都被public来修饰。<br>4.接口中没有构造方法，也不能实例化接口的对象。<br>5.接口可以实现多继承<br>6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。<br>7、在jdk1.8中接口可以有default、static方法。</p>\r\n<h2 id=\"h2-2-\"><a name=\"2、下列说法错误的有（ ）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、下列说法错误的有（ ）</h2><p>A 在类方法中可用this来调用本类的类方法</p>\r\n<p>B 在类方法中调用本类的类方法时可直接调用</p>\r\n<p>C 在类方法中只能调用本类中的类方法</p>\r\n<p>D 在类方法中绝对不能调用实例方法</p>\r\n<p><code>正确答案: A C D</code></p>\r\n<ul>\r\n<li>解析：</li></ul>\r\n<p>A:类方法是指类中被static修饰的方法，无this指针。<br>C：类方法是可以调用其他类的static方法的。<br>D:可以在类方法中生成实例对象再调用实例方法</p>\r\n<h2 id=\"h2-3-\"><a name=\"3、结果是什么？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3、结果是什么？</h2><pre><code>public class Test\r\n{\r\n    static boolean foo(char c)\r\n    {\r\n        System.out.print(c);\r\n        return true;\r\n    }\r\n    public static void main( String[] argv )\r\n    {\r\n        int i = 0;\r\n        for ( foo(&#39;A&#39;); foo(&#39;B&#39;) &amp;&amp; (i &lt; 2); foo(&#39;C&#39;))\r\n        {\r\n            i++ ;\r\n            foo(&#39;D&#39;);\r\n        }\r\n    }\r\n}\r\n</code></pre><p><code>结果为 ABDCBDCB</code></p>\r\n<ul>\r\n<li><p>解析：</p>\r\n<p>for(条件1;条件2;条件3) {<br>  //语句<br>}<br>执行顺序是条件1-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2-&gt;语句-&gt;条件3-&gt;条件2……..<br>如果条件2为true，则一直执行。如果条件2位false，则for循环结束</p>\r\n</li></ul>\r\n<h2 id=\"h2-4-\"><a name=\"4、去除重发字符（编程题）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4、去除重发字符（编程题）</h2><pre><code>public static void main(String[] args) {\r\n        // TODO Auto-generated method stub\r\n          String str = &quot;adsfagaeri&quot;;\r\n          System.out.println(&quot; 方法一：普通方法 &quot;); \r\n          char[] cy = str.toCharArray(); \r\n           String temp = &quot;&quot;; \r\n            for (int i = 0; i &lt; cy.length; i++) { \r\n                  if (temp.indexOf(cy[i]) == -1) { \r\n                  temp += cy[i]; \r\n                  } \r\n                } \r\n\r\n        System.out.println(&quot;  去除重复字符后： &quot; + temp);\r\n    }\r\n</code></pre>', '## 1、jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是？\r\n\r\n\r\nA 抽象类可以有构造方法，接口中不能有构造方法\r\n\r\nB 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法\r\n\r\nC 一个类可以实现多个接口，但只能继承一个抽象类\r\n\r\nD 接口中可以有普通成员变量，抽象类中没有普通成员变量\r\n\r\n正确答案: B D\r\n\r\n- 解析：\r\n\r\n\r\n**抽象类**\r\n特点:\r\n1.抽象类中可以构造方法\r\n2.抽象类中可以存在普通属性，方法，静态属性和方法。\r\n3.抽象类中可以存在抽象方法。\r\n4.如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。\r\n5.抽象类中的抽象方法，需要有子类实现，如果子类不实现，则子类也需要定义为抽象的。\r\n**接口**\r\n1.在接口中只有方法的声明，没有方法体。\r\n2.在接口中只有常量，因为定义的变量，在编译的时候都会默认加上\r\npublic static final \r\n3.在接口中的方法，永远都被public来修饰。\r\n4.接口中没有构造方法，也不能实例化接口的对象。\r\n5.接口可以实现多继承\r\n6.接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。\r\n7、在jdk1.8中接口可以有default、static方法。\r\n\r\n## 2、下列说法错误的有（ ）\r\n\r\n\r\nA 在类方法中可用this来调用本类的类方法\r\n\r\nB 在类方法中调用本类的类方法时可直接调用\r\n\r\nC 在类方法中只能调用本类中的类方法\r\n\r\nD 在类方法中绝对不能调用实例方法\r\n\r\n`正确答案: A C D `\r\n\r\n- 解析：\r\n\r\nA:类方法是指类中被static修饰的方法，无this指针。\r\nC：类方法是可以调用其他类的static方法的。\r\nD:可以在类方法中生成实例对象再调用实例方法\r\n\r\n## 3、结果是什么？\r\n```\r\npublic class Test\r\n{\r\n    static boolean foo(char c)\r\n    {\r\n        System.out.print(c);\r\n        return true;\r\n    }\r\n    public static void main( String[] argv )\r\n    {\r\n        int i = 0;\r\n        for ( foo(\'A\'); foo(\'B\') && (i < 2); foo(\'C\'))\r\n        {\r\n            i++ ;\r\n            foo(\'D\');\r\n        }\r\n    }\r\n}\r\n```\r\n`结果为 ABDCBDCB`\r\n\r\n- 解析：\r\n\r\n for(条件1;条件2;条件3) {\r\n    //语句\r\n}\r\n执行顺序是条件1->条件2->语句->条件3->条件2->语句->条件3->条件2........\r\n如果条件2为true，则一直执行。如果条件2位false，则for循环结束\r\n\r\n## 4、去除重发字符（编程题）\r\n\r\n```\r\npublic static void main(String[] args) {\r\n		// TODO Auto-generated method stub\r\n		  String str = \"adsfagaeri\";\r\n		  System.out.println(\" 方法一：普通方法 \"); \r\n		  char[] cy = str.toCharArray(); \r\n		   String temp = \"\"; \r\n		    for (int i = 0; i < cy.length; i++) { \r\n				  if (temp.indexOf(cy[i]) == -1) { \r\n				  temp += cy[i]; \r\n				  } \r\n				} \r\n\r\n		System.out.println(\"  去除重复字符后： \" + temp);\r\n	}\r\n```', '1', '2', '1,8', '11', '0', '0', '2018-03-01 17:35:07', '2018-03-05 12:11:23', '1', '1', '1');
INSERT INTO `article` VALUES ('49', '1', 'java 设计模式', '<h2 id=\"h2-1-\"><a name=\"1、结构型模式中最体现扩展性的模式是（）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、结构型模式中最体现扩展性的模式是（）</h2><p>A\\装饰模式</p>\r\n<p>B\\合成模式</p>\r\n<p>C\\桥接模式</p>\r\n<p>D\\适配器</p>\r\n<p><code>正确答案: A</code></p>\r\n<ul>\r\n<li><p>解析：</p>\r\n<p>1.适配器模式 Adapter<br>适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。</p>\r\n</li></ul>\r\n<p>2.桥接模式 Bridge<br>  桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。</p>\r\n<p>3.组合模式 Composite<br>  组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>\r\n<p>4.装饰模式 Decorator<br>装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。 装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。</p>\r\n<p>5.外观模式 Facade<br> 外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。</p>\r\n<p>6.享元模式 Flyweight<br> 享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。.<br>  享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。</p>\r\n<p>7.代理模式 Proxy<br>为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。</p>\r\n<h2 id=\"h2-2-\"><a name=\"2\\单例模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2\\单例模式</h2><pre><code>//饿汉式\r\npublic class SingletorTest {\r\n    private SingletorTest(){}\r\n    private static final SingletorTest singletor=new SingletorTest();\r\n    public static SingletorTest getInstance(){\r\n        return singletor;\r\n\r\n    }\r\n}\r\n</code></pre><pre><code>//双重锁\r\nclass Singletor {\r\n    private static volatile Singletor singletor=null;\r\n    private Singletor(){}\r\n    public static Singletor getInstance(){\r\n        if(singletor==null){\r\n            synchronized(Singletor.class){\r\n                if(singletor==null){\r\n                    singletor= new Singletor();\r\n                }\r\n            }\r\n        }\r\n        return singletor;    \r\n    }\r\n}\r\n</code></pre><pre><code>//懒汉式\r\nclass Singletor1{\r\n    private Singletor1(){}\r\n    private static Singletor1 singletor=null;\r\n    public static Singletor1 getInstance(){\r\n        if(singletor==null){\r\n            singletor=new Singletor1();\r\n        }\r\n        return singletor;\r\n\r\n    }\r\n}\r\n</code></pre>', '## 1、结构型模式中最体现扩展性的模式是（）\r\n\r\nA\\装饰模式\r\n\r\nB\\合成模式\r\n\r\nC\\桥接模式\r\n\r\nD\\适配器\r\n\r\n`正确答案: A  `\r\n\r\n- 解析：\r\n\r\n 1.适配器模式 Adapter\r\n  适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\r\n  两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。\r\n  \r\n2.桥接模式 Bridge\r\n  桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。\r\n  \r\n3.组合模式 Composite\r\n  组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。\r\n  \r\n4.装饰模式 Decorator\r\n装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。 装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。\r\n\r\n5.外观模式 Facade\r\n 外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\r\n外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。\r\n\r\n6.享元模式 Flyweight\r\n 享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。.\r\n  享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。\r\n  \r\n7.代理模式 Proxy   \r\n为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。\r\n\r\n## 2\\单例模式\r\n\r\n```\r\n//饿汉式\r\npublic class SingletorTest {\r\n	private SingletorTest(){}\r\n	private static final SingletorTest singletor=new SingletorTest();\r\n	public static SingletorTest getInstance(){\r\n		return singletor;\r\n		\r\n	}\r\n}\r\n```\r\n```\r\n//双重锁\r\nclass Singletor {\r\n	private static volatile Singletor singletor=null;\r\n	private Singletor(){}\r\n	public static Singletor getInstance(){\r\n		if(singletor==null){\r\n			synchronized(Singletor.class){\r\n				if(singletor==null){\r\n					singletor= new Singletor();\r\n				}\r\n			}\r\n		}\r\n		return singletor;	\r\n	}\r\n}\r\n```\r\n```\r\n//懒汉式\r\nclass Singletor1{\r\n	private Singletor1(){}\r\n	private static Singletor1 singletor=null;\r\n	public static Singletor1 getInstance(){\r\n		if(singletor==null){\r\n			singletor=new Singletor1();\r\n		}\r\n		return singletor;\r\n		\r\n	}\r\n}\r\n```', '1', '3', '1,8,15', '20', '0', '0', '2018-03-01 17:47:33', '2018-03-05 12:11:07', '1', '1', '1');
INSERT INTO `article` VALUES ('50', '1', 'jsp基础', '', '## 1、关于JSP生命周期的叙述，下列哪些为真?\r\n\r\n\r\n\r\nA JSP会先解释成Servlet源文件，然后编译成Servlet类文件\r\n\r\nB 每当用户端运行JSP时，jsp init()方法都会运行一次\r\n\r\nC 每当用户端运行JSP时，jsp service()方法都会运行一次\r\n\r\nD 每当用户端运行JSP时，jsp destroy()方法都会运行一次\r\n\r\n`正确答案: A C `\r\n\r\n- 解析：\r\n\r\nB：init方法：负责初始化Servlet对象。在Servlet的整个生命周期类，init（）方法只被调用一次。\r\nD：destroy方法：销毁Servlet对象，释放占用的资源，Servlet要被卸载时调用\r\n\r\n## 2、从以下哪一个选项中可以获得Servlet的初始化参数?\r\n\r\n\r\n\r\nA Servlet\r\n\r\nB ServletContext\r\n\r\nC ServletConfig\r\n\r\nD GenericServlet\r\n\r\n`正确答案 C`\r\n\r\n- 解析：\r\n\r\n **ServletContext对象**：servlet容器在启动时会加载web应用，并为每个web应用创建唯一的servlet context对象，可以把ServletContext看成是一个Web应用的服务器端组件的共享内存，在ServletContext中可以存放共享数据。ServletContext对象是真正的一个全局对象，凡是web容器中的Servlet都可以访问。\r\n   整个web应用只有唯一的一个ServletContext对象\r\n**servletConfig对象：**用于封装servlet的配置信息。从一个servlet被实例化后，对任何客户端在任何时候访问有效，但仅对servlet自身有效，一个servlet的ServletConfig对象不能被另一个servlet访问。', '1', '2', '1,8,18,19', '7', '0', '0', '2018-03-01 19:16:42', '2018-03-05 12:10:52', '1', '1', '2');
INSERT INTO `article` VALUES ('51', '1', '深入浅析Java中Static Class及静态内部类和非静态内部类的不同', '<p>java中的类可以是static吗？答案是可以。在java中我们可以有静态实例变量、静态方法、静态块。类也可以是静态的。</p>\r\n<p>java允许我们在一个类里面定义静态类。比如内部类（nested class）。把nested class封闭起来的类叫外部类。在java中，我们不能用static修饰顶级类（top level class）。只有内部类可以为static。</p>\r\n<pre><code> **静态内部类和非静态内部类之间到底有什么不同呢？下面是两者间主要的不同。**\r\n\r\n（1）内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。\r\n\r\n（2）非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。\r\n\r\n（3）一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。\r\n</code></pre><p>基于上面的讨论，我们可以通过这些特性让编程更简单、有效。</p>\r\n<pre><code>/* 下面程序演示如何在java中创建静态内部类和非静态内部类 */\r\nclass OuterClass{\r\n  private static String msg = &quot;GeeksForGeeks&quot;;\r\n  // 静态内部类\r\n  public static class NestedStaticClass{\r\n    // 静态内部类只能访问外部类的静态成员\r\n    public void printMessage() {\r\n     // 试着将msg改成非静态的，这将导致编译错误 \r\n     System.out.println(&quot;Message from nested static class: &quot; + msg); \r\n    }\r\n  }\r\n  // 非静态内部类\r\n  public class InnerClass{\r\n    // 不管是静态方法还是非静态方法都可以在非静态内部类中访问\r\n    public void display(){\r\n     System.out.println(&quot;Message from non-static nested class: &quot;+ msg);\r\n    }\r\n  }\r\n} \r\nclass Main\r\n{\r\n  // 怎么创建静态内部类和非静态内部类的实例\r\n  public static void main(String args[]){\r\n    // 创建静态内部类的实例\r\n    OuterClass.NestedStaticClass printer = new OuterClass.NestedStaticClass();\r\n    // 创建静态内部类的非静态方法\r\n    printer.printMessage();  \r\n    // 为了创建非静态内部类，我们需要外部类的实例\r\n    OuterClass outer = new OuterClass();    \r\n    OuterClass.InnerClass inner = outer.new InnerClass();\r\n    // 调用非静态内部类的非静态方法\r\n    inner.display();\r\n    // 我们也可以结合以上步骤，一步创建的内部类实例\r\n    OuterClass.InnerClass innerObject = new OuterClass().new InnerClass();\r\n    // 同样我们现在可以调用内部类方法\r\n    innerObject.display();\r\n  }\r\n}\r\n</code></pre>', 'java中的类可以是static吗？答案是可以。在java中我们可以有静态实例变量、静态方法、静态块。类也可以是静态的。\r\n\r\njava允许我们在一个类里面定义静态类。比如内部类（nested class）。把nested class封闭起来的类叫外部类。在java中，我们不能用static修饰顶级类（top level class）。只有内部类可以为static。\r\n\r\n     **静态内部类和非静态内部类之间到底有什么不同呢？下面是两者间主要的不同。**\r\n\r\n    （1）内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。\r\n\r\n    （2）非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。\r\n\r\n    （3）一个非静态内部类不能脱离外部类实体被创建，一个非静态内部类可以访问外部类的数据和方法，因为他就在外部类里面。\r\n\r\n基于上面的讨论，我们可以通过这些特性让编程更简单、有效。\r\n```\r\n/* 下面程序演示如何在java中创建静态内部类和非静态内部类 */\r\nclass OuterClass{\r\n  private static String msg = \"GeeksForGeeks\";\r\n  // 静态内部类\r\n  public static class NestedStaticClass{\r\n    // 静态内部类只能访问外部类的静态成员\r\n    public void printMessage() {\r\n     // 试着将msg改成非静态的，这将导致编译错误 \r\n     System.out.println(\"Message from nested static class: \" + msg); \r\n    }\r\n  }\r\n  // 非静态内部类\r\n  public class InnerClass{\r\n    // 不管是静态方法还是非静态方法都可以在非静态内部类中访问\r\n    public void display(){\r\n     System.out.println(\"Message from non-static nested class: \"+ msg);\r\n    }\r\n  }\r\n} \r\nclass Main\r\n{\r\n  // 怎么创建静态内部类和非静态内部类的实例\r\n  public static void main(String args[]){\r\n    // 创建静态内部类的实例\r\n    OuterClass.NestedStaticClass printer = new OuterClass.NestedStaticClass();\r\n    // 创建静态内部类的非静态方法\r\n    printer.printMessage();  \r\n    // 为了创建非静态内部类，我们需要外部类的实例\r\n    OuterClass outer = new OuterClass();    \r\n    OuterClass.InnerClass inner = outer.new InnerClass();\r\n    // 调用非静态内部类的非静态方法\r\n    inner.display();\r\n    // 我们也可以结合以上步骤，一步创建的内部类实例\r\n    OuterClass.InnerClass innerObject = new OuterClass().new InnerClass();\r\n    // 同样我们现在可以调用内部类方法\r\n    innerObject.display();\r\n  }\r\n}\r\n```', '1', '2', '1', '9', '0', '0', '2018-03-02 17:03:55', '2018-03-02 21:50:21', '1', '1', '1');

-- ----------------------------
-- Table structure for `category`
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category` (
  `category_id` int(5) unsigned NOT NULL AUTO_INCREMENT,
  `category_pid` int(5) DEFAULT NULL,
  `category_name` varchar(50) DEFAULT NULL,
  `category_description` varchar(255) DEFAULT NULL,
  `category_order` int(2) unsigned DEFAULT '1',
  `category_icon` varchar(20) DEFAULT NULL,
  `category_status` int(2) unsigned DEFAULT '1',
  PRIMARY KEY (`category_id`),
  UNIQUE KEY `category_name` (`category_name`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES ('1', '0', 'Java', 'Java语言', '1', 'fa fa-coffee', '1');
INSERT INTO `category` VALUES ('2', '1', 'Java基础', '', '1', '', '1');
INSERT INTO `category` VALUES ('3', '1', 'Java进阶', '', '1', '', '1');
INSERT INTO `category` VALUES ('8', '1', 'JavaWeb', '', '1', '', '1');
INSERT INTO `category` VALUES ('9', '1', 'Java框架', '', '1', '', '1');
INSERT INTO `category` VALUES ('10', '0', '计算机科学', '', '1', 'fa fa-cubes', '1');
INSERT INTO `category` VALUES ('11', '10', '数据结构和算法', '', '1', '', '1');
INSERT INTO `category` VALUES ('12', '10', '操作系统', '', '1', '', '1');
INSERT INTO `category` VALUES ('13', '10', '数据库', '', '1', '', '1');
INSERT INTO `category` VALUES ('14', '10', '计算机网络', '', '1', '', '1');
INSERT INTO `category` VALUES ('15', '0', '其他技术', '', '1', 'fa-snowflake-o fa', '1');
INSERT INTO `category` VALUES ('16', '15', '消息服务', '', '1', '', '1');
INSERT INTO `category` VALUES ('17', '15', '缓存服务', '', '1', '', '1');
INSERT INTO `category` VALUES ('18', '15', '负载均衡', '', '1', '', '1');
INSERT INTO `category` VALUES ('19', '1', 'blog进程', '', '1', '', '1');
INSERT INTO `category` VALUES ('20', '15', '实用工具教程', '', '1', '', '1');

-- ----------------------------
-- Table structure for `comment`
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `comment_id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `comment_pid` int(10) unsigned DEFAULT '0',
  `comment_pname` varchar(255) DEFAULT NULL,
  `comment_article_id` int(10) unsigned DEFAULT NULL,
  `comment_author_name` varchar(50) DEFAULT NULL,
  `comment_author_email` varchar(50) DEFAULT NULL,
  `comment_author_url` varchar(50) DEFAULT NULL,
  `comment_content` varchar(1000) DEFAULT NULL,
  `comment_agent` varchar(200) DEFAULT NULL,
  `comment_ip` varchar(50) DEFAULT NULL,
  `comment_create_time` datetime DEFAULT NULL,
  `comment_role` int(2) DEFAULT NULL,
  `comment_status` int(2) unsigned DEFAULT '1',
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('3', '0', '', '8', '张三', '123@qq.com', '', '评论测试', null, '0:0:0:0:0:0:0:1', '2017-10-07 16:08:06', '0', '1');
INSERT INTO `comment` VALUES ('4', '0', '', '8', 'Tom', '123@126.com', '', 'Tom来测试', null, '0:0:0:0:0:0:0:1', '2017-10-07 16:08:46', '0', '1');
INSERT INTO `comment` VALUES ('5', '0', '', '14', 'Jack', '666@qq.com', '', 'Jack来此一游', null, '0:0:0:0:0:0:0:1', '2017-10-07 16:09:27', '0', '1');
INSERT INTO `comment` VALUES ('6', '5', 'Jack', '14', 'Jack', '666@qq.com', '', 'Jack回复Jack测试', null, '0:0:0:0:0:0:0:1', '2017-10-07 16:10:10', '0', '1');
INSERT INTO `comment` VALUES ('7', '5', 'Jack', '14', '娜美', '123456@sina.com', '', '娜美回复Jack测试', null, '0:0:0:0:0:0:0:1', '2017-10-07 16:10:53', '0', '1');
INSERT INTO `comment` VALUES ('8', '0', '', '9', '苏珊', '1212@sina.com', '', '苏珊来过', null, '0:0:0:0:0:0:0:1', '2017-10-07 16:11:36', '0', '1');
INSERT INTO `comment` VALUES ('11', '0', '', '13', '多伦', 'duolun@gmail.com', '', '多伦路过', null, '0:0:0:0:0:0:0:1', '2017-10-07 16:13:09', '0', '1');
INSERT INTO `comment` VALUES ('12', '0', '', '13', '贾克斯', 'jax@sohu.com', '', '我是贾克斯', null, '0:0:0:0:0:0:0:1', '2017-10-07 16:13:44', '0', '1');
INSERT INTO `comment` VALUES ('13', '12', '贾克斯', '13', '瑞克斯', 'ruikou@126.com', '', '贾克斯你好，我是瑞克斯', null, '0:0:0:0:0:0:0:1', '2017-10-07 16:14:32', '0', '1');
INSERT INTO `comment` VALUES ('14', '0', '', '39', '枫叶', '821060818@qq.com', 'http://wjwcloud.cn', 'test', null, '115.150.178.142', '2018-02-06 16:03:24', '1', '1');

-- ----------------------------
-- Table structure for `link`
-- ----------------------------
DROP TABLE IF EXISTS `link`;
CREATE TABLE `link` (
  `link_id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `link_url` varchar(255) DEFAULT NULL,
  `link_name` varchar(255) DEFAULT NULL,
  `link_image` varchar(255) DEFAULT NULL,
  `link_description` varchar(255) DEFAULT NULL,
  `link_owner_nickname` varchar(40) DEFAULT NULL,
  `link_owner_contact` varchar(255) DEFAULT NULL,
  `link_update_time` datetime DEFAULT NULL,
  `link_create_time` datetime DEFAULT NULL,
  `link_order` int(2) unsigned DEFAULT '1',
  `link_status` int(2) unsigned DEFAULT '1',
  PRIMARY KEY (`link_id`),
  UNIQUE KEY `link_name` (`link_name`)
) ENGINE=MyISAM AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of link
-- ----------------------------
INSERT INTO `link` VALUES ('1', 'http://wjwcloud.com', '枫叶博客', null, '一个码农的成长之路', null, '企鹅821060818', '2018-01-27 00:18:07', '2017-10-07 16:29:35', '1', '1');

-- ----------------------------
-- Table structure for `menu`
-- ----------------------------
DROP TABLE IF EXISTS `menu`;
CREATE TABLE `menu` (
  `menu_id` int(5) NOT NULL AUTO_INCREMENT,
  `menu_name` varchar(255) DEFAULT NULL,
  `menu_url` varchar(255) DEFAULT NULL,
  `menu_level` int(2) DEFAULT NULL,
  `menu_icon` varchar(255) DEFAULT NULL,
  `menu_order` int(2) DEFAULT NULL,
  `menu_status` int(2) DEFAULT '1',
  PRIMARY KEY (`menu_id`),
  UNIQUE KEY `menu_name` (`menu_name`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of menu
-- ----------------------------
INSERT INTO `menu` VALUES ('1', '留言板', '/message', '2', 'fa fa-comment', '1', '1');
INSERT INTO `menu` VALUES ('2', '个人简历', 'http://wwsocool.com/jianli', '2', '', '2', '0');
INSERT INTO `menu` VALUES ('3', '关于本站', '/aboutSite', '1', 'fa fa-info', '1', '1');
INSERT INTO `menu` VALUES ('4', '文章归档', '/articleFile', '1', 'fa-list-alt fa', '2', '1');
INSERT INTO `menu` VALUES ('5', '申请友链', '/applyLink', '1', 'fa fa-link', '3', '1');

-- ----------------------------
-- Table structure for `notice`
-- ----------------------------
DROP TABLE IF EXISTS `notice`;
CREATE TABLE `notice` (
  `notice_id` int(10) NOT NULL AUTO_INCREMENT,
  `notice_title` varchar(255) DEFAULT NULL,
  `notice_content` varchar(10000) DEFAULT NULL,
  `notice_create_time` datetime DEFAULT NULL,
  `notice_update_time` datetime DEFAULT NULL,
  `notice_status` int(2) unsigned DEFAULT '1',
  `notice_order` int(2) DEFAULT NULL,
  PRIMARY KEY (`notice_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of notice
-- ----------------------------
INSERT INTO `notice` VALUES ('1', '本站下载地址', '<p><span>本站后端基于 Spring+SpringMVC+Mybatis+JSP实现，对于初学SSM的小伙伴可以参考。</span></p><p><span>下载地址：<a target=\"_blank\" href=\"https://github.com/wjw0315/MapleBlog\">https://github.com/wjw0315/MapleBlog</a></span></p>', '2017-10-06 23:44:35', '2018-01-30 00:13:12', '1', '1');
INSERT INTO `notice` VALUES ('2', '博客不定时更新', '博客不定时更新', null, '2018-02-25 19:00:12', '1', '2');

-- ----------------------------
-- Table structure for `options`
-- ----------------------------
DROP TABLE IF EXISTS `options`;
CREATE TABLE `options` (
  `option_id` int(11) NOT NULL,
  `option_site_title` varchar(255) DEFAULT NULL,
  `option_site_descrption` varchar(255) DEFAULT NULL,
  `option_meta_descrption` varchar(255) DEFAULT NULL,
  `option_meta_keyword` varchar(255) DEFAULT NULL,
  `option_aboutsite_avatar` varchar(255) DEFAULT NULL,
  `option_aboutsite_title` varchar(255) DEFAULT NULL,
  `option_aboutsite_content` varchar(255) DEFAULT NULL,
  `option_aboutsite_wechat` varchar(255) DEFAULT NULL,
  `option_aboutsite_qq` varchar(255) DEFAULT NULL,
  `option_aboutsite_github` varchar(255) DEFAULT NULL,
  `option_aboutsite_weibo` varchar(255) DEFAULT NULL,
  `option_tongji` varchar(255) DEFAULT NULL,
  `option_status` int(2) DEFAULT '1',
  PRIMARY KEY (`option_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of options
-- ----------------------------
INSERT INTO `options` VALUES ('1', 'MapleBlog', '保持努力的惯性', '枫叶博客,一个简洁的Java博客,编程学习的一个新起点。', '枫叶,枫叶博客,Java博客,SSM博客,MapleBlog', '/uploads/2018\\5/4105b0ee76094b36e3191d2faacc7cd98f109d96.jpg', '博客初心', '编程学习的新起点，大学以及实习的成长记录。保持努力的惯性。', '/uploads/2018/1/weixin.jpg', '821060818', 'wjw0315', '平凡的天空0215', null, '1');

-- ----------------------------
-- Table structure for `page`
-- ----------------------------
DROP TABLE IF EXISTS `page`;
CREATE TABLE `page` (
  `page_id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `page_key` varchar(50) DEFAULT NULL,
  `page_title` varchar(50) DEFAULT NULL,
  `page_content` mediumtext,
  `page_create_time` datetime DEFAULT NULL,
  `page_update_time` datetime DEFAULT NULL,
  `page_view_count` int(10) unsigned DEFAULT '0',
  `page_comment_count` int(5) unsigned DEFAULT '0',
  `page_status` int(2) unsigned DEFAULT '1',
  PRIMARY KEY (`page_id`),
  UNIQUE KEY `page_key` (`page_key`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of page
-- ----------------------------
INSERT INTO `page` VALUES ('1', 'map', '站点地图', null, null, null, '0', '0', '2');
INSERT INTO `page` VALUES ('2', 'articleFile', '文章归档', null, null, null, '0', '0', '2');
INSERT INTO `page` VALUES ('3', 'message', '留言板', null, null, null, '0', '0', '2');
INSERT INTO `page` VALUES ('4', 'applyLink', '申请友链', null, null, null, '0', '0', '2');
INSERT INTO `page` VALUES ('5', 'aboutSite', '关于本站', '<h2>关于项目</h2>\r\n<p>该项目是博主学完&nbsp;<a title=\"查看与 ssm 相关的文章\" href=\"https://liuyanzhao.com/tag/ssm/\" target=\"_blank\">ssm</a>（spring+springmvc+mybatis）后，开始着手做的一个博客系统。<br>主要涉及的包括 jsp，jstl，el表达式，mysql，druid连接池，spring，springmvc，mybatis 等。<br>前端采用layui框架和某更鸟扒了一个[网站](<a href=\"http://wjwcloud.com\">http://wjwcloud.com</a>)的前台样式。通过maven管理依赖。</p>\r\n<h2>效果预览</h2>\r\n<p>预览地址：<a href=\"http://wjwcloud.com\" rel=\"noopener noreferrer\" target=\"_blank\">http://<font color=\"#cc0000\">wjwcloud</font>.com</a></p>\r\n<p>前台效果图</p><p><img src=\"/uploads/2018/1/qiantai.png\" alt=\"qiantai.png\"><br></p>\r\n<p>后台效果图<br></p>\r\n<p>&nbsp;<img src=\"/uploads/2018/1/houtai.png\" alt=\"houtai.png\"><br></p>\r\n<p><span>后台地址：/admin 或者 /login</span></p>\r\n<p>【 暂时没有开放后台的注册系统】</p>\r\n<h2>使用注意</h2>\r\n<p><strong>1、使用ide导入项目</strong></p>\r\n<p>将项目即（mapleblog文件夹）放到某个位置，用ide(如eclipse，intellij idea)导入，然后可以在ide里运行 tomcat，访问项目。</p>\r\n<p>因为该项目使用了`maven`，所有你需要新的ide需要有maven插件或者功能，这里就不多介绍了。</p>\r\n<p><img src=\"/uploads/2018/1/mapleblog.png\" alt=\"mapleblog.png\"><br></p>\r\n<p><strong>2、 导入数据库</strong></p>\r\n<p>新建数据库 `maple_blog`，导入数据库（即maple_blog.sql）。注意，数据库的编码和排序规则是utf-8和utf-8_general_ci</p>\r\n<p><img src=\"/uploads/2018/1/shujuku.png\" alt=\"shujuku.png\"><br></p>\r\n<p><strong>3、修改项目中的数据库连接信息</strong></p>\r\n<p>修改&nbsp;`db.properties` 文件，该文件很容易找到，在 src/main/resources 中，注意修改数据库地址、表名、用户名和密码。</p>\r\n<p><span><strong>如果不修改，会出现无法启动项目</strong></span></p>\r\n<p>&nbsp;</p>\r\n<p><strong>4、修改上传文件路径</strong></p>\r\n<p>该项目中，文件上传是传到本地，且和项目文件夹不在一起，就是说是分离的。比如你的项目是在d盘，你可以修改上传路径到e盘。当然我们访问上传的图片时，需要 &nbsp; 给tomcat添加静态资源映射，比如访问 localhost:8080/uplaods/1.jpg tomcat可以在你的e盘找到。这个在第5步会说。</p>\r\n<p>现在是修改上传文件路径，该文件在 src/main/java/com/wujiawei/blog/controller/common/uploadfilecontroller.java</p>\r\n<p>修改第33行的 `string rootpath =\"/www/uploads/\";` 为你的 uploads 的路径。</p>\r\n<p><span><strong>如果不修改，会出现无法上传图片</strong></span></p>\r\n<p>&nbsp;</p>\r\n<p><strong>5、给uploads文件夹添加静态资源映射</strong></p>\r\n<p>同第4步，我们已经修改了uploads路径，该路径就要和下面的docbase一致。<br>在 tomcat/conf/server.xml 的 <b>host</b> 标签内添加如下代码</p>\r\n<p></p><div><pre class=\"brush:xml\"><context path=\"/uplodas\" docbase=\"/www/tomcat7zz/MapleBlog\" debug=\"0\" reloadable=\"true\">\r\n</context></pre></div><br><p></p>\r\n<p>对啦，如果你使用的是ide，需要在该ide里修改。</p>\r\n<p>比如 intellij idea 是在tomcat配置中添加</p>\r\n<p><img src=\"/uploads/2018/1/tomcat1.png\" alt=\"tomcat1.png\"><br></p>\r\n<p><span><strong>如果不修改，会出现uploads的图片无法加载，网页打开有延迟</strong></span></p>\r\n<p>&nbsp;</p>\r\n<p><strong>6、修改 tomcat的首页为该项目</strong></p>\r\n<p>跟第5步相似</p>\r\n<p>该项目中的所有根路径都是 / ，没有使用相对路径的 `${pagecontext.request.getcontextpath}` ,因为如何相对路径不存在，该值就会为空字符串，以致 &nbsp; 首页链接我必须改为 / 。<br>所以，你的项目首页应该是 localhost:8080，而不是loclahost:8080/MapleBlog</p>\r\n<p>所以要在 server.xml 的host标签内里添加</p><div><pre class=\"brush:xml\"><context path=\"\" docbase=\"/www/tomcat/MapleBlog\" debug=\"0\" reloadable=\"true\">\r\n</context></pre></div><br><p>其中path=\"\"表示为首页,即localhost:8080或者127.0.0.1：8080<br>docbase-\"xxx\"是文件路径</p>\r\n<p><br></p><p><br></p>\r\n<p>对啦，如果你使用的是ide，需要在该ide里修改。</p>\r\n<p>比如 intellij idea 是在tomcat配置中添加</p>\r\n<p><img src=\"/uploads/2018/1/tpmcat2(1).png\" alt=\"tpmcat2.png\"><br></p>\r\n<p><span><strong>如果不修改，会出现内页很多链接不对</strong></span></p>\r\n<p>&nbsp;<b>7、对于第4步骤，可以将文件上传到项目的目录中：（同样的修改上传文件</b><b>uploadfilecontroller.java）</b></p><pre>String rootPath =request.getSession().getServletContext().getRealPath(<span>\"/resource/uploads\"</span>)<span>;</span></pre>\r\n<p>会在项目的resource目录下创建uploads的文件夹，</p><p>然后到springmvc.xml配置文件中添加静态资源映射：<br></p><pre><span>&lt;</span><span>mvc</span><span>:resources </span><span>mapping</span><span>=\"/uploads/**\" </span><span>location</span><span>=\"/resource/uploads/\"</span><span>&gt;<!--</span--><span>mvc</span><span>:resources&gt;</span></span></pre><p><br></p><p>下载地址：</p>\r\n<p>github地址：<a href=\"https://liuyanzhao.com/wp-content/themes/begin/inc/go.php?url=https://github.com/saysky/forestblog\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/wjw0315/MapleBlog</a></p>\r\n<p><em>（如果可以帮忙点一次star和fork）</em></p>\r\n<p>&nbsp;</p>\r\n<h2>更新</h2>\r\n<p>上一次更新：2017年10月10日14:02:02</p>', '2017-10-06 23:40:35', '2018-01-29 18:14:11', null, null, '1');

-- ----------------------------
-- Table structure for `tag`
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `tag_id` int(5) unsigned NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(20) DEFAULT NULL,
  `tag_description` varchar(255) DEFAULT NULL,
  `tag_status` int(2) unsigned DEFAULT '1',
  PRIMARY KEY (`tag_id`),
  UNIQUE KEY `tag_name` (`tag_name`)
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES ('1', 'Java', '', '1');
INSERT INTO `tag` VALUES ('2', '算法', '', '1');
INSERT INTO `tag` VALUES ('3', '数据结构', '', '1');
INSERT INTO `tag` VALUES ('4', 'C', '', '0');
INSERT INTO `tag` VALUES ('5', '操作系统', '', '1');
INSERT INTO `tag` VALUES ('6', '计算机网络', '', '1');
INSERT INTO `tag` VALUES ('8', '面试题', '', '1');
INSERT INTO `tag` VALUES ('9', '数据库', '', '1');
INSERT INTO `tag` VALUES ('10', 'MySQL', '', '1');
INSERT INTO `tag` VALUES ('11', 'Spring', '', '1');
INSERT INTO `tag` VALUES ('12', 'SpringMVC', '', '1');
INSERT INTO `tag` VALUES ('13', 'MyBatis', '', '1');
INSERT INTO `tag` VALUES ('14', 'JVM', '', '1');
INSERT INTO `tag` VALUES ('15', '设计模式', '', '1');
INSERT INTO `tag` VALUES ('16', '网络编程', '', '1');
INSERT INTO `tag` VALUES ('17', 'IO', '', '1');
INSERT INTO `tag` VALUES ('18', 'JSP', '', '1');
INSERT INTO `tag` VALUES ('19', 'Servlet', '', '1');
INSERT INTO `tag` VALUES ('20', 'JavaWeb', '', '1');
INSERT INTO `tag` VALUES ('21', 'Hibernate', '', '1');
INSERT INTO `tag` VALUES ('22', 'SQL', '', '1');
INSERT INTO `tag` VALUES ('23', 'Git', '', '1');
INSERT INTO `tag` VALUES ('24', 'markdown', '', '1');
INSERT INTO `tag` VALUES ('25', '多线程', '', '1');

-- ----------------------------
-- Table structure for `user`
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `user_id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `user_name` varchar(255) NOT NULL DEFAULT '',
  `user_pass` varchar(255) NOT NULL DEFAULT '',
  `user_nickname` varchar(255) NOT NULL DEFAULT '',
  `user_email` varchar(100) DEFAULT '',
  `user_url` varchar(100) DEFAULT '',
  `user_avatar` varchar(255) DEFAULT NULL,
  `user_last_login_ip` varchar(255) DEFAULT NULL,
  `user_register_time` datetime DEFAULT NULL,
  `user_last_login_time` datetime DEFAULT NULL,
  `user_status` int(2) unsigned DEFAULT '1',
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `user_name` (`user_name`),
  UNIQUE KEY `user_email` (`user_email`)
) ENGINE=MyISAM AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', 'wujiawei', 'wjw19950215', '枫叶', '821060818@qq.com', 'http://wjwcloud.cn', '/uploads/2018\\5/1.jpg', '0:0:0:0:0:0:0:1', '2017-10-06 21:56:33', '2018-06-06 00:09:34', '1');
